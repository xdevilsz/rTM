<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Resilient Trade Manager</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0a0d12;
      --bg-elev: rgba(19, 26, 36, 0.7);
      --panel: rgba(20, 28, 39, 0.88);
      --border: rgba(61, 77, 102, 0.45);
      --border-strong: rgba(86, 108, 140, 0.7);
      --text: #e7edf7;
      --muted: #a6b4c8;
      --accent: #7cc4ff;
      --accent-2: #9b8cff;
      --success: #27d07d;
      --warning: #f5a524;
      --shadow: 0 18px 40px rgba(3, 8, 20, 0.45);
      --chart-height: 460px;
    }
    body {
      font-family: "Inter", "SF Pro Text", "Segoe UI", system-ui, -apple-system, sans-serif;
      background:
        radial-gradient(900px 500px at 10% -10%, rgba(124, 196, 255, 0.18), transparent 60%),
        radial-gradient(900px 500px at 90% -20%, rgba(155, 140, 255, 0.12), transparent 55%),
        var(--bg);
      color: var(--text);
      margin: 0;
      padding: 24px;
      letter-spacing: 0.1px;
    }
    h1 {
      margin: 0 0 6px;
      font-size: 28px;
      font-weight: 600;
    }
    h2 {
      margin-top: 28px;
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    .muted { color: var(--muted); }
    .row { display: flex; gap: 14px; flex-wrap: wrap; }
    .card {
      background: linear-gradient(135deg, rgba(30, 40, 56, 0.7), rgba(19, 28, 40, 0.92));
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px 16px;
      min-width: 180px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    .label {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .value { font-size: 18px; margin-top: 6px; font-weight: 600; }
    .tabs { display: flex; gap: 10px; margin: 16px 0 6px; }
    .tab {
      background: rgba(20, 28, 39, 0.5);
      border: 1px solid transparent;
      color: var(--text);
      border-radius: 999px;
      padding: 8px 14px;
      cursor: pointer;
      transition: all 180ms ease;
    }
    .tab:hover { border-color: var(--border-strong); }
    .tab.active {
      background: linear-gradient(135deg, rgba(124, 196, 255, 0.25), rgba(155, 140, 255, 0.2));
      border-color: rgba(124, 196, 255, 0.5);
      box-shadow: 0 8px 18px rgba(61, 138, 255, 0.25);
    }
    .panel { display: none; }
    .panel.active { display: block; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom: 1px solid rgba(61, 77, 102, 0.35); padding: 10px 10px; font-size: 12px; }
    th {
      background: rgba(20, 28, 39, 0.85);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      position: sticky;
      top: 0;
      backdrop-filter: blur(6px);
    }
    tr:hover td { background: rgba(24, 34, 48, 0.55); }
    pre {
      background: rgba(15, 23, 34, 0.9);
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02);
      overflow: auto;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 12px;
      background: rgba(20, 28, 39, 0.7);
      box-shadow: var(--shadow);
    }
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
    }
    .dot.ok { background: var(--success); }
    .dot.warn { background: var(--warning); }
    .dot.error { background: #ff6b6b; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 12px; }
    input, select, button {
      background: rgba(20, 28, 39, 0.8);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 10px;
      transition: border-color 160ms ease, box-shadow 160ms ease;
    }
    .symbol-select {
      min-width: 160px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    input:focus, select:focus, button:focus {
      outline: none;
      border-color: rgba(124, 196, 255, 0.6);
      box-shadow: 0 0 0 3px rgba(124, 196, 255, 0.15);
    }
    button {
      cursor: pointer;
      border-color: rgba(124, 196, 255, 0.35);
      background: linear-gradient(135deg, rgba(124, 196, 255, 0.2), rgba(155, 140, 255, 0.16));
    }
    button:hover {
      border-color: rgba(124, 196, 255, 0.6);
      box-shadow: 0 8px 18px rgba(61, 138, 255, 0.2);
    }
    .analysis-loading {
      display: none;
      align-items: center;
      gap: 10px;
      margin-top: 12px;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(20, 28, 39, 0.7);
      font-size: 12px;
      color: var(--muted);
    }
    .analysis-loading.active { display: flex; }
    .analysis-loading-bar {
      width: 120px;
      height: 6px;
      border-radius: 999px;
      background: rgba(124, 196, 255, 0.12);
      position: relative;
      overflow: hidden;
    }
    .analysis-loading-bar::after {
      content: '';
      position: absolute;
      left: -30%;
      top: 0;
      height: 100%;
      width: 40%;
      background: linear-gradient(90deg, transparent, rgba(124, 196, 255, 0.8), transparent);
      animation: analysisBar 1.2s ease-in-out infinite;
    }
    .analysis-loading-gear {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(124, 196, 255, 0.6);
      border-top-color: transparent;
      animation: analysisSpin 0.9s linear infinite;
    }
    @keyframes analysisBar {
      0% { transform: translateX(0); }
      100% { transform: translateX(220%); }
    }
    @keyframes analysisSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .analysis-summary {
      margin-top: 16px;
      padding: 16px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: linear-gradient(135deg, rgba(24, 34, 48, 0.85), rgba(18, 28, 40, 0.92));
      box-shadow: var(--shadow);
    }
    .analysis-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 14px;
    }
    .analysis-summary h3 {
      margin: 0 0 10px;
      font-size: 15px;
    }
    .analysis-chart {
      margin: 10px 0 6px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(15, 22, 32, 0.65);
      position: relative;
    }
    .analysis-charts-grid {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      margin-top: 12px;
    }
    .analysis-chart-block h3 {
      margin: 0 0 6px;
      font-size: 14px;
    }
    .chart-zoom {
      position: absolute;
      top: 8px;
      right: 8px;
      border-radius: 999px;
      font-size: 10px;
      padding: 4px 8px;
      background: rgba(15, 22, 32, 0.7);
    }
    .analysis-chart svg {
      display: block;
      width: 100%;
      height: 180px;
    }
    .analysis-chart path {
      stroke: rgba(124, 196, 255, 0.9);
      stroke-width: 0.9;
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
      vector-effect: non-scaling-stroke;
    }
    .analysis-chart .axis-line {
      stroke: rgba(255, 255, 255, 0.08);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
    }
    .analysis-chart .grid-line {
      stroke: rgba(255, 255, 255, 0.04);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
    }
    .analysis-chart .axis-text {
      fill: var(--muted);
      font-size: 4.5px;
    }
    .analysis-chart .bar {
      fill: rgba(124, 196, 255, 0.35);
    }
    .analysis-chart .series-secondary {
      stroke: rgba(255, 179, 102, 0.9);
    }
    .analysis-chart .hover-line {
      stroke: rgba(255, 255, 255, 0.12);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
    }
    .analysis-chart .hover-point {
      fill: rgba(124, 196, 255, 0.9);
    }
    .analysis-chart .hover-point.secondary {
      fill: rgba(255, 179, 102, 0.9);
    }
    .analysis-chart .chart-tooltip {
      position: absolute;
      pointer-events: none;
      opacity: 0;
      transform: translate(-50%, -110%);
      background: rgba(10, 14, 20, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 11px;
      color: var(--text);
      white-space: nowrap;
      transition: opacity 120ms ease;
    }
    .chart-modal {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 16, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    .chart-modal.active { display: flex; }
    .chart-modal-content {
      width: min(92vw, 960px);
      background: rgba(12, 18, 26, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
    }
    .chart-modal-content .analysis-chart svg {
      height: 320px;
    }
    .analysis-chart .chart-title {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    details.analysis-details {
      margin-top: 8px;
      border-radius: 12px;
      padding: 6px 0;
    }
    details.analysis-details summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    .analysis-list {
      margin: 0;
      padding-left: 18px;
      color: var(--text);
    }
    .analysis-list li {
      margin-bottom: 8px;
      font-size: 13px;
      line-height: 1.4;
    }
    .tooltip-cell { position: relative; }
    .tooltip-cell:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 50%;
      top: -8px;
      transform: translate(-50%, -100%);
      opacity: 0;
      animation: tooltip-fade 160ms ease forwards;
      background: rgba(10, 16, 26, 0.95);
      border: 1px solid var(--border-strong);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
      white-space: nowrap;
      font-size: 11px;
      z-index: 10;
      box-shadow: var(--shadow);
      pointer-events: none;
    }
    .pnl-positive { color: var(--success); }
    .pnl-negative { color: #ff6b6b; }
    @keyframes tooltip-fade {
      from { opacity: 0; transform: translate(-50%, -110%); }
      to { opacity: 1; transform: translate(-50%, -100%); }
    }
    .score-bar {
      margin-top: 8px;
      height: 10px;
      background: rgba(61, 77, 102, 0.35);
      border-radius: 999px;
      overflow: hidden;
      position: relative;
    }
    .score-bar::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.12), transparent);
      pointer-events: none;
    }
    .score-fill {
      height: 100%;
      width: 0%;
      transition: width 220ms ease;
      background: #ff6b6b;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.25);
    }
    .modal {
      position: fixed;
      inset: 0;
      opacity: 0;
      pointer-events: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(5, 9, 15, 0.65);
      z-index: 100;
      transition: opacity 180ms ease;
    }
    .modal.active {
      display: flex;
      opacity: 1;
      pointer-events: auto;
    }
    .modal-card {
      width: min(560px, 100%);
      background: var(--panel);
      border: 1px solid var(--border-strong);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      transform: translateY(12px) scale(0.98);
      transition: transform 180ms ease;
    }
    .modal.active .modal-card {
      transform: translateY(0) scale(1);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .modal-body { display: grid; gap: 10px; }
    .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 6px; }
    .warning {
      border: 1px solid rgba(245, 165, 36, 0.6);
      background: rgba(245, 165, 36, 0.12);
      padding: 10px;
      border-radius: 10px;
      font-size: 12px;
      color: var(--warning);
    }
    .chart-wrap {
      height: var(--chart-height);
      border: 1px solid var(--border);
      border-radius: 14px;
      background:
        radial-gradient(520px 260px at 12% 0%, rgba(124, 196, 255, 0.08), transparent 60%),
        radial-gradient(420px 240px at 85% 0%, rgba(155, 140, 255, 0.08), transparent 55%),
        rgba(15, 23, 34, 0.82);
      box-shadow: var(--shadow);
      overflow: hidden;
      padding: 0;
      box-sizing: border-box;
      position: relative;
    }
    .chart-meta-row {
      display: grid;
      grid-template-columns: minmax(220px, 1fr) minmax(260px, 1.6fr);
      gap: 12px;
      margin: 8px 0 14px;
    }
    .chart-meta-box {
      border-radius: 12px;
      padding: 10px 14px;
      border: 1px solid rgba(124, 196, 255, 0.18);
      background: rgba(16, 24, 38, 0.65);
      color: var(--muted);
      font-size: 0.88rem;
      letter-spacing: 0.02em;
    }
    .chart-note {
      color: #c8d7ef;
      font-size: 0.85rem;
    }
    .chart-canvas {
      width: calc(100% - 24px);
      height: calc(100% - 30px);
      margin: 12px 12px 18px;
      position: relative;
    }
    .chart-drawings {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 4;
    }
    .chart-drawings.active {
      pointer-events: auto;
      cursor: crosshair;
    }
    .chart-drawing-rect {
      fill: rgba(124, 196, 255, 0.08);
      stroke: rgba(124, 196, 255, 0.7);
      stroke-width: 1.4;
    }
    .qr {
      width: 140px;
      height: 140px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(10, 16, 26, 0.6);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }
    .engraved-row {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 8px 0;
      border-top: 1px solid rgba(61, 77, 102, 0.2);
    }
    .engraved-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: rgba(214, 225, 240, 0.45);
    }
    .engraved-icon {
      width: 14px;
      height: 14px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.6;
    }
    .engraved-link {
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(231, 237, 247, 0.55);
      text-decoration: none;
      text-shadow:
        0 1px 1px rgba(0, 0, 0, 0.6),
        0 -1px 0 rgba(255, 255, 255, 0.04);
    }
    .chart-trade {
      position: absolute;
      top: 16px;
      left: 16px;
      z-index: 10;
      width: 220px;
      background: rgba(16, 23, 34, 0.86);
      border: 1px solid var(--border-strong);
      border-radius: 14px;
      padding: 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      display: grid;
      gap: 10px;
    }
    .trade-title {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(214, 225, 240, 0.65);
    }
    .trade-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .trade-actions button.buy {
      background: linear-gradient(135deg, rgba(39, 208, 125, 0.25), rgba(53, 244, 155, 0.12));
      border-color: rgba(39, 208, 125, 0.6);
    }
    .trade-actions button.sell {
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.25), rgba(255, 123, 123, 0.12));
      border-color: rgba(255, 107, 107, 0.6);
    }
    .height-control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .height-control input[type="range"] {
      accent-color: var(--accent);
      min-width: 140px;
    }
  </style>
</head>
<body>
  <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap;">
    <div>
      <h1 id="title_text">Resilient Trade Manager</h1>
      <div class="muted" id="subtitle">Trade Monitoring and Analytics</div>
    </div>
    <div class="pill">
      <select id="lang_select">
        <option value="en">EN</option>
        <option value="zh">ä¸­æ–‡</option>
      </select>
      <button id="open_trading_modal" class="tab" data-i18n="button_enable_trading">Enable Trading</button>
      <span id="status_dot" class="dot"></span>
      <span id="status_text">Waiting for product...</span>
    </div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="card">
      <div class="label" data-i18n="label_product">Product</div>
      <div class="value" id="product_name">-</div>
    </div>
    <div class="card">
      <div class="label" data-i18n="label_source">Source</div>
      <div class="value" id="source_mode">-</div>
    </div>
    <div class="card">
      <div class="label" data-i18n="label_exchange">Exchange</div>
      <div class="value" id="exchange_name">-</div>
    </div>
    <div class="card">
      <div class="label" data-i18n="label_last_traded">Last Traded</div>
      <div class="value" id="symbol_name">-</div>
    </div>
    <div class="card">
      <div class="label" data-i18n="label_session">Session</div>
      <div class="value" id="session_id">-</div>
    </div>
  </div>

  <div class="tabs">
    <button class="tab active" data-tab="overview" data-i18n="tab_overview">Overview</button>
    <button class="tab" data-tab="analysis" data-i18n="tab_analysis">Analysis</button>
    <button class="tab" data-tab="advanced-analysis" data-i18n="tab_advanced_analysis">Advanced Analysis</button>
    <button class="tab" data-tab="chart" data-i18n="tab_chart">Chart</button>
    <button class="tab" data-tab="positions" data-i18n="tab_positions">Positions</button>
    <button class="tab" data-tab="resilient-maker" data-i18n="tab_resilient_maker">Resilient Maker</button>
    <button class="tab" data-tab="other-products" data-i18n="tab_other_products">Other Products</button>
    <button class="tab" data-tab="about" data-i18n="tab_about">About</button>
  </div>

  <div id="panel-overview" class="panel active">
    <h2 data-i18n="heading_trade_consistency">Trade Consistency</h2>
    <div class="row">
      <div class="card">
        <div class="label" data-i18n="label_consistency_score">Consistency Score</div>
        <div class="value" id="consistency_score">-</div>
        <div class="score-bar"><div id="consistency_fill" class="score-fill"></div></div>
      </div>
      <div class="card"><div class="label" data-i18n="label_avg_interval">Avg Interval (s)</div><div class="value" id="avg_interval">-</div></div>
      <div class="card"><div class="label" data-i18n="label_interval_std">Interval Std (s)</div><div class="value" id="std_interval">-</div></div>
      <div class="card"><div class="label" data-i18n="label_buy_sell">Buy / Sell</div><div class="value" id="buy_sell_ratio">-</div></div>
      <div class="card"><div class="label" data-i18n="label_trades_per_hour">Trades / Hour</div><div class="value" id="trades_per_hour">-</div></div>
      <div class="card"><div class="label" data-i18n="label_logged_trades">Logged Trades</div><div class="value" id="logged_trades">-</div></div>
    </div>

    <h2 data-i18n="heading_trade_history">Trade History (Logged)</h2>
    <div class="controls">
      <label><span data-i18n="label_symbol">Symbol</span>
        <select id="filter_symbol" class="symbol-select">
          <option value="" data-i18n="all">ALL</option>
        </select>
      </label>
      <label><span data-i18n="label_side">Side</span>
        <select id="filter_side">
          <option value="" data-i18n="all">ALL</option>
          <option value="Buy" data-i18n="side_buy">Buy</option>
          <option value="Sell" data-i18n="side_sell">Sell</option>
        </select>
      </label>
      <label><span data-i18n="label_start_date">Start</span>
        <input id="filter_start" type="date">
      </label>
      <label><span data-i18n="label_end_date">End</span>
        <input id="filter_end" type="date">
      </label>
      <label><span data-i18n="label_min_qty">Min Qty</span>
        <input id="filter_min_qty" type="number" step="0.0001" value="0">
      </label>
      <label><span data-i18n="label_max_rows">Max Rows</span>
        <input id="filter_max_rows" type="number" min="1" max="2000" value="200">
      </label>
      <button id="apply_filters" data-i18n="button_apply">Apply</button>
      <button id="export_history" data-i18n="button_export_history">Export History</button>
      <button id="clear_history" data-i18n="button_clear_log">Clear Local Log</button>
    </div>

    <table id="fills_table">
      <thead>
        <tr>
          <th data-i18n="th_time">Time</th>
          <th data-i18n="th_symbol">Symbol</th>
          <th data-i18n="th_side">Side</th>
          <th data-i18n="th_qty">Qty</th>
          <th data-i18n="th_price">Price</th>
          <th data-i18n="th_notional">Notional</th>
          <th data-i18n="th_fee">Fee</th>
          <th data-i18n="th_tp">TP</th>
          <th data-i18n="th_order_id">Order ID</th>
        </tr>
      </thead>
      <tbody id="fills_body"></tbody>
    </table>
  </div>

  <div id="panel-resilient-maker" class="panel">
    <h2 data-i18n="heading_rm_snapshot">Resilient Maker Snapshot</h2>
    <div class="row">
      <div class="card"><div class="label" data-i18n="label_inventory">Inventory</div><div class="value" id="rm_inventory">-</div></div>
      <div class="card"><div class="label" data-i18n="label_session_pnl">Session PnL</div><div class="value" id="rm_session_pnl">-</div></div>
      <div class="card"><div class="label" data-i18n="label_realized_pnl">Realized PnL</div><div class="value" id="rm_realized_pnl">-</div></div>
      <div class="card"><div class="label" data-i18n="label_unrealized_pnl">Unrealized PnL</div><div class="value" id="rm_unrealized_pnl">-</div></div>
      <div class="card"><div class="label" data-i18n="label_fee_total">Fee Total</div><div class="value" id="rm_fee_total">-</div></div>
      <div class="card"><div class="label" data-i18n="label_funding_total">Funding Total</div><div class="value" id="rm_funding_total">-</div></div>
    </div>
    <h2 data-i18n="heading_glft_status">GLFT Status</h2>
    <pre id="rm_glft">{}</pre>
  </div>

  <div id="panel-analysis" class="panel">
    <h2 data-i18n="heading_advanced_analytics">Analysis</h2>
    <div class="controls">
      <label><span data-i18n="label_analysis_mode">Analysis Mode</span>
        <select id="analysis_mode">
          <option value="full" data-i18n="analysis_full">Full Analysis</option>
          <option value="performance" data-i18n="analysis_performance">Performance Metrics</option>
          <option value="risk" data-i18n="analysis_risk">Risk Metrics</option>
          <option value="maker_taker" data-i18n="analysis_maker_taker">Maker/Taker Breakdown</option>
        </select>
      </label>
      <label><span data-i18n="label_symbol">Symbol</span>
        <select id="analysis_symbol" class="symbol-select">
          <option value="" data-i18n="all">ALL</option>
        </select>
      </label>
      <label><span data-i18n="label_timeframe">Timeframe</span>
        <select id="analysis_timeframe">
          <option value="1" data-i18n="tf_1d">1 Day</option>
          <option value="7" selected data-i18n="tf_7d">7 Days</option>
          <option value="14" data-i18n="tf_14d">14 Days</option>
          <option value="30" data-i18n="tf_30d">30 Days</option>
          <option value="60" data-i18n="tf_60d">60 Days</option>
          <option value="90" data-i18n="tf_90d">90 Days</option>
          <option value="180" data-i18n="tf_180d">180 Days</option>
          <option value="365" data-i18n="tf_365d">365 Days</option>
        </select>
      </label>
      <label>
        <input id="analysis_use_range" type="checkbox">
        <span data-i18n="label_use_date_range">Use Date Range</span>
      </label>
      <label><span data-i18n="label_start_date">Start</span>
        <input id="analysis_start" type="date">
      </label>
      <label><span data-i18n="label_end_date">End</span>
        <input id="analysis_end" type="date">
      </label>
      <button id="refresh_analysis" data-i18n="button_refresh_analysis">Generate Analysis</button>
      <button id="export_analysis" data-i18n="button_export_analysis">Export Analysis</button>
      <button id="export_analysis_fills" data-i18n="button_export_fills">Export Fills</button>
      <button id="export_order_history" data-i18n="button_export_orders">Export Orders</button>
      <button id="compare_sources" data-i18n="button_compare_sources">Compare Sources</button>
    </div>
    <div id="analysis_loading" class="analysis-loading">
      <div class="analysis-loading-bar"></div>
      <div class="analysis-loading-gear"></div>
      <span data-i18n="analysis_generating">Generating analysis...</span>
    </div>
    
    <div id="analysis_content">
      <div class="muted" data-i18n="analysis_hint">Click "Generate Analysis" to load comprehensive trade analysis.</div>
    </div>
  </div>

  <div id="panel-advanced-analysis" class="panel">
    <h2 data-i18n="heading_advanced_analysis">Advanced Analysis</h2>
    <div class="controls">
      <label><span data-i18n="label_symbol">Symbol</span>
        <select id="advanced_symbol" class="symbol-select">
          <option value="" data-i18n="all">ALL</option>
        </select>
      </label>
      <label><span data-i18n="label_timeframe">Timeframe</span>
        <select id="advanced_timeframe">
          <option value="1" data-i18n="tf_1d">1 Day</option>
          <option value="7" selected data-i18n="tf_7d">7 Days</option>
          <option value="14" data-i18n="tf_14d">14 Days</option>
          <option value="30" data-i18n="tf_30d">30 Days</option>
          <option value="60" data-i18n="tf_60d">60 Days</option>
          <option value="90" data-i18n="tf_90d">90 Days</option>
          <option value="180" data-i18n="tf_180d">180 Days</option>
          <option value="365" data-i18n="tf_365d">365 Days</option>
        </select>
      </label>
      <label>
        <input id="advanced_use_range" type="checkbox">
        <span data-i18n="label_use_date_range">Use Date Range</span>
      </label>
      <label><span data-i18n="label_start_date">Start</span>
        <input id="advanced_start" type="date">
      </label>
      <label><span data-i18n="label_end_date">End</span>
        <input id="advanced_end" type="date">
      </label>
      <button id="generate_advanced" data-i18n="button_generate_advanced">Generate Advanced Analysis</button>
    </div>
    <div id="advanced_loading" class="analysis-loading">
      <div class="analysis-loading-bar"></div>
      <div class="analysis-loading-gear"></div>
      <span data-i18n="advanced_generating">Generating advanced analysis...</span>
    </div>
    <div id="advanced_content">
      <div class="muted" data-i18n="advanced_analysis_hint">Click "Generate Advanced Analysis" to explore time-based performance.</div>
    </div>
  </div>

  <div id="chart_modal" class="chart-modal">
    <div class="chart-modal-content">
      <div class="row" style="justify-content:space-between;align-items:center;">
        <div class="label" id="chart_modal_title">Chart</div>
        <button id="chart_modal_close" data-i18n="button_close">Close</button>
      </div>
      <div id="chart_modal_body"></div>
    </div>
  </div>

  <div id="panel-chart" class="panel">
    <h2 data-i18n="heading_chart">Chart</h2>
    <div class="controls">
      <label><span data-i18n="label_symbol">Symbol</span>
        <select id="chart_symbol" class="symbol-select">
          <option value="" data-i18n="all">ALL</option>
        </select>
      </label>
      <label><span data-i18n="label_custom_symbol">Search</span>
        <input id="chart_custom_symbol" type="text" placeholder="e.g. BTCUSDT">
      </label>
      <button id="chart_add_symbol" data-i18n="button_add_symbol">Add</button>
      <label><span data-i18n="label_interval">Interval</span>
        <select id="chart_interval">
          <option value="tick">Tick</option>
          <option value="1s">1s</option>
          <option value="5s">5s</option>
          <option value="1">1m</option>
          <option value="3">3m</option>
          <option value="5">5m</option>
          <option value="15">15m</option>
          <option value="30">30m</option>
          <option value="60">1h</option>
          <option value="120">2h</option>
          <option value="240">4h</option>
          <option value="D">1D</option>
        </select>
      </label>
      <label><span data-i18n="label_refresh_ms">Refresh (ms)</span>
        <select id="chart_refresh">
          <option value="250">250</option>
          <option value="500" selected>500</option>
          <option value="1000">1000</option>
          <option value="2000">2000</option>
          <option value="5000">5000</option>
          <option value="10000">10000</option>
          <option value="15000">15000</option>
        </select>
      </label>
      <label>
        <input id="chart_auto" type="checkbox" checked>
        <span data-i18n="label_auto_refresh">Auto Refresh</span>
      </label>
      <label>
        <input id="chart_show_breakeven" type="checkbox" checked>
        <span data-i18n="label_breakeven">Break-even</span>
      </label>
      <label>
        <input id="chart_show_liq" type="checkbox" checked>
        <span data-i18n="label_liquidation">Liquidation</span>
      </label>
      <label>
        <input id="chart_show_orders" type="checkbox" checked>
        <span data-i18n="label_active_orders">Active Orders</span>
      </label>
      <label>
        <input id="chart_show_trades" type="checkbox" checked>
        <span data-i18n="label_trades">Trades</span>
      </label>
      <label class="height-control">
        <span data-i18n="label_chart_height">Height</span>
        <input id="chart_height" type="range" min="320" max="720" step="20" value="460">
        <span id="chart_height_value">460px</span>
      </label>
      <button id="chart_reload" data-i18n="button_reload">Reload</button>
      <button id="chart_draw_box">Draw Box</button>
      <button id="chart_clear_drawings">Clear Drawings</button>
    </div>
    <div class="chart-meta-row">
      <div class="chart-meta-box" id="chart_status">Select a symbol to load klines.</div>
      <div class="chart-meta-box chart-note" id="chart_note"></div>
    </div>
    <div class="chart-wrap">
      <div class="chart-trade">
        <div class="trade-title" data-i18n="trade_panel_title">Chart Trading</div>
        <label><span data-i18n="label_qty">Qty</span>
          <input id="chart_order_qty" type="number" min="0" step="0.0001" value="0">
        </label>
        <label><span data-i18n="label_order_type">Order Type</span>
          <select id="chart_order_mode">
            <option value="market" data-i18n="order_mode_market">Market</option>
            <option value="best" data-i18n="order_mode_best">Best Bid/Offer</option>
            <option value="chase" data-i18n="order_mode_chase">Chase Limit</option>
            <option value="limit" data-i18n="order_mode_limit">Limit</option>
          </select>
        </label>
        <label id="chart_price_row"><span data-i18n="label_price">Price</span>
          <input id="chart_order_price" type="number" min="0" step="0.01" value="">
        </label>
        <label>
          <input id="chart_reduce_only" type="checkbox">
          <span data-i18n="label_reduce_only">Reduce Only</span>
        </label>
        <div class="trade-actions">
          <button class="buy" id="chart_buy" data-i18n="button_buy">Buy</button>
          <button class="sell" id="chart_sell" data-i18n="button_sell">Sell</button>
        </div>
      </div>
      <div class="chart-canvas" id="chart_container">
        <svg id="chart_drawings" class="chart-drawings" width="100%" height="100%"></svg>
      </div>
    </div>
  </div>

  <div id="panel-positions" class="panel">
    <h2 data-i18n="heading_current_positions">Current Positions</h2>
    <div class="controls">
      <button id="refresh_positions" data-i18n="button_fetch_positions">Fetch Current Positions</button>
    </div>
    <div id="positions_content">
      <div class="muted" data-i18n="positions_hint">Click "Refresh Positions" to load current positions.</div>
    </div>

    <h2 data-i18n="heading_active_orders">Active Orders</h2>
    <div class="controls">
      <button id="refresh_orders" data-i18n="button_fetch_orders">Fetch Active Orders</button>
    </div>
    <div id="orders_content">
      <div class="muted" data-i18n="orders_hint">Fetch active orders (API credentials required).</div>
    </div>
  </div>

  <div id="position_modal" class="modal">
    <div class="modal-card">
      <div class="modal-header">
        <h2 data-i18n="position_modal_title">Position Controls</h2>
        <button id="close_position_modal" data-i18n="button_close">Close</button>
      </div>
      <div class="modal-body">
        <div class="row">
          <div class="card"><div class="label" data-i18n="label_symbol">Symbol</div><div class="value" id="position_modal_symbol">-</div></div>
          <div class="card"><div class="label" data-i18n="label_side">Side</div><div class="value" id="position_modal_side">-</div></div>
          <div class="card"><div class="label" data-i18n="label_qty">Qty</div><div class="value" id="position_modal_qty">-</div></div>
        </div>
        <label><span data-i18n="label_take_profit">Take Profit</span>
          <input id="position_tp" type="number" min="0" step="0.01" value="">
        </label>
        <label><span data-i18n="label_stop_loss">Stop Loss</span>
          <input id="position_sl" type="number" min="0" step="0.01" value="">
        </label>
      </div>
      <div class="modal-actions">
        <button id="position_set_tpsl" data-i18n="button_set_tpsl">Set TP/SL</button>
        <button id="position_smart_tp" data-i18n="button_smart_tp">Smart TP</button>
        <button id="position_smart_sl" data-i18n="button_smart_sl">Smart SL</button>
        <button id="position_close" data-i18n="button_close_position">Close Position</button>
      </div>
    </div>
  </div>

  <div id="panel-other-products" class="panel">
    <h2 data-i18n="heading_other_products">Other Products</h2>
    <div class="muted" data-i18n="other_products_hint">No additional products detected. Future modules will appear here automatically.</div>
  </div>

  <div id="panel-about" class="panel">
    <h2 data-i18n="heading_about">About</h2>
    <div class="card" style="max-width:720px;">
      <div class="value" data-i18n="about_credit">This Trade Manager is powered by Resilient Lab 505.</div>
      <div style="margin-top:10px;" class="muted" data-i18n="about_contact">
        Business contact: contact@resilientlab505.com
      </div>
      <div style="margin-top:16px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <button id="open_donate" class="tab"><span data-i18n="button_donate">ðŸ’œ Donate</span></button>
      </div>
      <div class="engraved-row" style="margin-top:18px;">
        <span class="engraved-label">
          <svg class="engraved-icon" viewBox="0 0 24 24" aria-hidden="true">
            <rect x="3" y="7" width="18" height="10" rx="3"></rect>
            <polygon points="11,10 16,12 11,14" fill="none"></polygon>
          </svg>
          <span data-i18n="about_youtube_label">YouTube</span>
        </span>
        <a class="engraved-link" href="https://www.youtube.com/@resilientlab505" target="_blank" rel="noreferrer">youtube.com/@resilientlab505</a>
      </div>
      <div class="engraved-row">
        <span class="engraved-label">
          <svg class="engraved-icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M4 12l16-7-4 14-5-4-3 2 1-4z"></path>
          </svg>
          <span data-i18n="about_telegram_label">Telegram</span>
        </span>
        <a class="engraved-link" href="https://t.me/resilientlab505" target="_blank" rel="noreferrer">@resilientlab505</a>
      </div>
      <div class="engraved-row">
        <span class="engraved-label">
          <svg class="engraved-icon" viewBox="0 0 24 24" aria-hidden="true">
            <rect x="3" y="5" width="18" height="14" rx="2"></rect>
            <line x1="3" y1="9" x2="21" y2="9"></line>
            <circle cx="7" cy="7" r="0.8"></circle>
            <circle cx="11" cy="7" r="0.8"></circle>
          </svg>
          <span data-i18n="about_website_label">Website</span>
        </span>
        <a class="engraved-link" href="https://www.resilientlab505.com" target="_blank" rel="noreferrer">www.resilientlab505.com</a>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

  <div id="trading_modal" class="modal">
    <div class="modal-card">
      <div class="modal-header">
        <h2 data-i18n="heading_enable_trading">Enable Trading</h2>
        <button id="close_trading_modal" data-i18n="button_close">Close</button>
      </div>
      <div class="modal-body">
        <div class="warning" data-i18n="trading_warning">
          Trading via API carries risk. Use restricted keys, avoid high leverage, and keep funds separated. Keys are stored in server memory for this session only.
        </div>
        <label>
          <input id="trade_ack" type="checkbox">
          <span data-i18n="trading_ack">I understand the risks and want to continue.</span>
        </label>
        <label>
          <input id="trade_use_env" type="checkbox">
          <span data-i18n="trading_use_env">Use API keys from .env (if available)</span>
        </label>
        <label><span data-i18n="label_api_key">API Key</span>
          <input id="trade_api_key" type="password" placeholder="Bybit API key" disabled data-i18n-placeholder="placeholder_api_key">
        </label>
        <label><span data-i18n="label_api_secret">API Secret</span>
          <input id="trade_api_secret" type="password" placeholder="Bybit API secret" disabled data-i18n-placeholder="placeholder_api_secret">
        </label>
        <label><span data-i18n="label_mode">Mode</span>
          <select id="trade_mode" disabled>
            <option value="close_only" data-i18n="mode_close_only">Enable Close Only</option>
            <option value="open_close" data-i18n="mode_open_close">Enable Open/Close</option>
          </select>
        </label>
        <label>
          <input id="trade_demo" type="checkbox" disabled>
          <span data-i18n="label_demo">Demo (REST-only, for order testing)</span>
        </label>
      </div>
      <div class="modal-actions">
        <button id="enable_trading" disabled data-i18n="button_enable_trading">Enable Trading</button>
        <button id="disable_trading" data-i18n="button_logout">Log Out</button>
      </div>
      <div class="muted" id="trade_status" data-i18n="status_trading_prompt">Trading disabled.</div>
    </div>
  </div>

  <div id="donate_modal" class="modal">
    <div class="modal-card">
      <div class="modal-header">
        <h2 data-i18n="donate_title">Support This Dashboard</h2>
        <button id="close_donate_modal" data-i18n="button_close">Close</button>
      </div>
      <div class="modal-body">
        <div class="muted" data-i18n="donate_note">
          Donations are optional and never required. Thank you for supporting Resilient Lab 505.
        </div>
        <div class="row">
          <div class="card" style="min-width:240px;">
            <div class="label" data-i18n="donate_evm_label">ETH / BSC / POL / ARB (EVM)</div>
            <div style="margin-top:8px;">
              <img class="qr" src="https://api.qrserver.com/v1/create-qr-code/?size=140x140&data=0x6E5a912588b1dAe7556DcD35EE8C2d8a9bC82Da8" alt="EVM QR">
            </div>
            <div class="muted" style="margin-top:8px;word-break:break-all;">
              0x6E5a912588b1dAe7556DcD35EE8C2d8a9bC82Da8
            </div>
          </div>
          <div class="card" style="min-width:240px;">
            <div class="label" data-i18n="donate_trc_label">TRC</div>
            <div style="margin-top:8px;">
              <img class="qr" src="https://api.qrserver.com/v1/create-qr-code/?size=140x140&data=TVWKt5ZZDdp9MXaqk9jTKnZsfz3q3Zwa5Q" alt="TRC QR">
            </div>
            <div class="muted" style="margin-top:8px;word-break:break-all;">
              TVWKt5ZZDdp9MXaqk9jTKnZsfz3q3Zwa5Q
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const HISTORY_KEY = 'trade_optimizer_history_v1';
    const MAX_HISTORY = 5000;
    const state = {
      history: [],
      historyIndex: new Set(),
      product: null,
      exchange: null,
      metrics: null,
      metricsSymbols: [],
      tradingEnabled: false,
      tradingMode: '',
      tradingHasEnv: false,
      chartRange: null,
      chartMarkerSignature: '',
      chartOrderSignature: '',
      ordersCache: [],
      ordersCacheSymbol: '',
      ordersLoaded: false,
      chartVisible: false,
      chartLastOverlayTs: 0,
      positionSymbols: [],
      positionCache: {},
      activePositionSymbol: '',
      customSymbols: [],
      streamInterval: '',
      lastKlineSymbol: '',
      lastKlineInterval: '',
      chartHasLoaded: false,
      lastKlineTime: 0,
      newCandleCount: 0,
      analysisData: null,
      analysisMode: 'full',
      analysisCompare: null,
      advancedData: null
    };
    let chart = null;
    let candleSeries = null;
    let chartTimer = null;
    let chartOverlayTimer = null;
    let chartPositionLines = [];
    let chartOrderLines = [];
    let chartMarkersCache = [];
    let tickSeries = null;
    let tradeStream = null;
    let streamCandles = [];
    let tickPoints = [];
    let tickUpdateQueued = false;
    let lastTickTime = 0;
    let suppressRangeTracking = false;
    let chartKlinesCache = [];
    let drawMode = null;
    let drawStart = null;
    let drawTempRect = null;
    let drawings = [];
    const TICK_MAX_POINTS = 2000;
    const TICK_TRIM_EVERY = 100;
    const I18N = {
      en: {
        title: 'Resilient Trade Manager',
        subtitle_monitoring: 'Trade Monitoring and Analytics',
        subtitle_bybit: 'Bybit API direct monitoring',
        status_waiting_product: 'Waiting for product...',
        status_waiting_data: 'Waiting for data',
        status_api_missing: 'API keys missing',
        status_trading_enabled: 'Trading Enabled',
        status_trading_disabled: 'Trading disabled.',
        status_trading_prompt: 'Trading disabled.',
        status_no_analysis: 'No analysis data available',
        status_analysis_hint: 'Click "Generate Analysis" to load comprehensive trade analysis.',
        status_positions_hint: 'Click "Refresh Positions" to load current positions.',
        status_orders_hint: 'Fetch active orders (API credentials required).',
        status_no_positions: 'No open positions',
        status_no_orders: 'No active orders.',
        status_orders_error: 'Error loading orders:',
        status_positions_error: 'Error loading positions:',
        status_analysis_error: 'Error loading analysis:',
        status_analysis_unavailable: 'Analysis not available. Make sure you are in sync or realtime mode.',
        label_product: 'Product',
        label_source: 'Source',
        label_exchange: 'Exchange',
        label_last_traded: 'Last Traded',
        label_session: 'Session',
        tab_overview: 'Overview',
        tab_analysis: 'Analysis',
        tab_advanced_analysis: 'Advanced Analysis',
        tab_chart: 'Chart',
        tab_positions: 'Positions',
        tab_resilient_maker: 'Resilient Maker',
        tab_other_products: 'Other Products',
        tab_about: 'About',
        heading_trade_consistency: 'Trade Consistency',
        label_consistency_score: 'Consistency Score',
        label_avg_interval: 'Avg Interval (s)',
        label_interval_std: 'Interval Std (s)',
        label_buy_sell: 'Buy / Sell',
        label_trades_per_hour: 'Trades / Hour',
        label_logged_trades: 'Logged Trades',
        heading_trade_history: 'Trade History (Logged)',
        label_symbol: 'Symbol',
        label_side: 'Side',
        side_buy: 'Buy',
        side_sell: 'Sell',
        label_min_qty: 'Min Qty',
        label_max_rows: 'Max Rows',
        label_start_date: 'Start',
        label_end_date: 'End',
        label_use_date_range: 'Use Date Range',
        button_apply: 'Apply',
        button_export_history: 'Export History',
        button_clear_log: 'Clear Local Log',
        th_time: 'Time',
        th_symbol: 'Symbol',
        th_side: 'Side',
        th_qty: 'Qty',
        th_price: 'Price',
        th_notional: 'Notional',
        th_fee: 'Fee',
        th_tp: 'TP',
        th_order_id: 'Order ID',
        heading_rm_snapshot: 'Resilient Maker Snapshot',
        label_inventory: 'Inventory',
        label_session_pnl: 'Session PnL',
        label_realized_pnl: 'Realized PnL',
        label_unrealized_pnl: 'Unrealized PnL',
        label_fee_total: 'Fee Total',
        label_funding_total: 'Funding Total',
        heading_glft_status: 'GLFT Status',
        heading_advanced_analytics: 'Analysis',
        heading_advanced_analysis: 'Advanced Analysis',
        label_analysis_mode: 'Analysis Mode',
        analysis_full: 'Full Analysis',
        analysis_performance: 'Performance Metrics',
        analysis_risk: 'Risk Metrics',
        analysis_maker_taker: 'Maker/Taker Breakdown',
        label_timeframe: 'Timeframe',
        tf_1d: '1 Day',
        tf_7d: '7 Days',
        tf_14d: '14 Days',
        tf_30d: '30 Days',
        tf_60d: '60 Days',
        tf_90d: '90 Days',
        tf_180d: '180 Days',
        tf_365d: '365 Days',
        button_refresh_analysis: 'Generate Analysis',
        analysis_generating: 'Generating analysis...',
        button_generate_advanced: 'Generate Advanced Analysis',
        advanced_generating: 'Generating advanced analysis...',
        button_export_analysis: 'Export Analysis',
        button_export_fills: 'Export Fills',
        button_export_orders: 'Export Orders',
        button_compare_sources: 'Compare Sources',
        analysis_hint: 'Click "Generate Analysis" to load comprehensive trade analysis.',
        advanced_analysis_hint: 'Click "Generate Advanced Analysis" to explore time-based performance.',
        analysis_heading_entry_exit: 'Average Entry / Exit',
        analysis_label_avg_entry_price: 'Avg Entry Price',
        analysis_label_avg_exit_price: 'Avg Exit Price',
        analysis_label_avg_entry_qty: 'Avg Entry Qty',
        analysis_label_avg_exit_qty: 'Avg Exit Qty',
        analysis_label_avg_entry_notional: 'Avg Entry Notional',
        analysis_label_avg_exit_notional: 'Avg Exit Notional',
        analysis_label_avg_entry_fee: 'Avg Entry Fee',
        analysis_label_avg_exit_fee: 'Avg Exit Fee',
        advanced_heading_time_correlation: 'Time vs PnL Correlation',
        advanced_label_corr_hour_pnl: 'Hour-of-Day vs PnL',
        advanced_label_corr_tradecount_pnl: 'Trade Count vs PnL',
        advanced_label_corr_volume_pnl: 'Notional vs PnL',
        advanced_heading_daily_performance: 'Day-on-Day Performance',
        advanced_heading_hourly_performance: 'Hour-on-Hour Performance',
        advanced_heading_hour_of_day: 'Hour-of-Day Performance',
        advanced_heading_symbol_hourly: 'Avg Buy/Sell per Hour (by Symbol)',
        advanced_heading_inventory_hourly: 'Inventory Build (Hourly)',
        advanced_heading_inventory_daily: 'Inventory Build (Daily)',
        advanced_heading_inventory_weekly: 'Inventory Build (Weekly)',
        advanced_heading_hourly_balance: 'Hourly PnL Curve (Proxy Balance)',
        advanced_balance_note: 'Proxy balance uses cumulative net PnL from fills; wallet-level PnL requires account asset endpoints.',
        advanced_label_date: 'Date',
        advanced_label_hour: 'Hour',
        advanced_label_week: 'Week',
        advanced_label_trades: 'Trades',
        advanced_label_notional: 'Notional',
        advanced_label_pnl: 'PnL',
        advanced_label_delta_trades: 'Î” Trades',
        advanced_label_delta_notional: 'Î” Notional',
        advanced_label_delta_pnl: 'Î” PnL',
        advanced_label_net_qty: 'Net Qty',
        advanced_label_cum_net_qty: 'Cumulative Net Qty',
        advanced_label_buy_count: 'Buy Count',
        advanced_label_sell_count: 'Sell Count',
        advanced_label_buy_qty: 'Buy Qty',
        advanced_label_sell_qty: 'Sell Qty',
        advanced_label_avg_buy_qty: 'Avg Buy Qty',
        advanced_label_avg_sell_qty: 'Avg Sell Qty',
        advanced_label_buy_notional: 'Buy Notional',
        advanced_label_sell_notional: 'Sell Notional',
        heading_chart: 'Chart',
        label_interval: 'Interval',
        label_refresh_ms: 'Refresh (ms)',
        label_auto_refresh: 'Auto Refresh',
        label_breakeven: 'Break-even',
        label_liquidation: 'Liquidation',
        label_active_orders: 'Active Orders',
        label_trades: 'Trades',
        button_reload: 'Reload',
        chart_hint: 'Select a symbol to load klines.',
        chart_zoom_hint: 'Auto refresh paused while zooming. Re-enable auto refresh to keep updating.',
        heading_current_positions: 'Current Positions',
        button_fetch_positions: 'Fetch Current Positions',
        positions_hint: 'Click "Refresh Positions" to load current positions.',
        heading_active_orders: 'Active Orders',
        button_fetch_orders: 'Fetch Active Orders',
        orders_hint: 'Fetch active orders (API credentials required).',
        heading_other_products: 'Other Products',
        other_products_hint: 'No additional products detected. Future modules will appear here automatically.',
        heading_about: 'About',
        about_credit: 'This Trade Manager is powered by Resilient Lab 505.',
        about_contact: 'Business contact: contact@resilientlab505.com',
        donate_title: 'Support This Dashboard',
        donate_note: 'Donations are optional and never required. Thank you for supporting Resilient Lab 505.',
        donate_evm_label: 'ETH / BSC / POL / ARB (EVM)',
        donate_trc_label: 'TRC',
        button_donate: 'ðŸ’œ Donate',
        about_youtube_label: 'YouTube',
        about_telegram_label: 'Telegram',
        about_website_label: 'Website',
        heading_enable_trading: 'Enable Trading',
        button_close: 'Close',
        trading_warning: 'Trading via API carries risk. Use restricted keys, avoid high leverage, and keep funds separated. Keys are stored in server memory for this session only.',
        trading_ack: 'I understand the risks and want to continue.',
        trading_use_env: 'Use API keys from .env (if available)',
        label_api_key: 'API Key',
        label_api_secret: 'API Secret',
        placeholder_api_key: 'Bybit API key',
        placeholder_api_secret: 'Bybit API secret',
        label_mode: 'Mode',
        mode_close_only: 'Enable Close Only',
        mode_open_close: 'Enable Open/Close',
        label_demo: 'Demo (REST-only, for order testing)',
        button_enable_trading: 'Enable Trading',
        button_logout: 'Log Out',
        all: 'ALL',
        analysis_heading_basic: 'Basic Statistics',
        analysis_heading_summary: 'Summary',
        analysis_heading_advice: 'Actionable Advice',
        analysis_heading_compare: 'Data Source Comparison',
        analysis_label_fills_rows: 'Fills Rows',
        analysis_label_orders_rows: 'Orders Rows',
        analysis_label_orders_filled: 'Orders Filled',
        analysis_label_fields_present: 'Fields Present',
        analysis_label_fetch_time: 'Fetch Time (ms)',
        analysis_heading_performance: 'Performance Metrics',
        analysis_heading_risk: 'Risk Metrics',
        analysis_heading_maker_taker: 'Maker vs Taker',
        analysis_heading_symbol_pnl: 'Symbol PnL',
        analysis_summary_empty: 'Not enough data to summarize yet.',
        analysis_advice_empty: 'No specific advice triggered by the current data.',
        analysis_label_total_trades: 'Total Trades',
        analysis_label_total_volume: 'Total Volume',
        analysis_label_net_pnl: 'Net PnL',
        analysis_label_total_fee: 'Total Fee',
        analysis_label_maker_trades: 'Maker Trades',
        analysis_label_taker_trades: 'Taker Trades',
        analysis_label_maker_pnl: 'Maker PnL',
        analysis_label_taker_pnl: 'Taker PnL',
        positions_table_symbol: 'Symbol',
        positions_table_side: 'Side',
        positions_table_size: 'Size',
        positions_table_avg_price: 'Avg Price',
        positions_table_mark_price: 'Mark Price',
        positions_table_unrealised: 'Unrealised PnL',
        positions_table_realised: 'Realised PnL',
        positions_table_leverage: 'Leverage',
        positions_table_actions: 'Actions',
        positions_table_manage: 'Manage',
        orders_table_symbol: 'Symbol',
        orders_table_side: 'Side',
        orders_table_type: 'Type',
        orders_table_qty: 'Qty',
        orders_table_price: 'Price',
        orders_table_status: 'Status',
        orders_table_action: 'Action',
        orders_cancel: 'Cancel',
        tooltip_current_realised: 'Current Realised',
        tooltip_funding: 'Funding',
        tooltip_closed_pnl: 'Closed PnL',
        tooltip_break_even: 'Break-even',
        tooltip_unrealised_pnl: 'Unrealised PnL',
        tooltip_realised_pnl: 'Realised PnL',
        chart_order_buy: 'Order (Buy)',
        chart_order_sell: 'Order (Sell)',
        chart_break_even: 'Break-even',
        chart_liq: 'Liq',
        label_chart_height: 'Height',
        label_custom_symbol: 'Search',
        button_add_symbol: 'Add',
        alert_missing_order: 'Missing order identifier.',
        alert_trading_required: 'Cancel requires trading to be enabled.',
        alert_cancel_confirm: 'Cancel order',
        alert_cancel_failed: 'Cancel failed.',
        alert_ack_risk: 'Please acknowledge the risks before enabling trading.',
        alert_keys_required: 'API key and secret are required.',
        alert_no_env: 'No .env keys detected on the server.',
        alert_enable_failed: 'Trading enable failed.',
        alert_disable_failed: 'Disable failed.',
        alert_export_error: 'Error exporting analysis'
        ,
        trade_panel_title: 'Chart Trading',
        label_qty: 'Qty',
        label_order_type: 'Order Type',
        order_mode_market: 'Market',
        order_mode_best: 'Best Bid/Offer',
        order_mode_chase: 'Chase Limit',
        order_mode_limit: 'Limit',
        label_price: 'Price',
        label_reduce_only: 'Reduce Only',
        button_buy: 'Buy',
        button_sell: 'Sell',
        position_modal_title: 'Position Controls',
        label_take_profit: 'Take Profit',
        label_stop_loss: 'Stop Loss',
        button_set_tpsl: 'Set TP/SL',
        button_smart_tp: 'Smart TP',
        button_smart_sl: 'Smart SL',
        button_close_position: 'Close Position',
        alert_trading_disabled: 'Trading is not enabled.',
        alert_qty_required: 'Enter a valid quantity.',
        alert_symbol_required: 'Select a symbol first.',
        alert_price_required: 'Enter a valid price.',
        alert_position_missing: 'Position not found.',
        alert_tpsl_required: 'Enter take profit and/or stop loss.',
        alert_order_failed: 'Order failed.',
        alert_action_failed: 'Action failed.'
      },
      zh: {
        title: 'Resilient äº¤æ˜“ç®¡ç†å™¨',
        subtitle_monitoring: 'äº¤æ˜“ç›‘æŽ§ä¸Žåˆ†æž',
        subtitle_bybit: 'Bybit API ç›´è¿žç›‘æŽ§',
        status_waiting_product: 'ç­‰å¾…äº§å“æ•°æ®...',
        status_waiting_data: 'ç­‰å¾…æ•°æ®',
        status_api_missing: 'ç¼ºå°‘ API å¯†é’¥',
        status_trading_enabled: 'äº¤æ˜“å·²å¯ç”¨',
        status_trading_disabled: 'äº¤æ˜“å·²ç¦ç”¨ã€‚',
        status_trading_prompt: 'äº¤æ˜“å·²ç¦ç”¨ã€‚',
        status_no_analysis: 'æš‚æ— åˆ†æžæ•°æ®',
        status_analysis_hint: 'ç‚¹å‡»â€œç”Ÿæˆåˆ†æžâ€åŠ è½½å®Œæ•´äº¤æ˜“åˆ†æžã€‚',
        status_positions_hint: 'ç‚¹å‡»â€œåˆ·æ–°æŒä»“â€åŠ è½½å½“å‰æŒä»“ã€‚',
        status_orders_hint: 'èŽ·å–æ´»è·ƒè®¢å•ï¼ˆéœ€è¦ API å‡­æ®ï¼‰ã€‚',
        status_no_positions: 'æš‚æ— æŒä»“',
        status_no_orders: 'æš‚æ— æ´»è·ƒè®¢å•ã€‚',
        status_orders_error: 'è®¢å•åŠ è½½å¤±è´¥ï¼š',
        status_positions_error: 'æŒä»“åŠ è½½å¤±è´¥ï¼š',
        status_analysis_error: 'åˆ†æžåŠ è½½å¤±è´¥ï¼š',
        status_analysis_unavailable: 'åˆ†æžä¸å¯ç”¨ï¼Œè¯·ç¡®è®¤å¤„äºŽåŒæ­¥æˆ–å®žæ—¶æ¨¡å¼ã€‚',
        label_product: 'äº§å“',
        label_source: 'æ¥æº',
        label_exchange: 'äº¤æ˜“æ‰€',
        label_last_traded: 'æœ€è¿‘æˆäº¤',
        label_session: 'ä¼šè¯',
        tab_overview: 'æ¦‚è§ˆ',
        tab_analysis: 'åˆ†æž',
        tab_advanced_analysis: 'é«˜çº§åˆ†æž',
        tab_chart: 'å›¾è¡¨',
        tab_positions: 'æŒä»“',
        tab_resilient_maker: 'Resilient Maker',
        tab_other_products: 'å…¶ä»–äº§å“',
        tab_about: 'å…³äºŽ',
        heading_trade_consistency: 'äº¤æ˜“ä¸€è‡´æ€§',
        label_consistency_score: 'ä¸€è‡´æ€§è¯„åˆ†',
        label_avg_interval: 'å¹³å‡é—´éš”ï¼ˆç§’ï¼‰',
        label_interval_std: 'é—´éš”æ ‡å‡†å·®ï¼ˆç§’ï¼‰',
        label_buy_sell: 'ä¹° / å–',
        label_trades_per_hour: 'æ¯å°æ—¶äº¤æ˜“æ•°',
        label_logged_trades: 'è®°å½•äº¤æ˜“æ•°',
        heading_trade_history: 'äº¤æ˜“åŽ†å²ï¼ˆå·²è®°å½•ï¼‰',
        label_symbol: 'äº¤æ˜“å¯¹',
        label_side: 'æ–¹å‘',
        side_buy: 'ä¹°',
        side_sell: 'å–',
        label_min_qty: 'æœ€å°æ•°é‡',
        label_max_rows: 'æœ€å¤§è¡Œæ•°',
        label_start_date: 'å¼€å§‹æ—¥æœŸ',
        label_end_date: 'ç»“æŸæ—¥æœŸ',
        label_use_date_range: 'ä½¿ç”¨æ—¥æœŸèŒƒå›´',
        button_apply: 'åº”ç”¨',
        button_export_history: 'å¯¼å‡ºåŽ†å²',
        button_clear_log: 'æ¸…é™¤æœ¬åœ°è®°å½•',
        th_time: 'æ—¶é—´',
        th_symbol: 'äº¤æ˜“å¯¹',
        th_side: 'æ–¹å‘',
        th_qty: 'æ•°é‡',
        th_price: 'ä»·æ ¼',
        th_notional: 'åä¹‰ä»·å€¼',
        th_fee: 'æ‰‹ç»­è´¹',
        th_tp: 'æ­¢ç›ˆ',
        th_order_id: 'è®¢å•å·',
        heading_rm_snapshot: 'Resilient Maker å¿«ç…§',
        label_inventory: 'åº“å­˜',
        label_session_pnl: 'ä¼šè¯ç›ˆäº',
        label_realized_pnl: 'å·²å®žçŽ°ç›ˆäº',
        label_unrealized_pnl: 'æœªå®žçŽ°ç›ˆäº',
        label_fee_total: 'æ‰‹ç»­è´¹åˆè®¡',
        label_funding_total: 'èµ„é‡‘è´¹åˆè®¡',
        heading_glft_status: 'GLFT çŠ¶æ€',
        heading_advanced_analytics: 'åˆ†æž',
        heading_advanced_analysis: 'é«˜çº§åˆ†æž',
        label_analysis_mode: 'åˆ†æžæ¨¡å¼',
        analysis_full: 'å®Œæ•´åˆ†æž',
        analysis_performance: 'ç»©æ•ˆæŒ‡æ ‡',
        analysis_risk: 'é£Žé™©æŒ‡æ ‡',
        analysis_maker_taker: 'Maker/Taker åˆ†æž',
        label_timeframe: 'æ—¶é—´èŒƒå›´',
        tf_1d: '1 å¤©',
        tf_7d: '7 å¤©',
        tf_14d: '14 å¤©',
        tf_30d: '30 å¤©',
        tf_60d: '60 å¤©',
        tf_90d: '90 å¤©',
        tf_180d: '180 å¤©',
        tf_365d: '365 å¤©',
        button_refresh_analysis: 'ç”Ÿæˆåˆ†æž',
        analysis_generating: 'åˆ†æžç”Ÿæˆä¸­...',
        button_generate_advanced: 'ç”Ÿæˆé«˜çº§åˆ†æž',
        advanced_generating: 'é«˜çº§åˆ†æžç”Ÿæˆä¸­...',
        button_export_analysis: 'å¯¼å‡ºåˆ†æž',
        button_export_fills: 'å¯¼å‡ºé€ç¬”',
        button_export_orders: 'å¯¼å‡ºè®¢å•',
        button_compare_sources: 'æ¥æºå¯¹æ¯”',
        analysis_hint: 'ç‚¹å‡»â€œç”Ÿæˆåˆ†æžâ€åŠ è½½å®Œæ•´äº¤æ˜“åˆ†æžã€‚',
        advanced_analysis_hint: 'ç‚¹å‡»â€œç”Ÿæˆé«˜çº§åˆ†æžâ€æŸ¥çœ‹æ—¶é—´ç»´åº¦è¡¨çŽ°ã€‚',
        analysis_heading_entry_exit: 'å¹³å‡è¿›å‡ºåœº',
        analysis_label_avg_entry_price: 'å¹³å‡è¿›åœºä»·',
        analysis_label_avg_exit_price: 'å¹³å‡å‡ºåœºä»·',
        analysis_label_avg_entry_qty: 'å¹³å‡è¿›åœºæ•°é‡',
        analysis_label_avg_exit_qty: 'å¹³å‡å‡ºåœºæ•°é‡',
        analysis_label_avg_entry_notional: 'å¹³å‡è¿›åœºåä¹‰',
        analysis_label_avg_exit_notional: 'å¹³å‡å‡ºåœºåä¹‰',
        analysis_label_avg_entry_fee: 'å¹³å‡è¿›åœºæ‰‹ç»­è´¹',
        analysis_label_avg_exit_fee: 'å¹³å‡å‡ºåœºæ‰‹ç»­è´¹',
        advanced_heading_time_correlation: 'äº¤æ˜“æ—¶é—´ vs ç›ˆäºç›¸å…³',
        advanced_label_corr_hour_pnl: 'å°æ—¶æ®µ vs ç›ˆäº',
        advanced_label_corr_tradecount_pnl: 'äº¤æ˜“é¢‘æ¬¡ vs ç›ˆäº',
        advanced_label_corr_volume_pnl: 'åä¹‰é‡‘é¢ vs ç›ˆäº',
        advanced_heading_daily_performance: 'æŒ‰æ—¥è¡¨çŽ°',
        advanced_heading_hourly_performance: 'æŒ‰å°æ—¶è¡¨çŽ°',
        advanced_heading_hour_of_day: 'æ—¥å†…å°æ—¶è¡¨çŽ°',
        advanced_heading_symbol_hourly: 'æŒ‰äº¤æ˜“å¯¹æ¯å°æ—¶å¹³å‡ä¹°å–',
        advanced_heading_inventory_hourly: 'åº“å­˜å˜åŒ–ï¼ˆå°æ—¶ï¼‰',
        advanced_heading_inventory_daily: 'åº“å­˜å˜åŒ–ï¼ˆæ¯æ—¥ï¼‰',
        advanced_heading_inventory_weekly: 'åº“å­˜å˜åŒ–ï¼ˆæ¯å‘¨ï¼‰',
        advanced_heading_hourly_balance: 'æ¯å°æ—¶ç›ˆäºæ›²çº¿ï¼ˆä½™é¢ä»£ç†ï¼‰',
        advanced_balance_note: 'ä½™é¢ä»£ç†ä½¿ç”¨é€ç¬”ç´¯è®¡å‡€ç›ˆäºï¼›é’±åŒ…çº§ç›ˆäºéœ€æŽ¥å…¥è´¦æˆ·èµ„äº§ç«¯ç‚¹ã€‚',
        advanced_label_date: 'æ—¥æœŸ',
        advanced_label_hour: 'å°æ—¶',
        advanced_label_week: 'å‘¨',
        advanced_label_trades: 'äº¤æ˜“æ•°',
        advanced_label_notional: 'åä¹‰é‡‘é¢',
        advanced_label_pnl: 'ç›ˆäº',
        advanced_label_delta_trades: 'äº¤æ˜“æ•°å˜åŒ–',
        advanced_label_delta_notional: 'åä¹‰å˜åŒ–',
        advanced_label_delta_pnl: 'ç›ˆäºå˜åŒ–',
        advanced_label_net_qty: 'å‡€æ•°é‡',
        advanced_label_cum_net_qty: 'ç´¯è®¡å‡€æ•°é‡',
        advanced_label_buy_count: 'ä¹°å…¥ç¬”æ•°',
        advanced_label_sell_count: 'å–å‡ºç¬”æ•°',
        advanced_label_buy_qty: 'ä¹°å…¥æ•°é‡',
        advanced_label_sell_qty: 'å–å‡ºæ•°é‡',
        advanced_label_avg_buy_qty: 'å¹³å‡ä¹°å…¥æ•°é‡',
        advanced_label_avg_sell_qty: 'å¹³å‡å–å‡ºæ•°é‡',
        advanced_label_buy_notional: 'ä¹°å…¥åä¹‰',
        advanced_label_sell_notional: 'å–å‡ºåä¹‰',
        heading_chart: 'å›¾è¡¨',
        label_interval: 'å‘¨æœŸ',
        label_refresh_ms: 'åˆ·æ–°ï¼ˆæ¯«ç§’ï¼‰',
        label_auto_refresh: 'è‡ªåŠ¨åˆ·æ–°',
        label_breakeven: 'ä¿æœ¬ä»·',
        label_liquidation: 'å¼ºå¹³ä»·',
        label_active_orders: 'æ´»è·ƒè®¢å•',
        label_trades: 'æˆäº¤',
        button_reload: 'é‡æ–°åŠ è½½',
        chart_hint: 'è¯·é€‰æ‹©äº¤æ˜“å¯¹ä»¥åŠ è½½ K çº¿ã€‚',
        chart_zoom_hint: 'ç¼©æ”¾æ—¶å·²æš‚åœè‡ªåŠ¨åˆ·æ–°ï¼Œéœ€è¦æ—¶è¯·é‡æ–°å¼€å¯è‡ªåŠ¨åˆ·æ–°ã€‚',
        heading_current_positions: 'å½“å‰æŒä»“',
        button_fetch_positions: 'åˆ·æ–°æŒä»“',
        positions_hint: 'ç‚¹å‡»â€œåˆ·æ–°æŒä»“â€åŠ è½½å½“å‰æŒä»“ã€‚',
        heading_active_orders: 'æ´»è·ƒè®¢å•',
        button_fetch_orders: 'åˆ·æ–°æ´»è·ƒè®¢å•',
        orders_hint: 'èŽ·å–æ´»è·ƒè®¢å•ï¼ˆéœ€è¦ API å‡­æ®ï¼‰ã€‚',
        heading_other_products: 'å…¶ä»–äº§å“',
        other_products_hint: 'æš‚æ— å…¶ä»–äº§å“ã€‚åŽç»­æ¨¡å—å°†è‡ªåŠ¨å±•ç¤ºã€‚',
        heading_about: 'å…³äºŽ',
        about_credit: 'æœ¬äº¤æ˜“ç®¡ç†å™¨ç”± Resilient Lab 505 é©±åŠ¨ã€‚',
        about_contact: 'å•†åŠ¡è”ç³»ï¼šcontact@resilientlab505.com',
        donate_title: 'æ”¯æŒæ­¤çœ‹æ¿',
        donate_note: 'æèµ å®Œå…¨è‡ªæ„¿ä¸”éžå¿…é¡»ã€‚æ„Ÿè°¢æ”¯æŒ Resilient Lab 505ã€‚',
        donate_evm_label: 'ETH / BSC / POL / ARBï¼ˆEVMï¼‰',
        donate_trc_label: 'TRC',
        button_donate: 'ðŸ’œ æèµ ',
        about_youtube_label: 'YouTube',
        about_telegram_label: 'Telegram',
        about_website_label: 'ç½‘ç«™',
        heading_enable_trading: 'å¯ç”¨äº¤æ˜“',
        button_close: 'å…³é—­',
        trading_warning: 'API äº¤æ˜“å­˜åœ¨é£Žé™©ã€‚è¯·ä½¿ç”¨å—é™å¯†é’¥ã€é¿å…é«˜æ æ†ï¼Œå¹¶éš”ç¦»èµ„é‡‘ã€‚å¯†é’¥ä»…åœ¨æœ¬æ¬¡ä¼šè¯ä¿å­˜åœ¨æœåŠ¡å™¨å†…å­˜ä¸­ã€‚',
        trading_ack: 'æˆ‘å·²äº†è§£é£Žé™©å¹¶ç»§ç»­ã€‚',
        trading_use_env: 'ä½¿ç”¨ .env ä¸­çš„ API å¯†é’¥ï¼ˆå¦‚å¯ç”¨ï¼‰',
        label_api_key: 'API Key',
        label_api_secret: 'API Secret',
        placeholder_api_key: 'Bybit API key',
        placeholder_api_secret: 'Bybit API secret',
        label_mode: 'æ¨¡å¼',
        mode_close_only: 'ä»…å…è®¸å¹³ä»“',
        mode_open_close: 'å…è®¸å¼€ä»“/å¹³ä»“',
        label_demo: 'Demoï¼ˆä»… RESTï¼Œç”¨äºŽä¸‹å•æµ‹è¯•ï¼‰',
        button_enable_trading: 'å¯ç”¨äº¤æ˜“',
        button_logout: 'é€€å‡ºç™»å½•',
        all: 'å…¨éƒ¨',
        analysis_heading_basic: 'åŸºç¡€ç»Ÿè®¡',
        analysis_heading_summary: 'æ‘˜è¦',
        analysis_heading_advice: 'é’ˆå¯¹æ€§å»ºè®®',
        analysis_heading_compare: 'æ•°æ®æºå¯¹æ¯”',
        analysis_label_fills_rows: 'é€ç¬”è¡Œæ•°',
        analysis_label_orders_rows: 'è®¢å•è¡Œæ•°',
        analysis_label_orders_filled: 'æˆäº¤è®¢å•',
        analysis_label_fields_present: 'å­—æ®µè¦†ç›–',
        analysis_label_fetch_time: 'èŽ·å–è€—æ—¶(ms)',
        analysis_heading_performance: 'ç»©æ•ˆæŒ‡æ ‡',
        analysis_heading_risk: 'é£Žé™©æŒ‡æ ‡',
        analysis_heading_maker_taker: 'Maker vs Taker',
        analysis_heading_symbol_pnl: 'æŒ‰äº¤æ˜“å¯¹ç›ˆäº',
        analysis_summary_empty: 'æ•°æ®ä¸è¶³ï¼Œæš‚æ— æ³•ç”Ÿæˆæ‘˜è¦ã€‚',
        analysis_advice_empty: 'å½“å‰æ•°æ®æœªè§¦å‘å…·ä½“å»ºè®®ã€‚',
        analysis_label_total_trades: 'æ€»äº¤æ˜“æ•°',
        analysis_label_total_volume: 'æ€»æˆäº¤é‡',
        analysis_label_net_pnl: 'å‡€ç›ˆäº',
        analysis_label_total_fee: 'æ€»æ‰‹ç»­è´¹',
        analysis_label_maker_trades: 'Maker äº¤æ˜“',
        analysis_label_taker_trades: 'Taker äº¤æ˜“',
        analysis_label_maker_pnl: 'Maker ç›ˆäº',
        analysis_label_taker_pnl: 'Taker ç›ˆäº',
        positions_table_symbol: 'äº¤æ˜“å¯¹',
        positions_table_side: 'æ–¹å‘',
        positions_table_size: 'æ•°é‡',
        positions_table_avg_price: 'å‡ä»·',
        positions_table_mark_price: 'æ ‡è®°ä»·',
        positions_table_unrealised: 'æœªå®žçŽ°ç›ˆäº',
        positions_table_realised: 'å·²å®žçŽ°ç›ˆäº',
        positions_table_leverage: 'æ æ†',
        positions_table_actions: 'æ“ä½œ',
        positions_table_manage: 'ç®¡ç†',
        orders_table_symbol: 'äº¤æ˜“å¯¹',
        orders_table_side: 'æ–¹å‘',
        orders_table_type: 'ç±»åž‹',
        orders_table_qty: 'æ•°é‡',
        orders_table_price: 'ä»·æ ¼',
        orders_table_status: 'çŠ¶æ€',
        orders_table_action: 'æ“ä½œ',
        orders_cancel: 'æ’¤å•',
        tooltip_current_realised: 'å½“å‰å·²å®žçŽ°',
        tooltip_funding: 'èµ„é‡‘è´¹',
        tooltip_closed_pnl: 'å¹³ä»“ç›ˆäº',
        tooltip_break_even: 'ä¿æœ¬ä»·',
        tooltip_unrealised_pnl: 'æœªå®žçŽ°ç›ˆäº',
        tooltip_realised_pnl: 'å·²å®žçŽ°ç›ˆäº',
        chart_order_buy: 'ä¹°å•',
        chart_order_sell: 'å–å•',
        chart_break_even: 'ä¿æœ¬ä»·',
        chart_liq: 'å¼ºå¹³ä»·',
        label_chart_height: 'é«˜åº¦',
        label_custom_symbol: 'æœç´¢',
        button_add_symbol: 'æ·»åŠ ',
        alert_missing_order: 'ç¼ºå°‘è®¢å•æ ‡è¯†ã€‚',
        alert_trading_required: 'æ’¤å•éœ€è¦å…ˆå¯ç”¨äº¤æ˜“ã€‚',
        alert_cancel_confirm: 'ç¡®è®¤æ’¤é”€è®¢å•',
        alert_cancel_failed: 'æ’¤å•å¤±è´¥ã€‚',
        alert_ack_risk: 'è¯·ç¡®è®¤é£Žé™©æç¤ºåŽå†å¯ç”¨äº¤æ˜“ã€‚',
        alert_keys_required: 'è¯·è¾“å…¥ API Key å’Œ Secretã€‚',
        alert_no_env: 'æœåŠ¡å™¨æœªæ£€æµ‹åˆ° .env å¯†é’¥ã€‚',
        alert_enable_failed: 'å¯ç”¨äº¤æ˜“å¤±è´¥ã€‚',
        alert_disable_failed: 'ç¦ç”¨å¤±è´¥ã€‚',
        alert_export_error: 'å¯¼å‡ºåˆ†æžå¤±è´¥'
        ,
        trade_panel_title: 'å›¾è¡¨äº¤æ˜“',
        label_qty: 'æ•°é‡',
        label_order_type: 'è®¢å•ç±»åž‹',
        order_mode_market: 'å¸‚ä»·',
        order_mode_best: 'æœ€ä½³ä¹°å–',
        order_mode_chase: 'è¿½ä»·é™ä»·',
        order_mode_limit: 'é™ä»·',
        label_price: 'ä»·æ ¼',
        label_reduce_only: 'ä»…å‡ä»“',
        button_buy: 'ä¹°å…¥',
        button_sell: 'å–å‡º',
        position_modal_title: 'æŒä»“ç®¡ç†',
        label_take_profit: 'æ­¢ç›ˆ',
        label_stop_loss: 'æ­¢æŸ',
        button_set_tpsl: 'è®¾ç½®æ­¢ç›ˆ/æ­¢æŸ',
        button_smart_tp: 'æ™ºèƒ½æ­¢ç›ˆ',
        button_smart_sl: 'æ™ºèƒ½æ­¢æŸ',
        button_close_position: 'å¹³ä»“',
        alert_trading_disabled: 'äº¤æ˜“æœªå¯ç”¨ã€‚',
        alert_qty_required: 'è¯·è¾“å…¥æœ‰æ•ˆæ•°é‡ã€‚',
        alert_symbol_required: 'è¯·å…ˆé€‰æ‹©äº¤æ˜“å¯¹ã€‚',
        alert_price_required: 'è¯·è¾“å…¥æœ‰æ•ˆä»·æ ¼ã€‚',
        alert_position_missing: 'æœªæ‰¾åˆ°æŒä»“ã€‚',
        alert_tpsl_required: 'è¯·è¾“å…¥æ­¢ç›ˆå’Œ/æˆ–æ­¢æŸä»·æ ¼ã€‚',
        alert_order_failed: 'ä¸‹å•å¤±è´¥ã€‚',
        alert_action_failed: 'æ“ä½œå¤±è´¥ã€‚'
      }
    };
    let currentLang = 'en';

    function t(key) {
      const table = I18N[currentLang] || I18N.en;
      return table[key] || I18N.en[key] || key;
    }

    function applyTranslations() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (key) el.textContent = t(key);
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (key) el.setAttribute('placeholder', t(key));
      });
      const titleEl = document.getElementById('title_text');
      if (titleEl) titleEl.textContent = t('title');
      document.title = t('title');
      const subtitle = document.getElementById('subtitle');
      if (subtitle && subtitle.getAttribute('data-mode') !== 'bybit') {
        subtitle.textContent = t('subtitle_monitoring');
      }
      const statusText = document.getElementById('status_text');
      if (statusText && statusText.textContent === I18N.en.status_waiting_product) {
        statusText.textContent = t('status_waiting_product');
      }
      const chartStatus = document.getElementById('chart_status');
      if (chartStatus && chartStatus.textContent === I18N.en.chart_hint) {
        chartStatus.textContent = t('chart_hint');
      }
      const tradeStatus = document.getElementById('trade_status');
      if (tradeStatus && tradeStatus.textContent === I18N.en.status_trading_prompt) {
        tradeStatus.textContent = t('status_trading_prompt');
      }
    }

    function formatModeLabel(mode) {
      if (!mode) return '-';
      const normalized = String(mode).replace('_', ' ');
      if (normalized === 'realtime') return currentLang === 'zh' ? 'å®žæ—¶' : 'Realtime';
      if (normalized === 'sync') return currentLang === 'zh' ? 'åŒæ­¥' : 'Sync';
      if (normalized === 'bybit api') return currentLang === 'zh' ? 'API ç›´è¿ž' : 'API Direct';
      return normalized;
    }

    function getChartTimeFormatter() {
      const interval = document.getElementById('chart_interval')?.value || '1';
      const isDaily = interval === 'D';
      const isStream = isStreamInterval(interval);
      const locale = currentLang === 'zh' ? 'zh-CN' : 'en-US';
      const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
      const format = isDaily
        ? { year: 'numeric', month: 'short', day: '2-digit' }
        : isStream
          ? { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }
          : { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' };
      const formatter = new Intl.DateTimeFormat(locale, { ...format, timeZone });
      return (time) => {
        const ts = typeof time === 'object'
          ? Date.UTC(time.year, time.month - 1, time.day)
          : time * 1000;
        return formatter.format(new Date(ts));
      };
    }

    function getChartTickMarkFormatter() {
      const interval = document.getElementById('chart_interval')?.value || '1';
      const isDaily = interval === 'D';
      const isStream = isStreamInterval(interval);
      const locale = currentLang === 'zh' ? 'zh-CN' : 'en-US';
      const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
      const format = isDaily
        ? { year: 'numeric', month: 'short', day: '2-digit' }
        : isStream
          ? { hour: '2-digit', minute: '2-digit', second: '2-digit' }
          : { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' };
      const formatter = new Intl.DateTimeFormat(locale, { ...format, timeZone });
      return (time) => {
        const ts = typeof time === 'object'
          ? Date.UTC(time.year, time.month - 1, time.day)
          : time * 1000;
        return formatter.format(new Date(ts));
      };
    }

    function applyChartLocalization() {
      if (!chart) return;
      const interval = document.getElementById('chart_interval')?.value || '1';
      const isStream = isStreamInterval(interval);
      const localization = {
        locale: currentLang === 'zh' ? 'zh-CN' : 'en-US'
      };
      localization.timeFormatter = getChartTimeFormatter();
      chart.applyOptions({
        localization,
        timeScale: {
          tickMarkFormatter: getChartTickMarkFormatter(),
          timeVisible: true,
          secondsVisible: isStream,
          rightOffset: isStream ? 2 : 6,
          barSpacing: isStream ? 6 : 12
        }
      });
    }

    function updateChartHeight(value) {
      const heightValue = Number(value) || 460;
      const adjustedHeight = heightValue + 5;
      const root = document.documentElement;
      root.style.setProperty('--chart-height', `${adjustedHeight}px`);
      const label = document.getElementById('chart_height_value');
      if (label) label.textContent = `${adjustedHeight}px`;
      resizeChart();
    }

    function setLanguage(lang) {
      currentLang = I18N[lang] ? lang : 'en';
      const select = document.getElementById('lang_select');
      if (select) select.value = currentLang;
      applyTranslations();
      updateSymbolOptions();
      renderHistory();
      renderConsistency();
      if (state.ordersLoaded) {
        renderOrders(state.ordersCache || []);
      }
      applyChartLocalization();
      const tradingBtn = document.getElementById('open_trading_modal');
      if (state.tradingEnabled) {
        setTradeStatus(`${t('status_trading_enabled')} (${state.tradingMode.replace('_', '/')} ${currentLang === 'zh' ? 'æ¨¡å¼' : 'mode'}).`, true);
        if (tradingBtn) tradingBtn.textContent = t('status_trading_enabled');
      } else {
        setTradeStatus(t('status_trading_disabled'), false);
        if (tradingBtn) tradingBtn.textContent = t('button_enable_trading');
      }
      syncChartTradingState();
      fetchStatus();
    }

    function setText(id, value) {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
    }

    function loadHistory() {
      try {
        const raw = localStorage.getItem(HISTORY_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        const list = Array.isArray(parsed?.history) ? parsed.history : [];
        state.history = list;
        state.historyIndex = new Set(list.map(makeKey));
      } catch (e) {
        state.history = [];
        state.historyIndex = new Set();
      }
    }

    function saveHistory() {
      const payload = { version: 1, history: state.history };
      localStorage.setItem(HISTORY_KEY, JSON.stringify(payload));
    }

    function makeKey(fill) {
      const parts = [
        fill.order_id || '',
        fill.ts || '',
        fill.side || '',
        fill.price || '',
        fill.qty || ''
      ];
      return parts.join('|');
    }

    function normalizeFill(fill) {
      const qty = fill.qty ?? 0;
      const price = fill.price ?? 0;
      const notional = fill.notional ?? (qty && price ? qty * price : 0);
      return {
        ts: fill.ts || 0,
        order_id: fill.order_id || '',
        symbol: fill.symbol || fill.Symbol || '',
        side: fill.side || '',
        qty,
        price,
        notional,
        fee: fill.fee ?? '',
        fee_ccy: fill.fee_ccy || '',
        is_tp: !!fill.is_tp
      };
    }

    function mergeHistory(fills) {
      let added = 0;
      for (const f of fills) {
        const norm = normalizeFill(f);
        const key = makeKey(norm);
        if (!state.historyIndex.has(key)) {
          state.history.push(norm);
          state.historyIndex.add(key);
          added += 1;
        }
      }
      if (added > 0) {
        state.history.sort((a, b) => (b.ts || 0) - (a.ts || 0));
        if (state.history.length > MAX_HISTORY) {
          state.history = state.history.slice(0, MAX_HISTORY);
          state.historyIndex = new Set(state.history.map(makeKey));
        }
        saveHistory();
      }
    }

    function computeConsistency(fills) {
      const total = fills.length;
      if (total < 2) {
        return {
          score: 0,
          avgInterval: 0,
          stdInterval: 0,
          buyCount: 0,
          sellCount: 0,
          tradesPerHour: 0
        };
      }
      const sorted = fills.slice().sort((a, b) => (a.ts || 0) - (b.ts || 0));
      const intervals = [];
      for (let i = 1; i < sorted.length; i++) {
        const dt = (sorted[i].ts || 0) - (sorted[i - 1].ts || 0);
        if (dt > 0) intervals.push(dt);
      }
      const avg = intervals.reduce((a, b) => a + b, 0) / (intervals.length || 1);
      const variance = intervals.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / (intervals.length || 1);
      const std = Math.sqrt(variance);
      const cv = avg > 0 ? std / avg : 1;
      const timeScore = Math.max(0, 100 - Math.min(100, cv * 100));
      let buy = 0;
      let sell = 0;
      for (const f of fills) {
        const side = String(f.side || '').toLowerCase();
        if (side.startsWith('b')) buy += 1;
        if (side.startsWith('s')) sell += 1;
      }
      const balance = total > 0 ? Math.abs(buy - sell) / total : 1;
      const balanceScore = Math.max(0, 100 - Math.min(100, balance * 100));
      const score = Math.round(timeScore * 0.7 + balanceScore * 0.3);
      const firstTs = sorted[0].ts || 0;
      const lastTs = sorted[sorted.length - 1].ts || 0;
      const hours = (lastTs - firstTs) / 3600;
      const tradesPerHour = hours > 0 ? (total / hours) : total;
      return {
        score,
        avgInterval: avg,
        stdInterval: std,
        buyCount: buy,
        sellCount: sell,
        tradesPerHour
      };
    }

    function getDateRangeFromInputs(startId, endId) {
      const startVal = document.getElementById(startId)?.value || '';
      const endVal = document.getElementById(endId)?.value || '';
      let startTs = null;
      let endTs = null;
      if (startVal) {
        const parsed = Date.parse(`${startVal}T00:00:00Z`);
        if (!Number.isNaN(parsed)) startTs = parsed / 1000;
      }
      if (endVal) {
        const parsed = Date.parse(`${endVal}T23:59:59Z`);
        if (!Number.isNaN(parsed)) endTs = parsed / 1000;
      }
      return { startTs, endTs };
    }

    function filterFillsByDate(rows, startTs, endTs) {
      if (!startTs && !endTs) return rows;
      return rows.filter(r => {
        const ts = Number(r.ts || 0);
        if (startTs && ts < startTs) return false;
        if (endTs && ts > endTs) return false;
        return true;
      });
    }

    function getHistoryFilters() {
      const symbol = getHistorySymbol();
      const side = document.getElementById('filter_side').value;
      const minQty = parseFloat(document.getElementById('filter_min_qty').value || '0');
      const { startTs, endTs } = getDateRangeFromInputs('filter_start', 'filter_end');
      return { symbol, side, minQty, startTs, endTs };
    }

    function applyHistoryFilters(rows, filters) {
      let output = rows;
      if (filters.symbol) output = output.filter(r => r.symbol === filters.symbol);
      if (filters.side) output = output.filter(r => r.side === filters.side);
      if (!Number.isNaN(filters.minQty) && filters.minQty > 0) {
        output = output.filter(r => Number(r.qty || 0) >= filters.minQty);
      }
      output = filterFillsByDate(output, filters.startTs, filters.endTs);
      return output;
    }

    function getFilteredHistoryRows(limit) {
      const filters = getHistoryFilters();
      let rows = applyHistoryFilters(state.history.slice(), filters);
      if (limit) rows = rows.slice(0, limit);
      return rows;
    }

    function renderHistory() {
      const body = document.getElementById('fills_body');
      body.innerHTML = '';
      const maxRows = parseInt(document.getElementById('filter_max_rows').value || '200', 10);
      const limit = isNaN(maxRows) ? 200 : maxRows;
      const rows = getFilteredHistoryRows(limit);
      for (const r of rows) {
        const t = r.ts ? new Date(r.ts * 1000).toLocaleTimeString() : '';
        const fee = r.fee !== '' ? `${r.fee} ${r.fee_ccy || ''}` : '';
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td data-value="${r.ts || ''}">${t}</td>
          <td>${r.symbol || ''}</td>
          <td>${r.side ? (String(r.side).toLowerCase().startsWith('b') ? 'B' : 'S') : ''}</td>
          <td data-value="${r.qty || ''}">${r.qty ?? ''}</td>
          <td data-value="${r.price || ''}">${r.price ?? ''}</td>
          <td data-value="${r.notional || ''}">${r.notional ?? ''}</td>
          <td data-value="${r.fee || ''}">${fee}</td>
          <td>${r.is_tp ? 'Y' : ''}</td>
          <td>${r.order_id || ''}</td>
        `;
        body.appendChild(tr);
      }
    }

    function renderConsistency() {
      const symbol = getHistorySymbol();
      const { startTs, endTs } = getDateRangeFromInputs('filter_start', 'filter_end');
      let scoped = filterFillsByDate(state.history.slice(), startTs, endTs);
      if (symbol) scoped = scoped.filter(r => r.symbol === symbol);
      const stats = computeConsistency(scoped);
      setText('consistency_score', stats.score ? `${stats.score}` : '-');
      const fill = document.getElementById('consistency_fill');
      if (fill) {
        const score = Math.max(0, Math.min(100, stats.score || 0));
        fill.style.width = `${score}%`;
        if (score >= 80) {
          fill.style.background = 'linear-gradient(90deg, #35f49b, #27d07d)';
          fill.style.boxShadow = '0 0 12px rgba(39, 208, 125, 0.35)';
        } else if (score >= 50) {
          fill.style.background = 'linear-gradient(90deg, #ffd36a, #f5a524)';
          fill.style.boxShadow = '0 0 10px rgba(245, 165, 36, 0.3)';
        } else {
          fill.style.background = 'linear-gradient(90deg, #ff7b7b, #ff6b6b)';
          fill.style.boxShadow = '0 0 10px rgba(255, 107, 107, 0.3)';
        }
      }
      setText('avg_interval', stats.avgInterval ? stats.avgInterval.toFixed(2) : '-');
      setText('std_interval', stats.stdInterval ? stats.stdInterval.toFixed(2) : '-');
      setText('buy_sell_ratio', `${stats.buyCount} / ${stats.sellCount}`);
      setText('trades_per_hour', stats.tradesPerHour ? stats.tradesPerHour.toFixed(2) : '-');
      setText('logged_trades', String(scoped.length));
    }

    function getHistorySymbol() {
      return document.getElementById('filter_symbol')?.value || '';
    }

    function getAnalysisSymbol() {
      return document.getElementById('analysis_symbol')?.value || '';
    }

    function updateSymbolOptions() {
      const historySymbols = state.history.map(r => r.symbol).filter(Boolean);
      const symbols = Array.from(new Set([
        ...historySymbols,
        ...state.metricsSymbols,
        ...state.positionSymbols,
        ...state.customSymbols
      ])).sort();
      const selects = [
        document.getElementById('filter_symbol'),
        document.getElementById('analysis_symbol'),
        document.getElementById('advanced_symbol'),
        document.getElementById('chart_symbol')
      ];
      selects.forEach(sel => {
        if (!sel) return;
        const current = sel.value;
        sel.innerHTML = `<option value="">${t('all')}</option>` + symbols.map(sym => `<option value="${sym}">${sym}</option>`).join('');
        if (current && symbols.includes(current)) {
          sel.value = current;
        } else {
          sel.value = '';
        }
      });
      const chartSelect = document.getElementById('chart_symbol');
      if (chartSelect && !chartSelect.value) {
        if (symbols.includes('ETHUSDT')) {
          chartSelect.value = 'ETHUSDT';
        } else if (symbols.length > 0) {
          chartSelect.value = symbols[0];
        } else {
          chartSelect.value = 'ETHUSDT';
          if (!state.customSymbols.includes('ETHUSDT')) {
            state.customSymbols.push('ETHUSDT');
          }
        }
      }
      if (chartSelect && chartSelect.value && chartSelect.value !== state.lastKlineSymbol) {
        fetchKlines();
      }
    }

    function applyTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const target = tab.getAttribute('data-tab');
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
          const panel = document.getElementById(`panel-${target}`);
          if (panel) panel.classList.add('active');
          if (target === 'chart') {
            state.chartVisible = true;
            ensureChartReady();
            requestOverlayUpdate();
            ensureOrdersLoaded();
          } else {
            state.chartVisible = false;
            stopTradeStream();
          }
        });
      });
    }

    async function fetchStatus() {
      try {
        const res = await fetch('/api/status', { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        const dot = document.getElementById('status_dot');
        const statusText = document.getElementById('status_text');
        dot.classList.remove('ok', 'warn', 'error');
        if (data.has_metrics) {
          dot.classList.add('ok');
          statusText.textContent = formatModeLabel((data.mode || 'unknown').toString());
        } else if (data.mode === 'bybit_api') {
          dot.classList.add('error');
          statusText.textContent = t('status_api_missing');
        } else {
          dot.classList.add('warn');
          statusText.textContent = t('status_waiting_data');
        }
        setText('product_name', data.product || '-');
        setText('exchange_name', data.exchange || '-');
        setText('source_mode', formatModeLabel(data.mode || '-'));
        const subtitle = document.getElementById('subtitle');
        if (subtitle) {
          if (data.mode === 'bybit_api') {
            subtitle.textContent = t('subtitle_bybit');
            subtitle.setAttribute('data-mode', 'bybit');
          } else {
            subtitle.textContent = t('subtitle_monitoring');
            subtitle.setAttribute('data-mode', 'monitor');
          }
        }
      } catch (e) {}
    }

    async function fetchMetrics() {
      try {
        const res = await fetch('/api/metrics', { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        state.metrics = data;
        state.product = data.product || null;
        state.exchange = data.exchange || null;
        setText('symbol_name', data.symbol || '-');
        setText('session_id', data.session_id || '-');
        state.metricsSymbols = (data.fills || []).map(f => f.symbol).filter(Boolean);
        mergeHistory(data.fills || []);
        updateSymbolOptions();
        renderHistory();
        renderConsistency();
        renderResilientMaker(data);
      } catch (e) {}
    }

    function setAnalysisLoading(active) {
      const el = document.getElementById('analysis_loading');
      if (!el) return;
      if (active) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    }

    async function fetchAnalysis() {
      setAnalysisLoading(true);
      try {
        const mode = document.getElementById('analysis_mode').value;
        const days = document.getElementById('analysis_timeframe').value;
        const symbol = getAnalysisSymbol();
        state.analysisCompare = null;
        const qs = new URLSearchParams({ days, symbol: symbol || '' });
        qs.set('source', 'rest');
        qs.set('limit', '20000');
        if (isAnalysisDateRangeEnabled()) {
          const startVal = document.getElementById('analysis_start')?.value || '';
          const endVal = document.getElementById('analysis_end')?.value || '';
          if (startVal) qs.set('start', startVal);
          if (endVal) qs.set('end', endVal);
        }
        const res = await fetch(`/api/analysis?${qs.toString()}`, { cache: 'no-store' });
        if (!res.ok) {
          let errorMsg = t('status_analysis_unavailable');
          try {
            const errorData = await res.json();
            errorMsg = errorData.error || errorMsg;
          } catch (jsonError) {
            errorMsg = `HTTP ${res.status}: ${res.statusText}`;
          }
          document.getElementById('analysis_content').innerHTML = `<div class="muted">${errorMsg}</div>`;
          return;
        }
        const data = await res.json();
        if (data.error) {
          document.getElementById('analysis_content').innerHTML = `<div class="muted">${data.error}</div>`;
          return;
        }
        state.analysisData = data;
        state.analysisMode = mode;
        renderAnalysis(data, mode);
      } catch (e) {
        console.error('Analysis fetch error:', e);
        const errorMsg = e.message || 'Unknown error occurred';
        document.getElementById('analysis_content').innerHTML = `<div class="muted">${t('status_analysis_error')} ${errorMsg}<br>${currentLang === 'zh' ? 'è¯·æ£€æŸ¥æµè§ˆå™¨æŽ§åˆ¶å°ã€‚' : 'Check browser console for details.'}</div>`;
      } finally {
        setAnalysisLoading(false);
      }
    }

    async function fetchAdvancedAnalysis() {
      setAdvancedLoading(true);
      try {
        const days = document.getElementById('advanced_timeframe').value;
        const symbol = getAdvancedSymbol();
        const qs = new URLSearchParams({ days, symbol: symbol || '' });
        qs.set('source', 'rest');
        qs.set('limit', '20000');
        if (isAdvancedDateRangeEnabled()) {
          const startVal = document.getElementById('advanced_start')?.value || '';
          const endVal = document.getElementById('advanced_end')?.value || '';
          if (startVal) qs.set('start', startVal);
          if (endVal) qs.set('end', endVal);
        }
        const res = await fetch(`/api/analysis?${qs.toString()}`, { cache: 'no-store' });
        if (!res.ok) {
          let errorMsg = t('status_analysis_unavailable');
          try {
            const errorData = await res.json();
            errorMsg = errorData.error || errorMsg;
          } catch (jsonError) {
            errorMsg = `HTTP ${res.status}: ${res.statusText}`;
          }
          document.getElementById('advanced_content').innerHTML = `<div class="muted">${errorMsg}</div>`;
          return;
        }
        const data = await res.json();
        if (data.error) {
          document.getElementById('advanced_content').innerHTML = `<div class="muted">${data.error}</div>`;
          return;
        }
        state.advancedData = data;
        renderAdvancedAnalysis(data, symbol);
      } catch (e) {
        console.error('Advanced analysis fetch error:', e);
        const errorMsg = e.message || 'Unknown error occurred';
        document.getElementById('advanced_content').innerHTML = `<div class="muted">${t('status_analysis_error')} ${errorMsg}<br>${currentLang === 'zh' ? 'è¯·æ£€æŸ¥æµè§ˆå™¨æŽ§åˆ¶å°ã€‚' : 'Check browser console for details.'}</div>`;
      } finally {
        setAdvancedLoading(false);
      }
    }

    function formatPct(value, digits = 1) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      return `${(num * 100).toFixed(digits)}%`;
    }

    function formatSigned(value, digits = 4) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      const sign = num > 0 ? '+' : '';
      return `${sign}${num.toFixed(digits)}`;
    }

    function formatNumber(value, digits = 2) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      return num.toFixed(digits);
    }

    function getHourLabel(hourStr) {
      if (!hourStr || typeof hourStr !== 'string') return '';
      const parts = hourStr.split(' ');
      if (parts.length < 2) return '';
      const hour = parts[1].split(':')[0];
      if (!hour) return '';
      return `${hour}:00`;
    }

    function buildAnalysisInsights(data) {
      const zh = currentLang === 'zh';
      const summary = [];
      const advice = [];
      const basic = data.basic || {};
      const perf = data.performance || {};
      const mt = data.maker_taker || {};
      const hourly = Array.isArray(data.hourly_stats) ? data.hourly_stats : [];
      const daily = Array.isArray(data.daily_stats) ? data.daily_stats : [];
      const symbols = Array.isArray(data.symbol_stats) ? data.symbol_stats : [];

      if (basic.total_trades) {
        const days = daily.length || 0;
        if (days > 0) {
          summary.push(zh ? `è¦†ç›– ${days} å¤© / ${basic.total_trades} ç¬”äº¤æ˜“` : `Coverage: ${days} days / ${basic.total_trades} trades`);
        } else {
          summary.push(zh ? `äº¤æ˜“æ•° ${basic.total_trades} ç¬”` : `Trades: ${basic.total_trades}`);
        }
      }

      if (basic.total_volume) {
        summary.push(zh ? `æ€»æˆäº¤é‡ ${basic.total_volume.toFixed(2)}` : `Total volume ${basic.total_volume.toFixed(2)}`);
      }

      if (basic.total_fee && basic.total_volume) {
        summary.push(zh ? `æ‰‹ç»­è´¹å æ¯” ${formatPct(basic.fee_rate, 2)}` : `Fee ratio ${formatPct(basic.fee_rate, 2)}`);
        if (basic.fee_rate > 0.0004) {
          advice.push(zh
            ? `æ‰‹ç»­è´¹å æ¯” ${formatPct(basic.fee_rate, 2)} åé«˜ï¼Œå»ºè®®é™ä½Žåƒå•æ¯”ä¾‹æˆ–ç¼©å°é«˜é¢‘äº¤æ˜“æ—¶æ®µã€‚`
            : `Fee ratio ${formatPct(basic.fee_rate, 2)} is high; reduce taker usage or narrow high-frequency windows.`);
        }
      }

      if (symbols.length && basic.total_volume) {
        const top = symbols.reduce((a, b) => (b.total_volume || 0) > (a.total_volume || 0) ? b : a, symbols[0]);
        const share = (top.total_volume || 0) / (basic.total_volume || 1);
        summary.push(zh
          ? `äº¤æ˜“é‡é›†ä¸­åœ¨ ${top.symbol || '-'}ï¼ˆ${formatPct(share, 1)}ï¼‰`
          : `Volume concentrated in ${top.symbol || '-'} (${formatPct(share, 1)})`);
        if (share >= 0.6) {
          advice.push(zh
            ? `${top.symbol || 'è¯¥å“ç§'} å æ¯” ${formatPct(share, 1)}ï¼Œé›†ä¸­åº¦åé«˜ï¼Œå»ºè®®æŠŠå•å“ç§å æ¯”åŽ‹åˆ° 50% ä»¥ä¸‹ã€‚`
            : `${top.symbol || 'Top symbol'} share is ${formatPct(share, 1)}; reduce single-symbol exposure below 50%.`);
        }
      }

      if (hourly.length) {
        const buckets = {};
        for (const row of hourly) {
          const label = getHourLabel(row.hour);
          if (!label) continue;
          if (!buckets[label]) {
            buckets[label] = { pnl: 0, trades: 0 };
          }
          buckets[label].pnl += Number(row.hourly_pnl) || 0;
          buckets[label].trades += Number(row.trade_count) || 0;
        }
        const minTrades = Math.max(3, Math.floor((basic.total_trades || 0) * 0.02));
        const bucketList = Object.entries(buckets)
          .map(([hour, v]) => ({
            hour,
            trades: v.trades,
            avg_pnl: v.trades ? v.pnl / v.trades : 0
          }))
          .filter(b => b.trades >= minTrades);
        if (bucketList.length >= 2) {
          const best = bucketList.reduce((a, b) => (b.avg_pnl > a.avg_pnl ? b : a), bucketList[0]);
          const worst = bucketList.reduce((a, b) => (b.avg_pnl < a.avg_pnl ? b : a), bucketList[0]);
          summary.push(zh
            ? `æ—¶æ®µåˆ†å¸ƒï¼šUTC ${best.hour} å¹³å‡ç›ˆäº ${formatSigned(best.avg_pnl)}ï¼›UTC ${worst.hour} å¹³å‡ç›ˆäº ${formatSigned(worst.avg_pnl)}`
            : `Time-of-day: UTC ${best.hour} avg ${formatSigned(best.avg_pnl)}; UTC ${worst.hour} avg ${formatSigned(worst.avg_pnl)}`);
          if (best.avg_pnl > 0 && worst.avg_pnl < 0) {
            advice.push(zh
              ? `å‡å°‘ UTC ${worst.hour} é™„è¿‘äº¤æ˜“ï¼Œä¼˜å…ˆ UTC ${best.hour} æ—¶æ®µï¼ˆæ ·æœ¬â‰¥${minTrades} ç¬”ï¼‰ã€‚`
              : `Reduce trading around UTC ${worst.hour}; prioritize UTC ${best.hour} (sample â‰¥ ${minTrades}).`);
          }
        }
      }

      if (mt.maker_count || mt.taker_count) {
        if ((mt.taker_count || 0) > (mt.maker_count || 0) && (mt.taker_pnl || 0) < 0) {
          advice.push(zh
            ? `Taker äº¤æ˜“ ${mt.taker_count || 0} ç¬”ä¸”ç›ˆäº ${formatSigned(mt.taker_pnl || 0)}ï¼Œå»ºè®®é™ä½Žåƒå•å æ¯”ã€‚`
            : `Taker trades ${mt.taker_count || 0} with PnL ${formatSigned(mt.taker_pnl || 0)}; reduce taker usage.`);
        }
        if ((mt.maker_count || 0) > 0 && (mt.maker_pnl || 0) < 0) {
          advice.push(zh
            ? `Maker ç›ˆäº ${formatSigned(mt.maker_pnl || 0)} ä¸ºè´Ÿï¼Œæ£€æŸ¥æŒ‚å•ä»·æ ¼åç¦»æˆ–æ’¤å•è¿‡æ—©ã€‚`
            : `Maker PnL ${formatSigned(mt.maker_pnl || 0)} is negative; review maker pricing or early cancels.`);
        }
      }

      if (perf.win_rate !== undefined && perf.profit_loss_ratio !== undefined) {
        summary.push(zh
          ? `èƒœçŽ‡ ${formatPct(perf.win_rate, 1)}ï¼Œç›ˆäºæ¯” ${Number(perf.profit_loss_ratio || 0).toFixed(2)}`
          : `Win rate ${formatPct(perf.win_rate, 1)}, P/L ${Number(perf.profit_loss_ratio || 0).toFixed(2)}`);
        if ((perf.win_rate || 0) < 0.45 && (perf.profit_loss_ratio || 0) < 1) {
          advice.push(zh
            ? `èƒœçŽ‡ ${formatPct(perf.win_rate, 1)} ä¸”ç›ˆäºæ¯” ${Number(perf.profit_loss_ratio || 0).toFixed(2)}ï¼Œå»ºè®®å…ˆç¼©å°å¼€ä»“é¢‘çŽ‡å¹¶ä¼˜åŒ–æ­¢æŸ/æ­¢ç›ˆæ¯”ä¾‹ã€‚`
            : `Win rate ${formatPct(perf.win_rate, 1)} and P/L ${Number(perf.profit_loss_ratio || 0).toFixed(2)}; reduce frequency and rebalance SL/TP.` );
        }
      }

      if (perf.max_drawdown_pct !== undefined) {
        const dd = Number(perf.max_drawdown_pct || 0);
        if (dd < -10) {
          advice.push(zh
            ? `æœ€å¤§å›žæ’¤ ${dd.toFixed(2)}%ï¼Œå»ºè®®é™åˆ¶å•ç¬”é£Žé™©å¹¶å›žæµ‹è§¦å‘ç‚¹ã€‚`
            : `Max drawdown ${dd.toFixed(2)}%; tighten per-trade risk and review triggers.`);
        }
      }

      return { summary, advice };
    }

    function renderAnalysisSummary(insights) {
      const summaryItems = insights.summary.length
        ? insights.summary.map(item => `<li>${item}</li>`).join('')
        : `<li class="muted">${t('analysis_summary_empty')}</li>`;
      const adviceItems = insights.advice.length
        ? insights.advice.map(item => `<li>${item}</li>`).join('')
        : `<li class="muted">${t('analysis_advice_empty')}</li>`;
      return `
        <div class="analysis-summary">
          <div class="analysis-summary-grid">
            <div>
              <h3>${t('analysis_heading_summary')}</h3>
              <ul class="analysis-list">${summaryItems}</ul>
            </div>
            <div>
              <h3>${t('analysis_heading_advice')}</h3>
              <ul class="analysis-list">${adviceItems}</ul>
            </div>
          </div>
        </div>
      `;
    }

    function renderCompareBlock(compare) {
      if (!compare || !compare.ok) return '';
      const fills = compare.fills || {};
      const orders = compare.orders || {};
      return `
        <h3>${t('analysis_heading_compare')}</h3>
        <div class="row">
          <div class="card"><div class="label">${t('analysis_label_fills_rows')}</div><div class="value">${fills.rows || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fetch_time')}</div><div class="value">${fills.ms || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fields_present')}</div><div class="value">${fills.fields_present || 0}</div></div>
        </div>
        <div class="row">
          <div class="card"><div class="label">${t('analysis_label_orders_rows')}</div><div class="value">${orders.rows || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_orders_filled')}</div><div class="value">${orders.filled_rows || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fetch_time')}</div><div class="value">${orders.ms || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fields_present')}</div><div class="value">${orders.fields_present || 0}</div></div>
        </div>
      `;
    }

    function clearAnalysisDateFilters() {
      const start = document.getElementById('analysis_start');
      const end = document.getElementById('analysis_end');
      if (start) start.value = '';
      if (end) end.value = '';
    }

    function isAnalysisDateRangeEnabled() {
      return !!document.getElementById('analysis_use_range')?.checked;
    }

    function syncAnalysisDateRangeUI() {
      const enabled = isAnalysisDateRangeEnabled();
      const start = document.getElementById('analysis_start');
      const end = document.getElementById('analysis_end');
      if (start) start.disabled = !enabled;
      if (end) end.disabled = !enabled;
      if (!enabled) {
        clearAnalysisDateFilters();
      }
    }

    function getAdvancedSymbol() {
      return document.getElementById('advanced_symbol')?.value || '';
    }

    function isAdvancedDateRangeEnabled() {
      return !!document.getElementById('advanced_use_range')?.checked;
    }

    function clearAdvancedDateFilters() {
      const start = document.getElementById('advanced_start');
      const end = document.getElementById('advanced_end');
      if (start) start.value = '';
      if (end) end.value = '';
    }

    function syncAdvancedDateRangeUI() {
      const enabled = isAdvancedDateRangeEnabled();
      const start = document.getElementById('advanced_start');
      const end = document.getElementById('advanced_end');
      if (start) start.disabled = !enabled;
      if (end) end.disabled = !enabled;
      if (!enabled) {
        clearAdvancedDateFilters();
      }
    }

    function setAdvancedLoading(active) {
      const el = document.getElementById('advanced_loading');
      if (!el) return;
      if (active) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    }

    function renderAnalysis(data, mode) {
      const content = document.getElementById('analysis_content');
      let html = '';

      // Check if there's a message (no data available)
      if (data.basic && data.basic.message) {
        html = `<div class="muted">${data.basic.message}</div>`;
        content.innerHTML = html;
        return;
      }

      const insights = buildAnalysisInsights(data);
      html += renderAnalysisSummary(insights);
      if (state.analysisCompare) {
        html += renderCompareBlock(state.analysisCompare);
      }

      if (mode === 'full' || mode === 'performance') {
        const perf = data.performance || {};
        html += `<h3>${t('analysis_heading_performance')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'èƒœçŽ‡' : 'Win Rate'}</div><div class="value">${((perf.win_rate || 0) * 100).toFixed(2)}%</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'ç›ˆäºæ¯”' : 'Profit/Loss Ratio'}</div><div class="value">${(perf.profit_loss_ratio || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'å¤æ™®æ¯”çŽ‡' : 'Sharpe Ratio'}</div><div class="value">${(perf.sharpe_ratio || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'å¡çŽ›æ¯”çŽ‡' : 'Calmar Ratio'}</div><div class="value">${(perf.calmar_ratio || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'æœ€å¤§å›žæ’¤' : 'Max Drawdown'}</div><div class="value">${(perf.max_drawdown || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'æ€»å›žæŠ¥' : 'Total Return'}</div><div class="value">${(perf.total_return || 0).toFixed(4)}</div></div>`;
        html += '</div>';
      }

      if (mode === 'full' || mode === 'risk') {
        const risk = data.risk || {};
        html += `<h3>${t('analysis_heading_risk')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">VaR (95%)</div><div class="value">${(risk.var_95 || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">CVaR (95%)</div><div class="value">${(risk.cvar_95 || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'å¹´åŒ–æ³¢åŠ¨çŽ‡' : 'Volatility (Annual)'}</div><div class="value">${(risk.volatility_annualised || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? 'å•æ—¥æœ€å¤§äºæŸ' : 'Max Daily Loss'}</div><div class="value">${(risk.max_daily_loss || 0).toFixed(4)}</div></div>`;
        html += '</div>';
      }

      if (mode === 'full' || mode === 'maker_taker') {
        const mt = data.maker_taker || {};
        html += `<h3>${t('analysis_heading_maker_taker')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${t('analysis_label_maker_trades')}</div><div class="value">${mt.maker_count || 0}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_taker_trades')}</div><div class="value">${mt.taker_count || 0}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_maker_pnl')}</div><div class="value">${(mt.maker_pnl || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_taker_pnl')}</div><div class="value">${(mt.taker_pnl || 0).toFixed(4)}</div></div>`;
        html += '</div>';
      }

      if (data.basic) {
        const basic = data.basic;
        html += `<h3>${t('analysis_heading_basic')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${t('analysis_label_total_trades')}</div><div class="value">${basic.total_trades || 0}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_total_volume')}</div><div class="value">${(basic.total_volume || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_net_pnl')}</div><div class="value">${(basic.net_pnl || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_total_fee')}</div><div class="value">${(basic.total_fee || 0).toFixed(4)}</div></div>`;
        html += '</div>';

        html += `<h3>${t('analysis_heading_entry_exit')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_price')}</div><div class="value">${formatNumber(basic.avg_buy_price, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_price')}</div><div class="value">${formatNumber(basic.avg_sell_price, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_qty')}</div><div class="value">${formatNumber(basic.avg_buy_qty, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_qty')}</div><div class="value">${formatNumber(basic.avg_sell_qty, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_notional')}</div><div class="value">${formatNumber(basic.avg_buy_notional, 2)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_notional')}</div><div class="value">${formatNumber(basic.avg_sell_notional, 2)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_fee')}</div><div class="value">${formatNumber(basic.avg_buy_fee, 6)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_fee')}</div><div class="value">${formatNumber(basic.avg_sell_fee, 6)}</div></div>`;
        html += '</div>';
      }

      if (Array.isArray(data.symbol_stats) && data.symbol_stats.length > 0) {
        html += `<h3>${t('analysis_heading_symbol_pnl')}</h3>`;
        html += `<table><thead><tr><th>${t('th_symbol')}</th><th>${currentLang === 'zh' ? 'æ€»ç›ˆäº' : 'Total PnL'}</th><th>${currentLang === 'zh' ? 'äº¤æ˜“æ•°' : 'Trades'}</th><th>${t('analysis_label_total_fee')}</th><th>${t('analysis_label_total_volume')}</th></tr></thead><tbody>`;
        data.symbol_stats.forEach(row => {
          html += `<tr>
            <td>${row.symbol || '-'}</td>
            <td>${(row.total_pnl || 0).toFixed(4)}</td>
            <td>${row.trade_count || 0}</td>
            <td>${(row.total_fee || 0).toFixed(4)}</td>
            <td>${(row.total_volume || 0).toFixed(2)}</td>
          </tr>`;
        });
        html += '</tbody></table>';
      }

      content.innerHTML = html || `<div class="muted">${t('status_no_analysis')}</div>`;
    }

    function renderAdvancedTable(headers, rows) {
      return `<table><thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody>${rows.join('')}</tbody></table>`;
    }

    function renderDetailsTable(summaryText, tableHtml) {
      return `
        <details class="analysis-details">
          <summary>${summaryText}</summary>
          ${tableHtml}
        </details>
      `;
    }

    function renderChartBlock(title, chartHtml) {
      return `
        <div class="analysis-chart-block">
          <h3>${title}</h3>
          ${chartHtml}
        </div>
      `;
    }

    function buildLinePath(points, width, height, padding = 12) {
      if (!points.length) return '';
      const min = Math.min(...points);
      const max = Math.max(...points);
      const span = max - min || 1;
      const innerW = width - padding * 2;
      const innerH = height - padding * 2;
      return points.map((val, idx) => {
        const x = padding + (innerW * idx) / (points.length - 1 || 1);
        const y = padding + innerH - ((val - min) / span) * innerH;
        return `${idx === 0 ? 'M' : 'L'}${x.toFixed(2)},${y.toFixed(2)}`;
      }).join(' ');
    }

    function renderLineChart(points, opts = {}) {
      const width = 180;
      const height = 80;
      const padding = 12;
      const label = opts.label || '';
      const units = opts.units || '';
      const secondary = Array.isArray(opts.secondary) ? opts.secondary : null;
      const showZoom = opts.zoom !== false;
      if (!points.length) {
        return `<div class="analysis-chart"><div class="muted">${t('status_no_analysis')}</div></div>`;
      }
      const path = buildLinePath(points, width, height, padding);
      const min = Math.min(...points);
      const max = Math.max(...points);
      const mid = (min + max) / 2;
      const gridY = [0, 1, 2].map(i => padding + (i * (height - padding * 2)) / 2);
      const leftLabelX = padding - 2;
      const rightLabelX = width - 2;
      let secondaryPath = '';
      let secondaryMin = 0;
      let secondaryMax = 0;
      let secondaryMid = 0;
      if (secondary && secondary.length) {
        secondaryMin = Math.min(...secondary);
        secondaryMax = Math.max(...secondary);
        secondaryMid = (secondaryMin + secondaryMax) / 2;
        secondaryPath = buildLinePath(secondary, width, height, padding);
      }
      return `
        <div class="analysis-chart">
          ${label ? `<div class="chart-title">${label}</div>` : ''}
          ${showZoom ? `<button class="chart-zoom" data-title="${label}">ðŸ”</button>` : ''}
          <div class="chart-tooltip"></div>
          <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet"
            data-values='${JSON.stringify(points)}'
            data-secondary='${secondary ? JSON.stringify(secondary) : ''}'
            data-min="${min}" data-max="${max}"
            data-min2="${secondary ? secondaryMin : ''}"
            data-max2="${secondary ? secondaryMax : ''}"
            data-padding="${padding}">
            <line class="axis-line" x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}"></line>
            ${gridY.map(y => `<line class="grid-line" x1="${padding}" y1="${y}" x2="${width - padding}" y2="${y}"></line>`).join('')}
            <text class="axis-text" text-anchor="end" x="${leftLabelX}" y="${padding + 2}">${max.toFixed(2)}${units}</text>
            <text class="axis-text" text-anchor="end" x="${leftLabelX}" y="${(height / 2).toFixed(2)}">${mid.toFixed(2)}${units}</text>
            <text class="axis-text" text-anchor="end" x="${leftLabelX}" y="${height - 2}">${min.toFixed(2)}${units}</text>
            ${secondary ? `
              <text class="axis-text" text-anchor="end" x="${rightLabelX}" y="${padding + 2}">${secondaryMax.toFixed(2)}${units}</text>
              <text class="axis-text" text-anchor="end" x="${rightLabelX}" y="${(height / 2).toFixed(2)}">${secondaryMid.toFixed(2)}${units}</text>
              <text class="axis-text" text-anchor="end" x="${rightLabelX}" y="${height - 2}">${secondaryMin.toFixed(2)}${units}</text>
            ` : ''}
            <path d="${path}"></path>
            ${secondaryPath ? `<path class="series-secondary" d="${secondaryPath}"></path>` : ''}
            <line class="hover-line" x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" style="opacity:0;"></line>
            <circle class="hover-point" r="1.6" cx="${padding}" cy="${height - padding}" style="opacity:0;"></circle>
            <circle class="hover-point secondary" r="1.6" cx="${padding}" cy="${height - padding}" style="opacity:0;"></circle>
          </svg>
        </div>
      `;
    }

    function wireAdvancedCharts() {
      document.querySelectorAll('.analysis-chart svg[data-values]').forEach(svg => {
        const chart = svg.closest('.analysis-chart');
        const tooltip = chart ? chart.querySelector('.chart-tooltip') : null;
        const values = JSON.parse(svg.getAttribute('data-values') || '[]');
        const secondaryRaw = svg.getAttribute('data-secondary') || '';
        const secondary = secondaryRaw ? JSON.parse(secondaryRaw) : null;
        const padding = Number(svg.getAttribute('data-padding') || 12);
        const min = Number(svg.getAttribute('data-min') || 0);
        const max = Number(svg.getAttribute('data-max') || 1);
        const min2 = Number(svg.getAttribute('data-min2') || 0);
        const max2 = Number(svg.getAttribute('data-max2') || 1);
        const hoverLine = svg.querySelector('.hover-line');
        const hoverPoint = svg.querySelector('.hover-point');
        const hoverPoint2 = svg.querySelector('.hover-point.secondary');
        const width = svg.viewBox.baseVal.width || 180;
        const height = svg.viewBox.baseVal.height || 80;
        const innerW = width - padding * 2;
        const innerH = height - padding * 2;

        const toY = (val, vmin, vmax) => {
          const span = vmax - vmin || 1;
          return padding + innerH - ((val - vmin) / span) * innerH;
        };

        const move = (evt) => {
          if (!values.length) return;
          const rect = svg.getBoundingClientRect();
          const x = evt.clientX - rect.left;
          const ratio = Math.min(1, Math.max(0, (x / rect.width)));
          const idx = Math.round(ratio * (values.length - 1));
          const idxSafe = Math.max(0, Math.min(values.length - 1, idx));
          const val = values[idxSafe];
          const sx = padding + innerW * (idxSafe / (values.length - 1 || 1));
          const sy = toY(val, min, max);

          if (hoverLine) {
            hoverLine.setAttribute('x1', sx);
            hoverLine.setAttribute('x2', sx);
            hoverLine.style.opacity = '1';
          }
          if (hoverPoint) {
            hoverPoint.setAttribute('cx', sx);
            hoverPoint.setAttribute('cy', sy);
            hoverPoint.style.opacity = '1';
          }
          let tooltipText = `#${idxSafe + 1}: ${formatNumber(val, 4)}`;
          if (secondary && secondary.length) {
            const val2 = secondary[idxSafe] ?? 0;
            const sy2 = toY(val2, min2, max2);
            if (hoverPoint2) {
              hoverPoint2.setAttribute('cx', sx);
              hoverPoint2.setAttribute('cy', sy2);
              hoverPoint2.style.opacity = '1';
            }
            tooltipText += ` | ${formatNumber(val2, 2)}`;
          }
          if (tooltip && chart) {
            tooltip.textContent = tooltipText;
            tooltip.style.opacity = '1';
            tooltip.style.left = `${(sx / width) * 100}%`;
            tooltip.style.top = `${(sy / height) * 100}%`;
          }
        };

        const leave = () => {
          if (hoverLine) hoverLine.style.opacity = '0';
          if (hoverPoint) hoverPoint.style.opacity = '0';
          if (hoverPoint2) hoverPoint2.style.opacity = '0';
          if (tooltip) tooltip.style.opacity = '0';
        };

        svg.addEventListener('mousemove', move);
        svg.addEventListener('mouseleave', leave);
      });

      document.querySelectorAll('.analysis-chart .chart-zoom').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const chart = btn.closest('.analysis-chart');
          const svg = chart ? chart.querySelector('svg[data-values]') : null;
          if (!svg) return;
          openChartModal(svg, btn.getAttribute('data-title') || 'Chart');
        });
      });
    }

    function openChartModal(svg, title) {
      const modal = document.getElementById('chart_modal');
      const body = document.getElementById('chart_modal_body');
      const titleEl = document.getElementById('chart_modal_title');
      if (!modal || !body) return;
      titleEl.textContent = title || 'Chart';
      const values = svg.getAttribute('data-values') || '[]';
      const secondary = svg.getAttribute('data-secondary') || '';
      const points = JSON.parse(values);
      const secondaryPoints = secondary ? JSON.parse(secondary) : null;
      body.innerHTML = renderLineChart(points, { units: '', secondary: secondaryPoints, zoom: false });
      modal.classList.add('active');
      wireAdvancedCharts();
    }

    function renderBarChart(points) {
      const width = 120;
      const height = 60;
      if (!points.length) {
        return `<div class="analysis-chart"><div class="muted">${t('status_no_analysis')}</div></div>`;
      }
      const max = Math.max(...points, 1);
      const barWidth = width / points.length;
      const bars = points.map((val, idx) => {
        const h = (val / max) * (height - 6);
        const x = idx * barWidth;
        const y = height - h - 4;
        return `<rect class="bar" x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${(barWidth * 0.7).toFixed(2)}" height="${h.toFixed(2)}"></rect>`;
      }).join('');
      return `
        <div class="analysis-chart">
          <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
            <line class="axis-line" x1="0" y1="${height - 4}" x2="${width}" y2="${height - 4}"></line>
            ${bars}
          </svg>
        </div>
      `;
    }

    function renderAdvancedAnalysis(data, symbol) {
      const content = document.getElementById('advanced_content');
      if (!data) {
        content.innerHTML = `<div class="muted">${t('status_no_analysis')}</div>`;
        return;
      }
      if (data.error) {
        content.innerHTML = `<div class="muted">${data.error}</div>`;
        return;
      }

      const hourly = Array.isArray(data.hourly_stats) ? data.hourly_stats : [];
      const daily = Array.isArray(data.daily_stats) ? data.daily_stats : [];
      const hourOfDay = Array.isArray(data.hour_of_day_stats) ? data.hour_of_day_stats : [];
      const symbolHourlyRaw = Array.isArray(data.symbol_hourly_stats) ? data.symbol_hourly_stats : [];
      const inventoryHourly = Array.isArray(data.inventory_hourly) ? data.inventory_hourly : [];
      const inventoryDaily = Array.isArray(data.inventory_daily) ? data.inventory_daily : [];
      const inventoryWeekly = Array.isArray(data.inventory_weekly) ? data.inventory_weekly : [];
      const corr = data.time_correlations || {};

      let html = '';
      let chartsHtml = '';
      let detailsHtml = '';

      html += `<h3>${t('advanced_heading_time_correlation')}</h3>`;
      html += '<div class="row">';
      html += `<div class="card"><div class="label">${t('advanced_label_corr_hour_pnl')}</div><div class="value">${formatSigned(corr.corr_hour_of_day_pnl || 0, 3)}</div></div>`;
      html += `<div class="card"><div class="label">${t('advanced_label_corr_tradecount_pnl')}</div><div class="value">${formatSigned(corr.corr_tradecount_pnl || 0, 3)}</div></div>`;
      html += `<div class="card"><div class="label">${t('advanced_label_corr_volume_pnl')}</div><div class="value">${formatSigned(corr.corr_volume_pnl || 0, 3)}</div></div>`;
      html += '</div>';

      chartsHtml += renderChartBlock(
        t('advanced_heading_daily_performance'),
        renderLineChart(
          daily.map(row => Number(row.daily_pnl || 0)),
          { units: '', secondary: daily.map(row => Number(row.daily_volume || 0)) }
        )
      );
      const dailyRows = daily.map(row => `
        <tr>
          <td>${row.date || '-'}</td>
          <td>${row.trade_count || 0}</td>
          <td>${formatNumber(row.daily_volume, 2)}</td>
          <td>${formatSigned(row.daily_pnl || 0, 4)}</td>
          <td>${formatSigned(row.delta_trades || 0, 0)}</td>
          <td>${formatSigned(row.delta_volume || 0, 2)}</td>
          <td>${formatSigned(row.delta_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [
            t('advanced_label_date'),
            t('advanced_label_trades'),
            t('advanced_label_notional'),
            t('advanced_label_pnl'),
            t('advanced_label_delta_trades'),
            t('advanced_label_delta_notional'),
            t('advanced_label_delta_pnl')
          ],
          dailyRows
        )
      );

      const hourlySlice = hourly.slice(-168);
      chartsHtml += renderChartBlock(
        t('advanced_heading_hourly_performance'),
        renderLineChart(
          hourlySlice.map(row => Number(row.hourly_pnl || 0)),
          { units: '', secondary: hourlySlice.map(row => Number(row.hourly_volume || 0)) }
        )
      );
      if (hourly.length > hourlySlice.length) {
        html += `<div class="muted">${currentLang === 'zh' ? `ä»…æ˜¾ç¤ºæœ€è¿‘ ${hourlySlice.length} å°æ—¶` : `Showing last ${hourlySlice.length} hours`}</div>`;
      }
      const hourlyRows = hourlySlice.map(row => `
        <tr>
          <td>${row.hour || '-'}</td>
          <td>${row.trade_count || 0}</td>
          <td>${formatNumber(row.hourly_volume, 2)}</td>
          <td>${formatSigned(row.hourly_pnl || 0, 4)}</td>
          <td>${formatSigned(row.delta_trades || 0, 0)}</td>
          <td>${formatSigned(row.delta_volume || 0, 2)}</td>
          <td>${formatSigned(row.delta_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [
            t('advanced_label_hour'),
            t('advanced_label_trades'),
            t('advanced_label_notional'),
            t('advanced_label_pnl'),
            t('advanced_label_delta_trades'),
            t('advanced_label_delta_notional'),
            t('advanced_label_delta_pnl')
          ],
          hourlyRows
        )
      );

      chartsHtml += renderChartBlock(
        t('advanced_heading_hour_of_day'),
        renderLineChart(
          hourOfDay.map(row => Number(row.hour_pnl || 0)),
          { units: '', secondary: hourOfDay.map(row => Number(row.hour_volume || 0)) }
        )
      );
      const hodRows = hourOfDay.map(row => `
        <tr>
          <td>${row.hour_of_day ?? '-'}</td>
          <td>${row.trade_count || 0}</td>
          <td>${formatNumber(row.hour_volume, 2)}</td>
          <td>${formatSigned(row.hour_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [
            t('advanced_label_hour'),
            t('advanced_label_trades'),
            t('advanced_label_notional'),
            t('advanced_label_pnl')
          ],
          hodRows
        )
      );

      html += `<h3>${t('advanced_heading_symbol_hourly')}</h3>`;
      let symbolHourly = symbol ? symbolHourlyRaw.filter(row => row.symbol === symbol) : symbolHourlyRaw;
      const symbolHourlyLimit = 200;
      const symbolHourlySlice = symbolHourly.slice(0, symbolHourlyLimit);
      if (symbolHourly.length > symbolHourlySlice.length) {
        html += `<div class="muted">${currentLang === 'zh' ? `ä»…æ˜¾ç¤ºå‰ ${symbolHourlySlice.length} è¡Œ` : `Showing first ${symbolHourlySlice.length} rows`}</div>`;
      }
      const symbolHourlyRows = symbolHourlySlice.map(row => `
        <tr>
          <td>${row.symbol || '-'}</td>
          <td>${row.hour_of_day ?? '-'}</td>
          <td>${row.buy_count || 0}</td>
          <td>${row.sell_count || 0}</td>
          <td>${formatNumber(row.avg_buy_qty, 4)}</td>
          <td>${formatNumber(row.avg_sell_qty, 4)}</td>
          <td>${formatNumber(row.buy_notional, 2)}</td>
          <td>${formatNumber(row.sell_notional, 2)}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [
            t('th_symbol'),
            t('advanced_label_hour'),
            t('advanced_label_buy_count'),
            t('advanced_label_sell_count'),
            t('advanced_label_avg_buy_qty'),
            t('advanced_label_avg_sell_qty'),
            t('advanced_label_buy_notional'),
            t('advanced_label_sell_notional')
          ],
          symbolHourlyRows
        )
      );

      const invHourlySlice = inventoryHourly.slice(-168);
      chartsHtml += renderChartBlock(
        t('advanced_heading_inventory_hourly'),
        renderLineChart(
          invHourlySlice.map(row => Number(row.cumulative_net_qty || 0)),
          { units: '', secondary: invHourlySlice.map(row => Number(row.trade_count || 0)) }
        )
      );
      const invHourlyRows = invHourlySlice.map(row => `
        <tr>
          <td>${row.hour || '-'}</td>
          <td>${formatSigned(row.net_qty || 0, 4)}</td>
          <td>${formatSigned(row.cumulative_net_qty || 0, 4)}</td>
          <td>${row.trade_count || 0}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [
            t('advanced_label_hour'),
            t('advanced_label_net_qty'),
            t('advanced_label_cum_net_qty'),
            t('advanced_label_trades')
          ],
          invHourlyRows
        )
      );

      const invDailySlice = inventoryDaily.slice(-60);
      chartsHtml += renderChartBlock(
        t('advanced_heading_inventory_daily'),
        renderLineChart(
          invDailySlice.map(row => Number(row.cumulative_net_qty || 0)),
          { units: '', secondary: invDailySlice.map(row => Number(row.trade_count || 0)) }
        )
      );
      const invDailyRows = invDailySlice.map(row => `
        <tr>
          <td>${row.date || '-'}</td>
          <td>${formatSigned(row.net_qty || 0, 4)}</td>
          <td>${formatSigned(row.cumulative_net_qty || 0, 4)}</td>
          <td>${row.trade_count || 0}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [
            t('advanced_label_date'),
            t('advanced_label_net_qty'),
            t('advanced_label_cum_net_qty'),
            t('advanced_label_trades')
          ],
          invDailyRows
        )
      );

      chartsHtml += renderChartBlock(
        t('advanced_heading_inventory_weekly'),
        renderLineChart(
          inventoryWeekly.map(row => Number(row.cumulative_net_qty || 0)),
          { units: '', secondary: inventoryWeekly.map(row => Number(row.trade_count || 0)) }
        )
      );
      const invWeeklyRows = inventoryWeekly.map(row => `
        <tr>
          <td>${row.week || '-'}</td>
          <td>${formatSigned(row.net_qty || 0, 4)}</td>
          <td>${formatSigned(row.cumulative_net_qty || 0, 4)}</td>
          <td>${row.trade_count || 0}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [
            t('advanced_label_week'),
            t('advanced_label_net_qty'),
            t('advanced_label_cum_net_qty'),
            t('advanced_label_trades')
          ],
          invWeeklyRows
        )
      );

      html += `<h3>${t('advanced_heading_hourly_balance')}</h3>`;
      html += `<div class="muted">${t('advanced_balance_note')}</div>`;
      const balanceSlice = hourly.slice(-168);
      chartsHtml += renderChartBlock(
        t('advanced_heading_hourly_balance'),
        renderLineChart(
          balanceSlice.map(row => Number(row.cumulative_net_pnl || 0)),
          { units: '', secondary: balanceSlice.map(row => Number(row.hourly_volume || 0)) }
        )
      );
      const balanceRows = balanceSlice.map(row => `
        <tr>
          <td>${row.hour || '-'}</td>
          <td>${formatSigned(row.cumulative_net_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsHtml += renderDetailsTable(
        currentLang === 'zh' ? 'æ˜Žç»†' : 'Details',
        renderAdvancedTable(
          [t('advanced_label_hour'), t('advanced_label_pnl')],
          balanceRows
        )
      );

      if (chartsHtml) {
        html += `<div class="analysis-charts-grid">${chartsHtml}</div>`;
      }
      if (detailsHtml) {
        html += `<h3>${currentLang === 'zh' ? 'æ˜Žç»†è¡¨' : 'Detailed Tables'}</h3>`;
        html += detailsHtml;
      }

      content.innerHTML = html || `<div class="muted">${t('status_no_analysis')}</div>`;
      wireAdvancedCharts();
    }

    async function fetchPositions() {
      try {
        const res = await fetch('/api/positions', { cache: 'no-store' });
        if (!res.ok) {
          document.getElementById('positions_content').innerHTML = `<div class="muted">${currentLang === 'zh' ? 'å½“å‰æ¨¡å¼ä¸æ”¯æŒæŒä»“ã€‚' : 'Positions not available in current mode.'}</div>`;
          return;
        }
        const data = await res.json();
        const positions = Array.isArray(data.positions) ? data.positions : [];
        state.positionSymbols = positions.map(p => p.symbol || p.Symbol).filter(Boolean);
        updateSymbolOptions();
        renderPositions(data);
      } catch (e) {
        document.getElementById('positions_content').innerHTML = `<div class="muted">${t('status_positions_error')} ${e.message}</div>`;
      }
    }

    function renderPositions(data) {
      const content = document.getElementById('positions_content');
      let positions = data.positions || [];
      
      // Ensure positions is an array
      if (!Array.isArray(positions)) {
        if (typeof positions === 'object' && positions !== null) {
          positions = Object.values(positions);
        } else {
          positions = [];
        }
      }
      
      if (positions.length === 0) {
        content.innerHTML = `<div class="muted">${t('status_no_positions')}</div>`;
        return;
      }

      const cache = {};
      let html = `<table><thead><tr><th>${t('positions_table_symbol')}</th><th>${t('positions_table_side')}</th><th>${t('positions_table_size')}</th><th>${t('positions_table_avg_price')}</th><th>${t('positions_table_mark_price')}</th><th>${t('positions_table_unrealised')}</th><th>${t('positions_table_realised')}</th><th>${t('positions_table_leverage')}</th><th>${t('positions_table_actions')}</th></tr></thead><tbody>`;
      positions.forEach(pos => {
        const unrealised = getPosValue(pos, ['unrealisedPnl', 'UnrealisedPnl']);
        const realised = getPosValue(pos, ['curRealisedPnl', 'realisedPnl', 'CurRealisedPnl', 'RealisedPnl']);
        const funding = getPosValue(pos, ['fundingFee', 'FundingFee', 'funding', 'Funding']);
        const closed = getPosValue(pos, ['closedPnl', 'ClosedPnl', 'execPnl', 'ExecPnl']);
        const breakEven = getPosValue(pos, ['breakEvenPrice', 'BreakEvenPrice']);
        const realisedTip = buildPnlTooltip({ realised, funding, closed, breakEven });
        const unrealisedClass = pnlClass(unrealised);
        const realisedClass = pnlClass(realised);
        const symbol = pos.symbol || pos.Symbol || '-';
        cache[symbol] = pos;
        html += `<tr>
          <td>${symbol}</td>
          <td>${pos.side || pos.Side || '-'}</td>
          <td>${pos.size || pos.Size || 0}</td>
          <td>${pos.avgPrice || pos.AvgPrice || 0}</td>
          <td>${pos.markPrice || pos.MarkPrice || 0}</td>
          <td class="tooltip-cell ${unrealisedClass}" data-tooltip="${realisedTip.unrealised}">${unrealised || 0}</td>
          <td class="tooltip-cell ${realisedClass}" data-tooltip="${realisedTip.realised}">${realised || 0}</td>
          <td>${pos.leverage || pos.Leverage || '-'}</td>
          <td><button class="position-manage" data-symbol="${symbol}">${t('positions_table_manage')}</button></td>
        </tr>`;
      });
      html += '</tbody></table>';
      content.innerHTML = html;
      state.positionCache = cache;
      content.querySelectorAll('.position-manage').forEach(btn => {
        btn.addEventListener('click', () => openPositionModal(btn.dataset.symbol));
      });
    }

    function renderResilientMaker(metrics) {
      if (!metrics) return;
      setText('rm_inventory', metrics.inventory ?? '-');
      setText('rm_session_pnl', metrics.session_pnl ?? '-');
      setText('rm_realized_pnl', metrics.realized_pnl ?? '-');
      setText('rm_unrealized_pnl', metrics.unrealized_pnl ?? '-');
      setText('rm_fee_total', metrics.fee_total ?? '-');
      setText('rm_funding_total', metrics.funding_fee_total ?? '-');
      const glft = metrics.glft || {};
      document.getElementById('rm_glft').textContent = JSON.stringify(glft, null, 2);
    }

    function setTradeStatus(text, ok) {
      const el = document.getElementById('trade_status');
      if (!el) return;
      el.textContent = text;
      el.style.color = ok ? 'var(--success)' : 'var(--muted)';
    }

    function updateTradingFormState() {
      const ack = document.getElementById('trade_ack').checked;
      const useEnvEl = document.getElementById('trade_use_env');
      const apiKey = document.getElementById('trade_api_key');
      const apiSecret = document.getElementById('trade_api_secret');
      const mode = document.getElementById('trade_mode');
      const demo = document.getElementById('trade_demo');
      const enableBtn = document.getElementById('enable_trading');
      useEnvEl.disabled = !state.tradingHasEnv;
      if (!state.tradingHasEnv && useEnvEl.checked) {
        useEnvEl.checked = false;
      }
      const useEnv = useEnvEl.checked;
      apiKey.disabled = !ack || useEnv;
      apiSecret.disabled = !ack || useEnv;
      mode.disabled = !ack;
      demo.disabled = !ack;
      const hasManualKeys = apiKey.value.trim() && apiSecret.value.trim();
      const canUseEnv = useEnv && state.tradingHasEnv;
      enableBtn.disabled = !ack || (!hasManualKeys && !canUseEnv);
    }

    function syncChartTradingState() {
      const reduceOnly = document.getElementById('chart_reduce_only');
      if (!reduceOnly) return;
      if (state.tradingMode === 'close_only') {
        reduceOnly.checked = true;
        reduceOnly.disabled = true;
      } else {
        reduceOnly.disabled = false;
      }
    }

    function updateChartOrderMode() {
      const mode = document.getElementById('chart_order_mode').value;
      const priceRow = document.getElementById('chart_price_row');
      if (priceRow) {
        priceRow.style.display = mode === 'limit' ? 'block' : 'none';
      }
    }

    async function submitChartOrder(side) {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = getChartSymbol();
      if (!symbol) {
        alert(t('alert_symbol_required'));
        return;
      }
      const qty = parseFloat(document.getElementById('chart_order_qty').value || '0');
      if (!Number.isFinite(qty) || qty <= 0) {
        alert(t('alert_qty_required'));
        return;
      }
      const orderMode = document.getElementById('chart_order_mode').value;
      const reduceOnly = document.getElementById('chart_reduce_only').checked || state.tradingMode === 'close_only';
      let price = null;
      if (orderMode === 'limit') {
        price = parseFloat(document.getElementById('chart_order_price').value || '0');
        if (!Number.isFinite(price) || price <= 0) {
          alert(t('alert_price_required'));
          return;
        }
      }
      try {
        const res = await fetch('/api/orders/create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbol,
            side,
            qty,
            order_mode: orderMode,
            price,
            reduce_only: reduceOnly
          })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_order_failed'));
        }
        fetchOrders('');
        updateOrdersOverlay();
      } catch (e) {
        alert(e.message || t('alert_order_failed'));
      }
    }

    function openPositionModal(symbol) {
      const pos = state.positionCache[symbol];
      if (!pos) {
        alert(t('alert_position_missing'));
        return;
      }
      state.activePositionSymbol = symbol;
      setText('position_modal_symbol', symbol);
      setText('position_modal_side', pos.side || pos.Side || '-');
      setText('position_modal_qty', pos.size || pos.Size || '-');
      document.getElementById('position_tp').value = '';
      document.getElementById('position_sl').value = '';
      document.getElementById('position_modal').classList.add('active');
    }

    async function submitPositionClose() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      try {
        const res = await fetch('/api/positions/close', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
        fetchPositions();
        fetchOrders('');
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function submitPositionTpSl() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      const tp = parseFloat(document.getElementById('position_tp').value || '');
      const sl = parseFloat(document.getElementById('position_sl').value || '');
      const hasTp = Number.isFinite(tp) && tp > 0;
      const hasSl = Number.isFinite(sl) && sl > 0;
      if (!hasTp && !hasSl) {
        alert(t('alert_tpsl_required'));
        return;
      }
      try {
        const res = await fetch('/api/positions/tpsl', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbol,
            take_profit: hasTp ? tp : null,
            stop_loss: hasSl ? sl : null
          })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function submitSmartTp() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      try {
        const res = await fetch('/api/positions/smart-tp', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
        fetchOrders('');
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function submitSmartSl() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      try {
        const res = await fetch('/api/positions/smart-sl', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
        fetchOrders('');
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function loadTradingStatus() {
      try {
        const res = await fetch('/api/trading/status', { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        if (data.enabled) {
          state.tradingEnabled = true;
          state.tradingMode = data.mode || '';
          state.tradingHasEnv = !!data.has_env;
          setTradeStatus(`${t('status_trading_enabled')} (${state.tradingMode.replace('_', '/')} ${currentLang === 'zh' ? 'æ¨¡å¼' : 'mode'}).`, true);
          document.getElementById('open_trading_modal').textContent = t('status_trading_enabled');
          ensureOrdersLoaded();
        } else {
          state.tradingEnabled = false;
          state.tradingMode = '';
          state.tradingHasEnv = !!data.has_env;
          setTradeStatus(t('status_trading_disabled'), false);
          document.getElementById('open_trading_modal').textContent = t('button_enable_trading');
          if (state.tradingHasEnv) {
            ensureOrdersLoaded();
          }
        }
        updateTradingFormState();
        syncChartTradingState();
      } catch (e) {}
    }

    async function enableTrading() {
      const apiKey = document.getElementById('trade_api_key').value.trim();
      const apiSecret = document.getElementById('trade_api_secret').value.trim();
      const mode = document.getElementById('trade_mode').value;
      const ack = document.getElementById('trade_ack').checked;
      const useEnv = document.getElementById('trade_use_env').checked;
      const demo = document.getElementById('trade_demo').checked;

      if (!ack) {
        alert(t('alert_ack_risk'));
        return;
      }
      if (!useEnv && (!apiKey || !apiSecret)) {
        alert(t('alert_keys_required'));
        return;
      }
      if (useEnv && !state.tradingHasEnv) {
        alert(t('alert_no_env'));
        return;
      }

      try {
        const res = await fetch('/api/trading/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ api_key: apiKey, api_secret: apiSecret, mode, use_env: useEnv, demo })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_enable_failed'));
        }
        state.tradingEnabled = true;
        state.tradingMode = mode;
        document.getElementById('trade_api_key').value = '';
        document.getElementById('trade_api_secret').value = '';
        document.getElementById('trade_ack').checked = false;
        document.getElementById('trade_use_env').checked = false;
        document.getElementById('trade_demo').checked = false;
        setTradeStatus(`${t('status_trading_enabled')} (${mode.replace('_', '/')} ${currentLang === 'zh' ? 'æ¨¡å¼' : 'mode'}).`, true);
        updateTradingFormState();
        fetchOrders('');
        document.getElementById('trading_modal').classList.remove('active');
      } catch (e) {
        setTradeStatus(t('status_trading_disabled'), false);
        alert(e.message || t('alert_enable_failed'));
      }
    }

    async function disableTrading() {
      try {
        const res = await fetch('/api/trading/disable', { method: 'POST' });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_disable_failed'));
        }
        state.tradingEnabled = false;
        state.tradingMode = '';
        setTradeStatus(t('status_trading_disabled'), false);
        document.getElementById('open_trading_modal').textContent = t('button_enable_trading');
        state.ordersLoaded = false;
      } catch (e) {
        alert(e.message || t('alert_disable_failed'));
      }
    }

    function ensureOrdersLoaded() {
      if (state.ordersLoaded) return;
      fetchOrders('');
    }

    async function fetchOrders(symbolOverride = '') {
      const content = document.getElementById('orders_content');
      try {
        const symbol = symbolOverride || '';
        const res = await fetch('/api/orders/list', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || (currentLang === 'zh' ? 'èŽ·å–è®¢å•å¤±è´¥ã€‚' : 'Failed to fetch orders.'));
        }
        state.ordersCache = Array.isArray(data.orders) ? data.orders : [];
        state.ordersCacheSymbol = symbol ? symbol : 'all';
        state.ordersLoaded = true;
        renderOrders(data.orders || []);
        updateOrdersOverlay();
      } catch (e) {
        content.innerHTML = `<div class="muted">${t('status_orders_error')} ${e.message}</div>`;
      }
    }

    function renderOrders(orders) {
      const content = document.getElementById('orders_content');
      if (!Array.isArray(orders) || orders.length === 0) {
        content.innerHTML = `<div class="muted">${t('status_no_orders')}</div>`;
        return;
      }
      let html = `<table><thead><tr><th>${t('orders_table_symbol')}</th><th>${t('orders_table_side')}</th><th>${t('orders_table_type')}</th><th>${t('orders_table_qty')}</th><th>${t('orders_table_price')}</th><th>${t('orders_table_status')}</th><th>${t('orders_table_action')}</th></tr></thead><tbody>`;
      orders.forEach(order => {
        const orderId = order.orderId || order.orderID || '';
        const symbol = order.symbol || order.Symbol || '-';
        html += `<tr>
          <td>${symbol}</td>
          <td>${order.side || '-'}</td>
          <td>${order.orderType || order.type || '-'}</td>
          <td>${order.qty || order.leavesQty || 0}</td>
          <td>${order.price || order.avgPrice || 0}</td>
          <td>${order.orderStatus || order.status || '-'}</td>
          <td><button data-order-id="${orderId}" data-symbol="${symbol}" class="cancel-order">${t('orders_cancel')}</button></td>
        </tr>`;
      });
      html += '</tbody></table>';
      content.innerHTML = html;
      content.querySelectorAll('.cancel-order').forEach(btn => {
        btn.addEventListener('click', () => cancelOrder(btn.dataset.orderId, btn.dataset.symbol));
      });
    }

    async function cancelOrder(orderId, symbol) {
      if (!orderId || !symbol) {
        alert(t('alert_missing_order'));
        return;
      }
      if (!state.tradingEnabled) {
        alert(t('alert_trading_required'));
        return;
      }
      if (!confirm(`${t('alert_cancel_confirm')} ${orderId}?`)) return;
      try {
        const res = await fetch('/api/orders/cancel', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ order_id: orderId, symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || 'Cancel failed.');
        }
        fetchOrders();
      } catch (e) {
        alert(e.message || t('alert_cancel_failed'));
      }
    }

    function updateOrdersOverlay() {
      if (!candleSeries) return;
      const showOrders = document.getElementById('chart_show_orders').checked;
      if (!showOrders) {
        chartOrderLines.forEach(line => candleSeries.removePriceLine(line));
        chartOrderLines = [];
        state.chartOrderSignature = '';
        return;
      }
      const symbol = getChartSymbol();
      if (!symbol) return;
      if (state.ordersCacheSymbol && state.ordersCacheSymbol !== 'all' && state.ordersCacheSymbol !== symbol) {
        return;
      }
      const orders = state.ordersCache.filter(o => (o.symbol || o.Symbol) === symbol);
      const orderSignature = orders.map(o => `${o.orderId || o.orderID || ''}:${o.price || o.avgPrice || ''}:${o.side || ''}`).join('|');
      if (orderSignature === state.chartOrderSignature) return;
      chartOrderLines.forEach(line => candleSeries.removePriceLine(line));
      chartOrderLines = [];
      orders.forEach(order => {
        const price = parseFloat(order.price || order.avgPrice || '');
        if (!Number.isFinite(price) || price <= 0) return;
        const side = String(order.side || '').toLowerCase();
        const isBuy = side.startsWith('b');
        chartOrderLines.push(candleSeries.createPriceLine({
          price,
          color: isBuy ? '#27d07d' : '#ff6b6b',
          lineWidth: 1,
          lineStyle: 1,
          axisLabelVisible: true,
          title: isBuy ? t('chart_order_buy') : t('chart_order_sell'),
        }));
      });
      state.chartOrderSignature = orderSignature;
    }

    function getPosValue(pos, keys) {
      for (const key of keys) {
        const val = pos[key];
        if (val !== undefined && val !== null && val !== '') {
          return val;
        }
      }
      return 0;
    }

    function buildPnlTooltip(values) {
      const realisedLines = [];
      const unrealisedLines = [];
      if (values.realised !== undefined && values.realised !== null && values.realised !== 0) {
        realisedLines.push(`${t('tooltip_current_realised')}: ${values.realised}`);
      }
      if (values.funding !== undefined && values.funding !== null && values.funding !== 0) {
        realisedLines.push(`${t('tooltip_funding')}: ${values.funding}`);
      }
      if (values.closed !== undefined && values.closed !== null && values.closed !== 0) {
        realisedLines.push(`${t('tooltip_closed_pnl')}: ${values.closed}`);
      }
      if (values.breakEven !== undefined && values.breakEven !== null && values.breakEven !== 0) {
        unrealisedLines.push(`${t('tooltip_break_even')}: ${values.breakEven}`);
      }
      return {
        unrealised: unrealisedLines.length ? unrealisedLines.join(' | ') : t('tooltip_unrealised_pnl'),
        realised: realisedLines.length ? realisedLines.join(' | ') : t('tooltip_realised_pnl')
      };
    }

    function pnlClass(value) {
      const num = Number(value);
      if (!Number.isFinite(num) || num === 0) return '';
      return num > 0 ? 'pnl-positive' : 'pnl-negative';
    }

    function getChartSymbol() {
      const dropdown = document.getElementById('chart_symbol');
      if (dropdown && dropdown.value) return dropdown.value;
      if (state.metricsSymbols.includes('ETHUSDT')) return 'ETHUSDT';
      const first = state.metricsSymbols[0];
      return first || '';
    }

    function initChart() {
      const container = document.getElementById('chart_container');
      if (!container || !window.LightweightCharts) return;
      if (chart) return;
      chart = LightweightCharts.createChart(container, {
        layout: {
          background: { color: 'transparent' },
          textColor: '#d6e1f0',
          fontFamily: '"Inter", "SF Pro Text", "Segoe UI", system-ui, -apple-system, sans-serif'
        },
        grid: {
          vertLines: { color: 'rgba(91, 110, 140, 0.18)' },
          horzLines: { color: 'rgba(91, 110, 140, 0.18)' }
        },
        rightPriceScale: {
          borderVisible: false,
          scaleMargins: { top: 0.18, bottom: 0.2 },
          ticksVisible: true
        },
        timeScale: {
          borderVisible: false,
          timeVisible: true,
          rightOffset: 6,
          barSpacing: 12,
          tickMarkFormatter: getChartTickMarkFormatter()
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Magnet,
          vertLine: { color: 'rgba(124, 196, 255, 0.35)', width: 1, style: 1 },
          horzLine: { color: 'rgba(124, 196, 255, 0.35)', width: 1, style: 1 },
        },
        localization: {
          locale: currentLang === 'zh' ? 'zh-CN' : 'en-US',
          timeFormatter: getChartTimeFormatter()
        }
      });
      applyChartLocalization();
      candleSeries = chart.addCandlestickSeries({
        upColor: '#27d07d',
        downColor: '#ff6b6b',
        borderVisible: false,
        wickUpColor: '#35f49b',
        wickDownColor: '#ff7b7b',
        priceLineColor: 'rgba(124, 196, 255, 0.6)',
        priceLineWidth: 1,
      });
      tickSeries = chart.addLineSeries({
        color: '#7cc4ff',
        lineWidth: 2,
        crosshairMarkerVisible: true,
        priceLineVisible: true,
        lastValueVisible: true,
      });
      if (window.LightweightCharts && window.LightweightCharts.LineType) {
        tickSeries.applyOptions({ lineType: window.LightweightCharts.LineType.Simple });
      }
      tickSeries.applyOptions({ visible: false });
      chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        renderDrawings();
      });
      window.addEventListener('resize', () => {
        applyChartSize();
      });
      applyChartSize();
    }

    function resizeChart() {
      applyChartSize();
    }

    function applyChartSize() {
      const container = document.getElementById('chart_container');
      if (!container || !chart) return;
      const width = container.clientWidth;
      const height = Math.max(240, container.clientHeight);
      chart.applyOptions({ width, height });
      renderDrawings();
    }

    function setDrawMode(mode) {
      drawMode = mode;
      const svg = document.getElementById('chart_drawings');
      if (svg) {
        svg.classList.toggle('active', Boolean(drawMode));
      }
    }

    function getRelativePoint(event) {
      const svg = document.getElementById('chart_drawings');
      if (!svg) return null;
      const rect = svg.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
    }

    function renderDrawings() {
      const svg = document.getElementById('chart_drawings');
      if (!svg) return;
      const width = svg.clientWidth || svg.getBoundingClientRect().width || 1;
      const height = svg.clientHeight || svg.getBoundingClientRect().height || 1;
      svg.innerHTML = '';
      const renderRect = (x, y, w, h, className) => {
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return;
        if (w <= 0 || h <= 0) return;
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', x.toFixed(2));
        rect.setAttribute('y', y.toFixed(2));
        rect.setAttribute('width', w.toFixed(2));
        rect.setAttribute('height', h.toFixed(2));
        rect.setAttribute('class', className);
        svg.appendChild(rect);
      };
      for (const item of drawings) {
        if (item.type !== 'box') continue;
        const x = Math.min(item.x1, item.x2) * width;
        const y = Math.min(item.y1, item.y2) * height;
        const w = Math.abs(item.x2 - item.x1) * width;
        const h = Math.abs(item.y2 - item.y1) * height;
        renderRect(x, y, w, h, 'chart-drawing-rect');
      }
      if (chart && candleSeries) {
        // reserved for future strategy drawings
      }
      if (drawTempRect) {
        svg.appendChild(drawTempRect);
      }
    }

    function startDraw(event) {
      if (!drawMode) return;
      const point = getRelativePoint(event);
      if (!point) return;
      drawStart = point;
      const svg = document.getElementById('chart_drawings');
      if (!svg) return;
      if (event.pointerId != null && svg.setPointerCapture) {
        svg.setPointerCapture(event.pointerId);
      }
      drawTempRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      drawTempRect.setAttribute('class', 'chart-drawing-rect');
      svg.appendChild(drawTempRect);
      updateDraw(event);
    }

    function updateDraw(event) {
      if (!drawMode || !drawStart || !drawTempRect) return;
      const point = getRelativePoint(event);
      if (!point) return;
      const svg = document.getElementById('chart_drawings');
      if (!svg) return;
      const width = svg.clientWidth || svg.getBoundingClientRect().width || 1;
      const height = svg.clientHeight || svg.getBoundingClientRect().height || 1;
      const x = Math.min(drawStart.x, point.x) * width;
      const y = Math.min(drawStart.y, point.y) * height;
      const w = Math.abs(point.x - drawStart.x) * width;
      const h = Math.abs(point.y - drawStart.y) * height;
      drawTempRect.setAttribute('x', x.toFixed(2));
      drawTempRect.setAttribute('y', y.toFixed(2));
      drawTempRect.setAttribute('width', w.toFixed(2));
      drawTempRect.setAttribute('height', h.toFixed(2));
    }

    function endDraw(event) {
      if (!drawMode || !drawStart || !drawTempRect) return;
      const point = getRelativePoint(event);
      if (!point) return;
      const svg = document.getElementById('chart_drawings');
      if (event.pointerId != null && svg && svg.releasePointerCapture) {
        svg.releasePointerCapture(event.pointerId);
      }
      drawings.push({ type: 'box', x1: drawStart.x, y1: drawStart.y, x2: point.x, y2: point.y });
      drawStart = null;
      drawTempRect = null;
      renderDrawings();
    }


    function ensureChartReady() {
      initChart();
      requestAnimationFrame(() => {
        resizeChart();
        fetchKlines();
        startChartPolling();
      });
    }

    function isStreamInterval(interval) {
      return interval === 'tick' || interval === '1s' || interval === '5s';
    }

    function setChartSeriesMode(interval) {
      if (!candleSeries || !tickSeries) return;
      const isTick = interval === 'tick';
      tickSeries.applyOptions({ visible: isTick });
      candleSeries.applyOptions({ visible: !isTick });
    }

    function stopTradeStream() {
      if (tradeStream) {
        tradeStream.close();
        tradeStream = null;
      }
      state.streamInterval = '';
    }

    function applyTradeToStream(trade, bucketSeconds) {
      const ts = Number(trade.ts || 0);
      const price = Number(trade.price || 0);
      const qty = Number(trade.qty || 0);
      if (!Number.isFinite(ts) || !Number.isFinite(price)) return;
      const base = Math.floor(ts);
      const bucket = Math.floor(base / bucketSeconds) * bucketSeconds;
      let candle = streamCandles[streamCandles.length - 1];
      if (!candle || candle.time !== bucket) {
        candle = {
          time: bucket,
          open: price,
          high: price,
          low: price,
          close: price,
          volume: qty
        };
        streamCandles.push(candle);
        if (streamCandles.length > 300) {
          streamCandles = streamCandles.slice(-300);
        }
      } else {
        candle.high = Math.max(candle.high, price);
        candle.low = Math.min(candle.low, price);
        candle.close = price;
        candle.volume = (candle.volume || 0) + qty;
      }
      candleSeries.setData(streamCandles);
    }

    function normalizeTickTime(ts) {
      let t = Number(ts || 0);
      if (!Number.isFinite(t) || t <= 0) return 0;
      if (t <= lastTickTime) {
        t = lastTickTime + 0.001;
      }
      lastTickTime = t;
      return t;
    }

    function applyTradeToTick(trade) {
      const ts = Number(trade.ts || 0);
      const price = Number(trade.price || 0);
      if (!Number.isFinite(ts) || !Number.isFinite(price)) return;
      const time = normalizeTickTime(ts);
      if (!time) return;
      const point = { time, value: price };
      tickPoints.push(point);
      if (tickPoints.length < 2) {
        tickSeries.setData(tickPoints);
      } else {
        tickSeries.update(point);
      }
      if (tickPoints.length > TICK_MAX_POINTS && tickPoints.length % TICK_TRIM_EVERY === 0) {
        tickPoints = tickPoints.slice(-TICK_MAX_POINTS);
        scheduleTickSync();
      }
    }

    function scheduleTickSync() {
      if (tickUpdateQueued) return;
      tickUpdateQueued = true;
      requestAnimationFrame(() => {
        tickUpdateQueued = false;
        if (tickSeries) {
          tickSeries.setData(tickPoints);
        }
      });
    }

    function startTradeStream(interval) {
      stopTradeStream();
      const symbol = getChartSymbol();
      if (!symbol) return;
      streamCandles = [];
      state.streamInterval = interval;
      if (interval === 'tick') {
        tickPoints = [];
        tickSeries.setData([]);
        lastTickTime = 0;
      } else if (interval === '1s' || interval === '5s') {
        candleSeries.setData([]);
      } else {
        candleSeries.setData([]);
      }
      tradeStream = new EventSource(`/api/trades/stream?symbol=${encodeURIComponent(symbol)}`);
      tradeStream.addEventListener('snapshot', (event) => {
        try {
          if (state.streamInterval !== interval || document.getElementById('chart_interval').value !== interval) return;
          const payload = JSON.parse(event.data);
          const trades = Array.isArray(payload.trades) ? payload.trades : [];
          trades.sort((a, b) => (a.ts || 0) - (b.ts || 0));
          if (interval === 'tick') {
            lastTickTime = 0;
            tickPoints = trades.map(t => {
              const time = normalizeTickTime(t.ts);
              return time ? { time, value: t.price } : null;
            }).filter(Boolean);
            tickSeries.setData(tickPoints);
          } else if (interval === '1s') {
            trades.forEach(trade => applyTradeToStream(trade, 1));
          } else if (interval === '5s') {
            trades.forEach(trade => applyTradeToStream(trade, 5));
          }
        } catch (e) {}
      });
      tradeStream.onmessage = (event) => {
        try {
          if (state.streamInterval !== interval || document.getElementById('chart_interval').value !== interval) return;
          const trade = JSON.parse(event.data);
          if (interval === 'tick') {
            applyTradeToTick(trade);
          } else if (interval === '1s') {
            applyTradeToStream(trade, 1);
          } else if (interval === '5s') {
            applyTradeToStream(trade, 5);
          }
        } catch (e) {}
      };
    }

    async function fetchKlines() {
      if (!candleSeries) return;
      const symbol = getChartSymbol();
      const status = document.getElementById('chart_status');
      const note = document.getElementById('chart_note');
      if (note) note.textContent = '';
      if (!symbol) {
        if (status) status.textContent = t('chart_hint');
        return;
      }
      const interval = document.getElementById('chart_interval').value;
      const isIntervalChange = state.lastKlineInterval !== interval || state.lastKlineSymbol !== symbol;
      if (isIntervalChange) {
        state.chartHasLoaded = false;
        state.lastKlineTime = 0;
        state.newCandleCount = 0;
      }
      setChartSeriesMode(interval);
      if (isStreamInterval(interval)) {
        if (status) status.textContent = `${symbol} Â· ${interval}`;
        startTradeStream(interval);
        state.chartRange = null;
        if (candleSeries) {
          candleSeries.setMarkers([]);
        }
        applyChartLocalization();
        requestOverlayUpdate();
        return;
      }
      stopTradeStream();
      if (tickSeries) {
        tickPoints = [];
        tickSeries.setData([]);
        lastTickTime = 0;
      }
      applyChartLocalization();
      const limit = 300;
      const qs = new URLSearchParams({ symbol, interval, limit: String(limit) });
      const res = await fetch(`/api/klines?${qs.toString()}`, { cache: 'no-store' });
      if (!res.ok) {
        if (status) status.textContent = currentLang === 'zh' ? 'èŽ·å– K çº¿å¤±è´¥ã€‚' : 'Failed to fetch klines.';
        return;
      }
      const data = await res.json();
      if (data.error || !Array.isArray(data.klines)) {
        if (status) status.textContent = data.error || (currentLang === 'zh' ? 'æš‚æ—  K çº¿æ•°æ®ã€‚' : 'No kline data available.');
        return;
      }
      suppressRangeTracking = true;
      chartKlinesCache = data.klines;
      candleSeries.setData(data.klines);
      if (data.klines.length > 0) {
        const latestTime = data.klines[data.klines.length - 1].time;
        if (latestTime && latestTime !== state.lastKlineTime) {
          if (state.lastKlineTime) {
            state.newCandleCount += 1;
          }
          state.lastKlineTime = latestTime;
        }
      }
      if (chart && !state.chartHasLoaded) {
        chart.timeScale().fitContent();
      }
      suppressRangeTracking = false;
      state.chartHasLoaded = true;
      if (data.klines.length > 1) {
        state.chartRange = {
          from: data.klines[0].time,
          to: data.klines[data.klines.length - 1].time
        };
      }
      state.lastKlineInterval = interval;
      state.lastKlineSymbol = symbol;
      if (status) status.textContent = `${symbol} Â· ${interval} ${currentLang === 'zh' ? 'å‘¨æœŸ' : 'interval'}`;
      requestOverlayUpdate();
    }

    function requestOverlayUpdate() {
      if (!state.chartVisible) return;
      if (chartOverlayTimer) return;
      chartOverlayTimer = setTimeout(() => {
        chartOverlayTimer = null;
        state.chartLastOverlayTs = Date.now();
        updateChartOverlays();
      }, 600);
    }


    async function updateChartOverlays() {
      if (!candleSeries) return;
      const symbol = getChartSymbol();
      if (!symbol) return;

      chartPositionLines.forEach(line => candleSeries.removePriceLine(line));
      chartPositionLines = [];

      const showBreakeven = document.getElementById('chart_show_breakeven').checked;
      const showLiq = document.getElementById('chart_show_liq').checked;
      const showOrders = document.getElementById('chart_show_orders').checked;
      const showTrades = document.getElementById('chart_show_trades').checked;
      const intervalValue = document.getElementById('chart_interval').value;

      try {
        const posRes = await fetch('/api/positions', { cache: 'no-store' });
        if (posRes.ok) {
          const posData = await posRes.json();
          const positions = Array.isArray(posData.positions) ? posData.positions : [];
          const pos = positions.find(p => (p.symbol || p.Symbol) === symbol);
          if (pos) {
            const breakeven = parseFloat(pos.breakEvenPrice || pos.BreakEvenPrice || '');
            const liq = parseFloat(pos.liqPrice || pos.LiqPrice || '');
            if (showBreakeven && Number.isFinite(breakeven) && breakeven > 0) {
              chartPositionLines.push(candleSeries.createPriceLine({
                price: breakeven,
                color: '#d7dee8',
                lineWidth: 1,
                lineStyle: 2,
                axisLabelVisible: true,
                title: t('chart_break_even'),
              }));
            }
            if (showLiq && Number.isFinite(liq) && liq > 0) {
              chartPositionLines.push(candleSeries.createPriceLine({
                price: liq,
                color: '#ff6b6b',
                lineWidth: 1,
                lineStyle: 3,
                axisLabelVisible: true,
                title: t('chart_liq'),
              }));
            }
          }
        }
      } catch (e) {}

      let combinedMarkers = [];
      if (showTrades && intervalValue !== 'tick') {
        const range = state.chartRange;
        if (!range) return;
        const markers = [];
        const intervalSeconds = getIntervalSeconds(intervalValue);
        if (intervalSeconds > 0 && intervalSeconds < 60) {
          candleSeries.setMarkers([]);
          chartMarkersCache = [];
          state.chartMarkerSignature = '';
          return;
        }
        const bucketMap = new Map();
        const trades = state.history.filter(r => r.symbol === symbol);
        for (const trade of trades) {
          const ts = Number(trade.ts || 0);
          if (!Number.isFinite(ts) || ts <= 0) continue;
          const bucketTime = intervalSeconds > 0 ? Math.floor(ts / intervalSeconds) * intervalSeconds : ts;
          if (bucketTime < range.from || bucketTime > range.to) continue;
          const existing = bucketMap.get(bucketTime);
          if (!existing || ts > existing.ts) {
            bucketMap.set(bucketTime, { trade, ts, bucketTime });
          }
        }
        for (const item of bucketMap.values()) {
          const trade = item.trade;
          const side = String(trade.side || '').toLowerCase();
          const isBuy = side.startsWith('b');
          markers.push({
            time: item.bucketTime,
            position: isBuy ? 'belowBar' : 'aboveBar',
            color: isBuy ? '#27d07d' : '#ff6b6b',
            shape: isBuy ? 'arrowUp' : 'arrowDown',
            text: isBuy ? 'B' : 'S',
          });
        }
        if (markers.length > 200) {
          const status = document.getElementById('chart_status');
          if (status) status.textContent = 'Too many trades in range. Zoom in or reduce interval.';
          candleSeries.setMarkers([]);
          chartMarkersCache = [];
          state.chartMarkerSignature = '';
          return;
        }
        const sig = `${symbol}|${range.from}|${range.to}|${markers.length}|${markers[0]?.time || 0}|${markers[markers.length - 1]?.time || 0}`;
        if (sig !== state.chartMarkerSignature) {
          chartMarkersCache = markers;
          state.chartMarkerSignature = sig;
        }
        combinedMarkers = combinedMarkers.concat(chartMarkersCache);
      }

      if (combinedMarkers.length) {
        candleSeries.setMarkers(combinedMarkers);
      } else {
        candleSeries.setMarkers([]);
        chartMarkersCache = [];
        state.chartMarkerSignature = '';
      }
    }

    function getIntervalSeconds(intervalValue) {
      if (intervalValue === '5s') return 5;
      if (intervalValue === '1s') return 1;
      if (intervalValue === 'tick') return 1;
      if (/^\d+$/.test(intervalValue)) {
        return parseInt(intervalValue, 10) * 60;
      }
      if (intervalValue === 'D') return 86400;
      return 0;
    }

    function startChartPolling() {
      if (chartTimer) clearInterval(chartTimer);
      const interval = document.getElementById('chart_interval').value;
      if (isStreamInterval(interval)) return;
      const auto = document.getElementById('chart_auto').checked;
      if (!auto) return;
      const refresh = parseInt(document.getElementById('chart_refresh').value || '5000', 10);
      chartTimer = setInterval(fetchKlines, isNaN(refresh) ? 5000 : refresh);
    }

    function exportHistory() {
      exportHistoryBybitCsv();
    }

    function pad2(value) {
      return String(value).padStart(2, '0');
    }

    function formatUtcTime(tsSeconds) {
      if (!tsSeconds) return '';
      const ms = tsSeconds > 1000000000000 ? tsSeconds : tsSeconds * 1000;
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return '';
      return `${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())} ${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-${pad2(d.getUTCDate())}`;
    }

    function csvEscape(value) {
      if (value === null || value === undefined) return '';
      const str = String(value);
      if (/[",\n]/.test(str)) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    }

    function downloadCsv(filename, rows, columns) {
      const header = columns.map(col => csvEscape(col.label)).join(',');
      const lines = [header];
      for (const row of rows) {
        const line = columns.map(col => csvEscape(row[col.key] ?? '')).join(',');
        lines.push(line);
      }
      const text = lines.join('\n');
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'text/csv' }));
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function formatDateStamp(value) {
      if (!value) return '';
      const d = new Date(value);
      if (Number.isNaN(d.getTime())) return '';
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, '0');
      const day = String(d.getUTCDate()).padStart(2, '0');
      return `${y}${m}${day}`;
    }

    function buildExportFilename(prefix, symbol, startDate, endDate, days) {
      const symbolTag = symbol ? symbol : 'ALL';
      const startTag = startDate ? formatDateStamp(`${startDate}T00:00:00Z`) : '';
      const endTag = endDate ? formatDateStamp(`${endDate}T00:00:00Z`) : '';
      if (startTag || endTag) {
        const rangeTag = `${startTag || 'NA'}-${endTag || 'NA'}`;
        return `${prefix}_${symbolTag}_${rangeTag}.csv`;
      }
      return `${prefix}_${symbolTag}_${days || 'range'}d.csv`;
    }

    function buildBybitOrderHistoryRows(fills) {
      const orders = new Map();
      for (const fill of fills || []) {
        if (!fill || !fill.order_id) continue;
        const symbol = fill.symbol || '';
        const side = fill.side || '';
        const key = `${fill.order_id}|${symbol}|${side}`;
        const qty = Number(fill.qty) || 0;
        const price = Number(fill.price) || 0;
        const fee = Number(fill.fee) || 0;
        const feeCcy = fill.fee_ccy || '';
        let entry = orders.get(key);
        if (!entry) {
          entry = {
            order_id: fill.order_id,
            symbol,
            side,
            qty: 0,
            notional: 0,
            min_ts: fill.ts || 0,
            max_ts: fill.ts || 0,
            fee_by_ccy: {}
          };
          orders.set(key, entry);
        }
        entry.qty += qty;
        entry.notional += qty * price;
        entry.min_ts = Math.min(entry.min_ts || fill.ts || 0, fill.ts || 0);
        entry.max_ts = Math.max(entry.max_ts || fill.ts || 0, fill.ts || 0);
        if (feeCcy) {
          entry.fee_by_ccy[feeCcy] = (entry.fee_by_ccy[feeCcy] || 0) + fee;
        }
      }

      const rows = [];
      for (const entry of orders.values()) {
        const filledPrice = entry.qty ? entry.notional / entry.qty : '';
        const feeInfo = Object.keys(entry.fee_by_ccy).length ? JSON.stringify(entry.fee_by_ccy) : '';
        const suffix = entry.order_id.slice(-8);
        rows.push({
          market: entry.symbol,
          order_qty: entry.qty || '',
          order_price: filledPrice || '',
          filled_price: filledPrice || '',
          trigger_price: '',
          filled_qty: entry.qty || '',
          fee_info: feeInfo,
          direction: entry.side === 'Buy' ? 'Long' : entry.side === 'Sell' ? 'Short' : entry.side,
          order_type: '',
          order_status: entry.qty ? 'Filled' : '',
          order_id: suffix,
          order_time: formatUtcTime(entry.min_ts),
          tif: '',
          create_time: formatUtcTime(entry.min_ts),
          max_slippage: '',
          max_slippage_type: '',
          limit_tpsl_strategy: '',
          bbo_side_type: '',
          bbo_level: ''
        });
      }

      rows.sort((a, b) => (b.order_time || '').localeCompare(a.order_time || ''));
      return rows;
    }

    function formatUtcFromMs(value) {
      if (!value) return '';
      const ms = Number(value);
      if (!Number.isFinite(ms)) return '';
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return '';
      return `${String(d.getUTCHours()).padStart(2, '0')}:${String(d.getUTCMinutes()).padStart(2, '0')} ${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}-${String(d.getUTCDate()).padStart(2, '0')}`;
    }

    function buildOrderHistoryRows(orders) {
      return (orders || []).map(o => {
        const orderId = o.orderId || o.orderID || '';
        const orderQty = o.qty ?? o.orderQty ?? '';
        const filledQty = o.cumExecQty ?? o.filledQty ?? '';
        const avgPrice = o.avgPrice ?? o.filledPrice ?? '';
        const orderPrice = o.price ?? o.orderPrice ?? '';
        return {
          market: o.symbol || '',
          order_qty: orderQty,
          order_price: orderPrice,
          filled_price: avgPrice,
          trigger_price: o.triggerPrice ?? '',
          filled_qty: filledQty,
          fee_info: o.feeInfo ?? '',
          direction: o.side === 'Buy' ? 'Long' : o.side === 'Sell' ? 'Short' : (o.side || ''),
          order_type: o.orderType || '',
          order_status: o.orderStatus || '',
          order_id: orderId ? String(orderId).slice(-8) : '',
          order_time: formatUtcFromMs(o.updatedTime || o.createdTime || ''),
          tif: o.timeInForce || '',
          create_time: formatUtcFromMs(o.createdTime || ''),
          max_slippage: o.maxSlippage ?? '',
          max_slippage_type: o.maxSlippageType ?? '',
          limit_tpsl_strategy: o.tpslMode ?? '',
          bbo_side_type: o.bboSideType ?? '',
          bbo_level: o.bboLevel ?? ''
        };
      });
    }

    function buildFillRows(fills) {
      return (fills || []).map(f => {
        const ts = f.ts ? new Date(f.ts * 1000) : null;
        const timeStr = ts ? `${String(ts.getUTCHours()).padStart(2, '0')}:${String(ts.getUTCMinutes()).padStart(2, '0')} ${ts.getUTCFullYear()}-${String(ts.getUTCMonth() + 1).padStart(2, '0')}-${String(ts.getUTCDate()).padStart(2, '0')}` : '';
        return {
          time: timeStr,
          symbol: f.symbol || '',
          side: f.side || '',
          qty: f.qty ?? '',
          price: f.price ?? '',
          notional: f.notional ?? '',
          fee: f.fee ?? '',
          fee_ccy: f.fee_ccy || '',
          exec_pnl: f.exec_pnl ?? '',
          order_id: f.order_id || '',
          is_maker: f.is_maker ?? ''
        };
      });
    }

    function getFillColumns() {
      return [
        { key: 'time', label: 'Time(UTC)' },
        { key: 'symbol', label: 'Symbol' },
        { key: 'side', label: 'Side' },
        { key: 'qty', label: 'Qty' },
        { key: 'price', label: 'Price' },
        { key: 'notional', label: 'Notional' },
        { key: 'fee', label: 'Fee' },
        { key: 'fee_ccy', label: 'Fee Ccy' },
        { key: 'exec_pnl', label: 'Exec PnL' },
        { key: 'order_id', label: 'Order ID' },
        { key: 'is_maker', label: 'Is Maker' }
      ];
    }

    function getBybitOrderHistoryColumns() {
      return [
        { key: 'market', label: 'Market' },
        { key: 'order_qty', label: 'Order Quantity' },
        { key: 'order_price', label: 'Order Price' },
        { key: 'filled_price', label: 'Filled Price' },
        { key: 'trigger_price', label: 'Trigger Price' },
        { key: 'filled_qty', label: 'Filled Quantity' },
        { key: 'fee_info', label: 'feeInfo' },
        { key: 'direction', label: 'Direction' },
        { key: 'order_type', label: 'Order Type' },
        { key: 'order_status', label: 'Order Status' },
        { key: 'order_id', label: 'Order ID' },
        { key: 'order_time', label: 'Order Time(UTC+0)' },
        { key: 'tif', label: 'Time In Force' },
        { key: 'create_time', label: 'Create Time' },
        { key: 'max_slippage', label: 'Max Slippage' },
        { key: 'max_slippage_type', label: 'Max Slippage Type' },
        { key: 'limit_tpsl_strategy', label: 'Limit Tpsl Strategy' },
        { key: 'bbo_side_type', label: 'Bbo Side Type' },
        { key: 'bbo_level', label: 'Bbo Level' }
      ];
    }

    function exportHistoryBybitCsv() {
      const columns = getBybitOrderHistoryColumns();
      const rows = buildBybitOrderHistoryRows(getFilteredHistoryRows(null));
      const symbol = getHistorySymbol();
      const { startTs, endTs } = getDateRangeFromInputs('filter_start', 'filter_end');
      const startDate = startTs ? new Date(startTs * 1000).toISOString().slice(0, 10) : '';
      const endDate = endTs ? new Date(endTs * 1000).toISOString().slice(0, 10) : '';
      const filename = buildExportFilename('trade_history_bybit', symbol, startDate, endDate, '');
      downloadCsv(filename, rows, columns);
    }

    function clearHistory() {
      if (!confirm(currentLang === 'zh' ? 'æ¸…é™¤æœ¬åœ°äº¤æ˜“åŽ†å²ï¼Ÿ' : 'Clear local trade history?')) return;
      state.history = [];
      state.historyIndex = new Set();
      saveHistory();
      updateSymbolOptions();
      renderHistory();
      renderConsistency();
    }

    loadHistory();
    setLanguage('zh');
    updateChartHeight(460);
    updateChartOrderMode();
    updateSymbolOptions();
    applyTabs();
    syncAnalysisDateRangeUI();
    syncAdvancedDateRangeUI();
    document.getElementById('apply_filters').addEventListener('click', () => {
      renderHistory();
      renderConsistency();
    });
    document.getElementById('export_history').addEventListener('click', exportHistory);
    document.getElementById('clear_history').addEventListener('click', clearHistory);
    document.getElementById('refresh_analysis').addEventListener('click', fetchAnalysis);
    document.getElementById('generate_advanced').addEventListener('click', fetchAdvancedAnalysis);
    document.getElementById('chart_modal_close').addEventListener('click', () => {
      const modal = document.getElementById('chart_modal');
      if (modal) modal.classList.remove('active');
    });
    document.getElementById('refresh_positions').addEventListener('click', fetchPositions);
    document.getElementById('enable_trading').addEventListener('click', enableTrading);
    document.getElementById('disable_trading').addEventListener('click', disableTrading);
    document.getElementById('refresh_orders').addEventListener('click', () => fetchOrders(''));
    document.getElementById('lang_select').addEventListener('change', (e) => setLanguage(e.target.value));
    document.getElementById('open_trading_modal').addEventListener('click', () => {
      document.getElementById('trading_modal').classList.add('active');
      loadTradingStatus();
      updateTradingFormState();
    });
    const on = (id, evt, fn) => {
      const el = document.getElementById(id);
      if (el) el.addEventListener(evt, fn);
    };
    on('close_trading_modal', 'click', () => {
      const modal = document.getElementById('trading_modal');
      if (modal) modal.classList.remove('active');
    });
    on('open_donate', 'click', () => {
      const modal = document.getElementById('donate_modal');
      if (modal) modal.classList.add('active');
    });
    on('close_donate_modal', 'click', () => {
      const modal = document.getElementById('donate_modal');
      if (modal) modal.classList.remove('active');
    });
    on('close_position_modal', 'click', () => {
      const modal = document.getElementById('position_modal');
      if (modal) modal.classList.remove('active');
    });
    on('trading_modal', 'click', (e) => {
      if (e.target.id === 'trading_modal') {
        const modal = document.getElementById('trading_modal');
        if (modal) modal.classList.remove('active');
      }
    });
    on('donate_modal', 'click', (e) => {
      if (e.target.id === 'donate_modal') {
        const modal = document.getElementById('donate_modal');
        if (modal) modal.classList.remove('active');
      }
    });
    on('position_modal', 'click', (e) => {
      if (e.target.id === 'position_modal') {
        const modal = document.getElementById('position_modal');
        if (modal) modal.classList.remove('active');
      }
    });
    on('trade_ack', 'change', updateTradingFormState);
    on('trade_use_env', 'change', updateTradingFormState);
    on('trade_demo', 'change', updateTradingFormState);
    on('trade_api_key', 'input', updateTradingFormState);
    on('trade_api_secret', 'input', updateTradingFormState);
    on('chart_order_mode', 'change', updateChartOrderMode);
    on('chart_buy', 'click', () => submitChartOrder('Buy'));
    on('chart_sell', 'click', () => submitChartOrder('Sell'));
    on('position_set_tpsl', 'click', submitPositionTpSl);
    on('position_smart_tp', 'click', submitSmartTp);
    on('position_smart_sl', 'click', submitSmartSl);
    on('position_close', 'click', submitPositionClose);
    on('chart_height', 'input', (e) => updateChartHeight(e.target.value));
    on('chart_symbol', 'change', () => {
      fetchKlines();
      requestOverlayUpdate();
      updateOrdersOverlay();
    });
    on('chart_interval', 'change', () => {
      fetchKlines();
    });
    on('chart_interval', 'change', applyChartLocalization);
    on('chart_interval', 'change', startChartPolling);
    on('chart_refresh', 'change', startChartPolling);
    on('chart_auto', 'change', startChartPolling);
    on('chart_show_breakeven', 'change', requestOverlayUpdate);
    on('chart_show_liq', 'change', requestOverlayUpdate);
    on('chart_show_orders', 'change', updateOrdersOverlay);
    on('chart_show_trades', 'change', requestOverlayUpdate);
    on('chart_reload', 'click', () => {
      fetchKlines();
    });
    const drawSvg = document.getElementById('chart_drawings');
    if (drawSvg) {
      drawSvg.addEventListener('pointerdown', startDraw);
      drawSvg.addEventListener('pointermove', updateDraw);
      drawSvg.addEventListener('pointerup', endDraw);
      drawSvg.addEventListener('pointerleave', endDraw);
    }
    on('chart_draw_box', 'click', () => {
      setDrawMode(drawMode === 'box' ? null : 'box');
    });
    on('chart_clear_drawings', 'click', () => {
      drawings = [];
      drawStart = null;
      drawTempRect = null;
      renderDrawings();
    });
    on('chart_add_symbol', 'click', () => {
      const input = document.getElementById('chart_custom_symbol');
      if (!input) return;
      const symbol = (input.value || '').trim().toUpperCase();
      if (!symbol) return;
      if (!state.customSymbols.includes(symbol)) {
        state.customSymbols.push(symbol);
        updateSymbolOptions();
      }
      const chartSelect = document.getElementById('chart_symbol');
      if (chartSelect) chartSelect.value = symbol;
      input.value = '';
      fetchKlines();
    });
    on('filter_symbol', 'change', () => {
      renderHistory();
      renderConsistency();
    });
    on('analysis_timeframe', 'change', () => {
      document.getElementById('analysis_use_range').checked = false;
      syncAnalysisDateRangeUI();
    });
    on('analysis_use_range', 'change', syncAnalysisDateRangeUI);
    on('advanced_timeframe', 'change', () => {
      document.getElementById('advanced_use_range').checked = false;
      syncAdvancedDateRangeUI();
    });
    on('advanced_use_range', 'change', syncAdvancedDateRangeUI);
    on('export_analysis', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('source', 'rest');
      qs.set('limit', '20000');
      let startVal = '';
      let endVal = '';
      if (isAnalysisDateRangeEnabled()) {
        startVal = document.getElementById('analysis_start')?.value || '';
        endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/analysis/fills?${qs.toString()}`).then(r => r.json()).then(data => {
        const fills = Array.isArray(data?.fills) ? data.fills : [];
        const rows = buildBybitOrderHistoryRows(fills);
        const columns = getBybitOrderHistoryColumns();
        const filename = buildExportFilename('analysis_bybit', symbol, startVal, endVal, days);
        downloadCsv(filename, rows, columns);
      }).catch(e => alert(t('alert_export_error')));
    });
    on('export_analysis_fills', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('source', 'rest');
      qs.set('limit', '20000');
      let startVal = '';
      let endVal = '';
      if (isAnalysisDateRangeEnabled()) {
        startVal = document.getElementById('analysis_start')?.value || '';
        endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/analysis/fills?${qs.toString()}`).then(r => r.json()).then(data => {
        const fills = Array.isArray(data?.fills) ? data.fills : [];
        const rows = buildFillRows(fills);
        const columns = getFillColumns();
        const filename = buildExportFilename('analysis_fills', symbol, startVal, endVal, days);
        downloadCsv(filename, rows, columns);
      }).catch(e => alert(t('alert_export_error')));
    });
    on('export_order_history', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('limit', '20000');
      let startVal = '';
      let endVal = '';
      if (isAnalysisDateRangeEnabled()) {
        startVal = document.getElementById('analysis_start')?.value || '';
        endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/orders/history?${qs.toString()}`).then(r => r.json()).then(data => {
        const orders = Array.isArray(data?.orders) ? data.orders : [];
        const rows = buildOrderHistoryRows(orders);
        const columns = getBybitOrderHistoryColumns();
        const filename = buildExportFilename('order_history', symbol, startVal, endVal, days);
        downloadCsv(filename, rows, columns);
      }).catch(e => alert(t('alert_export_error')));
    });
    on('compare_sources', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('limit', '20000');
      if (isAnalysisDateRangeEnabled()) {
        const startVal = document.getElementById('analysis_start')?.value || '';
        const endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/analysis/compare?${qs.toString()}`).then(r => r.json()).then(data => {
        state.analysisCompare = data && data.ok ? data : null;
        if (state.analysisData) {
          renderAnalysis(state.analysisData, state.analysisMode || 'full');
        } else {
          document.getElementById('analysis_content').innerHTML = renderCompareBlock(state.analysisCompare);
        }
      }).catch(e => alert(t('alert_export_error')));
    });
    renderHistory();
    renderConsistency();
    fetchStatus();
    fetchMetrics();
    loadTradingStatus();
    updateTradingFormState();
    initChart();
    ensureChartReady();
    setInterval(fetchStatus, 5000);
    setInterval(fetchMetrics, 2000);
    // Auto-refresh positions every 10 seconds if in realtime mode
    setInterval(() => {
      if (state.metrics && (state.metrics.mode === 'realtime' || state.metrics.mode === 'sync')) {
        fetchPositions();
      }
    }, 10000);
  </script>
</body>
</html>
