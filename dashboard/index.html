<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Resilient Trade Manager</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #05070c;
      --bg-elev: #0d1420;
      --panel: #121b2a;
      --surface-1: #121b2a;
      --surface-2: #0d1420;
      --border: rgba(97, 255, 214, 0.12);
      --border-strong: rgba(97, 255, 214, 0.28);
      --grid: rgba(79, 129, 118, 0.12);
      --text: #edfdf7;
      --muted: #9bbdb0;
      --accent: #61ffd6;
      --accent-2: #ffd479;
      --danger: #ff6b6b;
      --warning: #ffb454;
      --success: #31d488;
      --r-sm: 8px;
      --r-md: 12px;
      --r-lg: 18px;
      --sh-sm: 0 14px 34px rgba(0, 0, 0, 0.35);
      --sh-md: 0 30px 70px rgba(0, 0, 0, 0.45);
      --focus: rgba(97, 255, 214, 0.28);
      --chart-height: 460px;
      --font-sans: "Space Grotesk", "SF Pro Text", "Segoe UI", system-ui, -apple-system, sans-serif;
      --font-mono: "IBM Plex Mono", "SF Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --toolbar-pill-height: 34px;
      --toolbar-pill-padding: 0 14px;
      --toolbar-pill-border: rgba(255, 255, 255, 0.12);
      --toolbar-pill-bg: rgba(255, 255, 255, 0.04);
      --toolbar-pill-active-bg: rgba(97, 255, 214, 0.16);
      --toolbar-pill-hover-border: rgba(97, 255, 214, 0.5);
    }
    * { box-sizing: border-box; }
    body {
      font-family: var(--font-sans);
      background:
        radial-gradient(900px 500px at 12% -10%, rgba(97, 255, 214, 0.1), transparent 60%),
        radial-gradient(760px 420px at 92% -20%, rgba(255, 212, 121, 0.06), transparent 65%),
        var(--bg);
      color: var(--text);
      margin: 0;
      padding: 24px;
      letter-spacing: 0.01em;
      font-variant-numeric: tabular-nums;
      min-height: 100vh;
      position: relative;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(to right, var(--grid) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
      background-size: 48px 48px;
      opacity: 0.12;
      pointer-events: none;
      z-index: 0;
    }
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background:
        radial-gradient(680px 420px at 20% 10%, rgba(97, 255, 214, 0.06), transparent 60%),
        radial-gradient(680px 420px at 80% 15%, rgba(255, 212, 121, 0.05), transparent 60%);
      opacity: 0.45;
      pointer-events: none;
      z-index: 0;
    }
    .page {
      position: relative;
      z-index: 1;
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      gap: 20px;
    }
    .main {
      display: grid;
      gap: 20px;
    }
    h1 {
      margin: 0 0 6px;
      font-size: 30px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    h2 {
      margin: 6px 0 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
    }
    .mono {
      font-family: var(--font-mono);
    }
    .muted { color: var(--muted); }
    .note { color: var(--muted); font-size: 12px; margin: 6px 0 0; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    .row-between { justify-content: space-between; align-items: center; }
    .card {
      background: linear-gradient(160deg, rgba(18, 27, 40, 0.85), rgba(12, 19, 30, 0.92));
      border: 1px solid var(--border);
      border-radius: var(--r-md);
      padding: 16px 18px;
      box-shadow: var(--sh-sm);
      backdrop-filter: blur(12px);
    }
    .row > .card {
      flex: 1 1 180px;
      min-width: 180px;
    }
    .label {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .value { font-size: 18px; margin-top: 6px; font-weight: 600; }
    .tabs {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      padding: 12px 14px;
      background: rgba(12, 18, 28, 0.72);
      border: 1px solid rgba(97, 255, 214, 0.2);
      border-radius: var(--r-lg);
      box-shadow: var(--sh-sm);
      position: sticky;
      top: 16px;
      z-index: 5;
    }
    .tab {
      background: transparent;
      border: 1px solid transparent;
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-size: 11px;
      transition: all 180ms ease;
    }
    .tab:hover { border-color: var(--border-strong); color: var(--text); }
    .tab.active {
      background: rgba(97, 255, 214, 0.12);
      border-color: rgba(97, 255, 214, 0.35);
      color: var(--text);
      box-shadow: 0 6px 14px rgba(12, 255, 210, 0.12);
    }
    .panel {
      display: none;
      background: rgba(11, 17, 27, 0.82);
      border: 1px solid var(--border);
      border-radius: var(--r-lg);
      padding: 20px;
      box-shadow: var(--sh-sm);
      backdrop-filter: blur(14px);
      animation: panelIn 240ms ease;
    }
    .panel.active { display: grid; gap: 16px; }
    @keyframes panelIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border-bottom: 1px solid rgba(97, 255, 214, 0.1); padding: 10px 10px; font-size: 12px; }
    th {
      background: rgba(12, 18, 28, 0.82);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      position: sticky;
      top: 0;
      backdrop-filter: blur(6px);
    }
    tr:hover td { background: rgba(10, 18, 28, 0.6); }
    pre {
      background: rgba(12, 18, 28, 0.88);
      padding: 12px;
      border-radius: var(--r-md);
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.02);
      overflow: auto;
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--text);
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 8px 12px;
      background: rgba(12, 18, 28, 0.68);
      box-shadow: var(--sh-sm);
    }
    .pill .btn {
      padding: 6px 10px;
      font-size: 11px;
    }
    .pill select {
      font-size: 11px;
      padding: 6px 8px;
    }
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
    }
    .dot.ok { background: var(--success); }
    .dot.warn { background: var(--warning); }
    .dot.error { background: var(--danger); }
    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      padding: 14px;
      border-radius: var(--r-md);
      border: 1px solid rgba(97, 255, 214, 0.16);
      background: rgba(10, 16, 26, 0.65);
    }
    label {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }
    label.check {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }
    .controls label {
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      min-width: 140px;
    }
    .controls label.check {
      flex-direction: row;
      align-items: center;
      min-width: auto;
    }
    .controls label > span {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }
    .controls label.check > span {
      font-size: 12px;
      text-transform: none;
      letter-spacing: 0;
      color: var(--text);
    }
    .headerRow {
      display: grid;
      grid-template-columns: minmax(280px, 1.1fr) minmax(260px, 0.9fr);
      align-items: center;
      gap: 16px;
      padding: 18px 20px;
      border-radius: var(--r-lg);
      border: 1px solid rgba(97, 255, 214, 0.22);
      background: linear-gradient(135deg, rgba(18, 27, 40, 0.88), rgba(10, 16, 26, 0.92));
      box-shadow: var(--sh-md);
      backdrop-filter: blur(12px);
    }
    .headerLeft {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .headerRight {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .meta-pill {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 12px;
      background: rgba(11, 18, 28, 0.78);
      box-shadow: var(--sh-sm);
      font-size: 12px;
      color: var(--muted);
    }
    .meta-pill .meta-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: var(--text);
    }
    .meta-pill .label {
      font-size: 9px;
      letter-spacing: 0.14em;
    }
    .exchange-row {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .exchange-logo {
      max-height: 48px;
      max-width: 200px;
      height: auto;
      width: auto;
      object-fit: contain;
      border-radius: 8px;
      display: none;
      border: 1px solid rgba(97, 255, 214, 0.16);
      background: rgba(8, 12, 20, 0.6);
      padding: 4px 6px;
    }
    .exchange-logo.has-logo {
      display: inline-block;
    }
    input, select, button {
      background: rgba(12, 18, 28, 0.78);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--r-sm);
      padding: 8px 10px;
      transition: border-color 160ms ease, box-shadow 160ms ease, transform 120ms ease;
      font-family: var(--font-sans);
    }
    input::placeholder {
      color: rgba(138, 179, 164, 0.6);
    }
    input[type="checkbox"] {
      accent-color: var(--accent);
    }
    .field.sm {
      padding: 6px 8px;
      font-size: 11px;
    }
    .field.md {
      padding: 8px 10px;
      font-size: 12px;
    }
    .field.lg {
      padding: 10px 12px;
      font-size: 14px;
    }
    .field.invalid {
      border-color: rgba(255, 107, 107, 0.7);
      box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.25);
    }
    .symbol-select {
      min-width: 160px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    input:focus-visible, select:focus-visible, button:focus-visible {
      outline: none;
      border-color: rgba(97, 255, 214, 0.6);
      box-shadow: 0 0 0 3px var(--focus);
    }
    button {
      cursor: pointer;
      font-weight: 600;
      background: rgba(10, 16, 24, 0.9);
    }
    button:hover {
      border-color: rgba(97, 255, 214, 0.5);
      box-shadow: 0 8px 18px rgba(10, 255, 210, 0.14);
      transform: translateY(-1px);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    .btn {
      padding: 8px 12px;
      border-radius: 999px;
    }
    .btn.primary {
      background: linear-gradient(135deg, rgba(97, 255, 214, 0.25), rgba(97, 255, 214, 0.1));
      border-color: rgba(97, 255, 214, 0.6);
      color: var(--text);
    }
    .btn.ghost {
      background: transparent;
      border-color: rgba(97, 255, 214, 0.2);
      color: var(--text);
    }
    .btn.danger {
      background: rgba(255, 107, 107, 0.12);
      border-color: rgba(255, 107, 107, 0.6);
      color: var(--danger);
    }
    .btn.sm {
      padding: 6px 10px;
      font-size: 11px;
    }
    .analysis-loading {
      display: none;
      align-items: center;
      gap: 10px;
      margin-top: 12px;
      padding: 10px 14px;
      border-radius: var(--r-md);
      border: 1px solid var(--border);
      background: rgba(10, 16, 24, 0.85);
      font-size: 12px;
      color: var(--muted);
    }
    .analysis-loading.active { display: flex; }
    .analysis-loading-bar {
      width: 120px;
      height: 6px;
      border-radius: 999px;
      background: rgba(97, 255, 214, 0.12);
      position: relative;
      overflow: hidden;
    }
    .analysis-loading-bar::after {
      content: '';
      position: absolute;
      left: -30%;
      top: 0;
      height: 100%;
      width: 40%;
      background: linear-gradient(90deg, transparent, rgba(97, 255, 214, 0.8), transparent);
      animation: analysisBar 1.2s ease-in-out infinite;
    }
    .analysis-loading-gear {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(97, 255, 214, 0.6);
      border-top-color: transparent;
      animation: analysisSpin 0.9s linear infinite;
    }
    @keyframes analysisBar {
      0% { transform: translateX(0); }
      100% { transform: translateX(220%); }
    }
    @keyframes analysisSpin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .analysis-summary {
      margin-top: 16px;
      padding: 16px;
      border-radius: var(--r-lg);
      border: 1px solid var(--border);
      background: linear-gradient(150deg, rgba(18, 27, 40, 0.75), rgba(12, 18, 28, 0.85));
      box-shadow: var(--sh-sm);
      backdrop-filter: blur(10px);
    }
    .analysis-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 14px;
    }
    .analysis-summary h3 {
      margin: 0 0 10px;
      font-size: 15px;
    }
    .analysis-chart {
      margin: 10px 0 6px;
      padding: 12px;
      border-radius: var(--r-md);
      border: 1px solid var(--border);
      background: rgba(12, 18, 28, 0.7);
      position: relative;
    }
    .analysis-charts-grid {
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      margin-top: 12px;
    }
    .analysis-charts-grid.single {
      grid-template-columns: minmax(320px, 520px);
    }
    .analysis-charts-grid.focus .analysis-chart-block {
      display: none;
    }
    .analysis-charts-grid.focus .analysis-chart-block.expanded {
      display: block;
      grid-column: 1 / -1;
    }
    .analysis-chart-block.expanded .analysis-chart svg {
      height: 320px;
    }
    .analysis-chart-block h3 {
      margin: 0 0 6px;
      font-size: 14px;
    }
    .chart-zoom {
      position: absolute;
      top: 8px;
      right: 8px;
      border-radius: 999px;
      font-size: 10px;
      padding: 4px 8px;
      background: rgba(10, 16, 24, 0.85);
    }
    .analysis-chart svg {
      display: block;
      width: 100%;
      height: 180px;
    }
    .analysis-chart path {
      stroke: var(--accent);
      stroke-width: 0.9;
      stroke-linecap: round;
      stroke-linejoin: round;
      fill: none;
      vector-effect: non-scaling-stroke;
    }
    .analysis-chart .axis-line {
      stroke: rgba(255, 255, 255, 0.08);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
    }
    .analysis-chart .grid-line {
      stroke: rgba(255, 255, 255, 0.04);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
    }
    .analysis-chart .axis-text {
      fill: var(--muted);
      font-size: 4.5px;
    }
    .analysis-chart .bar {
      fill: rgba(97, 255, 214, 0.35);
    }
    .analysis-chart .series-secondary {
      stroke: var(--accent-2);
    }
    .analysis-chart .hover-line {
      stroke: rgba(255, 255, 255, 0.12);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
      opacity: 0;
    }
    .analysis-chart .hover-point {
      fill: var(--accent);
      opacity: 0;
    }
    .analysis-chart .hover-point.secondary {
      fill: var(--accent-2);
    }
    .analysis-chart .chart-tooltip {
      position: absolute;
      pointer-events: none;
      opacity: 0;
      transform: translate(-50%, -110%);
      background: rgba(8, 12, 20, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 11px;
      color: var(--text);
      white-space: nowrap;
      transition: opacity 120ms ease;
    }
    .analysis-chart .chart-title {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    .analysis-chart .chart-legend {
      position: absolute;
      left: 10px;
      top: 10px;
      display: flex;
      gap: 10px;
      font-size: 11px;
      color: var(--muted);
      background: rgba(8, 12, 20, 0.6);
      border-radius: 999px;
      padding: 2px 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .analysis-chart .legend-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .analysis-chart .legend-dot.primary {
      background: var(--accent);
    }
    .analysis-chart .legend-dot.secondary {
      background: var(--accent-2);
    }
    details.analysis-details {
      margin-top: 8px;
      border-radius: var(--r-md);
      padding: 6px 0;
    }
    details.analysis-details summary {
      cursor: pointer;
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    .analysis-list {
      margin: 0;
      padding-left: 18px;
      color: var(--text);
    }
    .analysis-list li {
      margin-bottom: 8px;
      font-size: 13px;
      line-height: 1.4;
    }
    .tooltip-cell { position: relative; }
    .tooltip-cell:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 50%;
      top: -8px;
      transform: translate(-50%, -100%);
      opacity: 0;
      animation: tooltip-fade 160ms ease forwards;
      background: rgba(8, 12, 20, 0.95);
      border: 1px solid var(--border-strong);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 8px;
      white-space: nowrap;
      font-size: 11px;
      z-index: 10;
      box-shadow: var(--sh-sm);
      pointer-events: none;
    }
    .pnl-positive { color: var(--success); }
    .pnl-negative { color: var(--danger); }
    @keyframes tooltip-fade {
      from { opacity: 0; transform: translate(-50%, -110%); }
      to { opacity: 1; transform: translate(-50%, -100%); }
    }
    .score-bar {
      margin-top: 8px;
      height: 10px;
      background: rgba(97, 255, 214, 0.12);
      border-radius: 999px;
      overflow: hidden;
      position: relative;
    }
    .score-bar::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.1), transparent);
      pointer-events: none;
    }
    .score-fill {
      height: 100%;
      width: 0%;
      transition: width 220ms ease;
      background: linear-gradient(90deg, var(--danger), rgba(255, 107, 107, 0.5));
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.25);
    }
    .modal {
      position: fixed;
      inset: 0;
      opacity: 0;
      pointer-events: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(6, 10, 16, 0.6);
      z-index: 100;
      transition: opacity 180ms ease;
    }
    .modal.active {
      display: flex;
      opacity: 1;
      pointer-events: auto;
    }
    .modal-card {
      width: min(560px, 100%);
      background: rgba(18, 27, 40, 0.9);
      border: 1px solid var(--border-strong);
      border-radius: var(--r-lg);
      padding: 16px;
      box-shadow: var(--sh-md);
      backdrop-filter: blur(14px);
      transform: translateY(12px) scale(0.98);
      transition: transform 180ms ease;
    }
    .modal.active .modal-card {
      transform: translateY(0) scale(1);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .modal-body { display: grid; gap: 10px; }
    .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 6px; flex-wrap: wrap; }
    .warning {
      border: 1px solid rgba(255, 180, 84, 0.6);
      background: rgba(255, 180, 84, 0.12);
      padding: 10px;
      border-radius: var(--r-md);
      font-size: 12px;
      color: var(--warning);
    }
    .chart-card { margin-bottom: 24px; }
    .chart-head { display: flex; justify-content: space-between; gap: 12px; align-items: center; flex-wrap: wrap; }
    .chart-controls { align-items: center; }
    .chart-toolbar {
      margin: 12px 0;
      border-radius: var(--r-lg);
      background: linear-gradient(135deg, rgba(10, 15, 22, 0.92), rgba(14, 20, 32, 0.96));
      padding: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: var(--sh-sm);
      position: relative;
      z-index: 1;
    }
    .toolbar-pill-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .toolbar-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
    }
    .toolbar-row .tf-group,
    .toolbar-row .tool-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .toolbar-row-settings {
      align-items: flex-end;
    }
    .settings-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .toolbar-dropdown {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .toolbar-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .tool-group {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .dropdown { position: relative; }
    .dropdown-toggle::after { content: "▾"; margin-left: 6px; font-size: 10px; }
    .dropdown-menu {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      min-width: 160px;
      background: #0b111a;
      border: 1px solid var(--border);
      border-radius: var(--r-md);
      padding: 8px;
      display: none;
      z-index: 5;
      box-shadow: var(--sh-sm);
    }
    .dropdown.open .dropdown-menu { display: grid; gap: 6px; }
    .check-pill { display: flex; align-items: center; gap: 8px; font-size: 12px; color: var(--text); }
    .toolbar-dropdown .dropdown-toggle {
      min-height: var(--toolbar-pill-height);
      border-radius: 999px;
      padding: var(--toolbar-pill-padding);
      border: 1px solid var(--toolbar-pill-border);
      background: var(--toolbar-pill-bg);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: border 0.2s ease, background 0.2s ease;
    }
    .chart-stream-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(15, 22, 34, 0.7);
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
      max-width: 220px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .live-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(49, 212, 136, 0.4);
      color: var(--success);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(49, 212, 136, 0.08);
      opacity: 0.6;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    .live-badge.on,
    .live-badge.active {
      opacity: 1;
      transform: none;
    }
    .tf-btn,
    .tool-btn {
      border-radius: 999px;
      min-height: var(--toolbar-pill-height);
      padding: var(--toolbar-pill-padding);
      border: 1px solid var(--toolbar-pill-border);
      background: var(--toolbar-pill-bg);
      color: var(--text);
      font-size: 11px;
      cursor: pointer;
      transition: border 0.2s ease, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .tf-btn.active,
    .tool-btn.active,
    .side-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 0 1px var(--focus);
    }
    .tool-btn.active {
      background: rgba(97, 255, 214, 0.12);
    }
    .overlay-pill-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .overlay-pill {
      position: relative;
      border-radius: 999px;
      min-height: var(--toolbar-pill-height);
      padding: var(--toolbar-pill-padding);
      border: 1px solid var(--toolbar-pill-border);
      background: var(--toolbar-pill-bg);
      color: var(--muted);
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
      transition: border 0.2s ease, background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .overlay-pill input {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }
    .overlay-pill.active,
    .overlay-pill:has(input:checked) {
      border-color: var(--accent);
      background: var(--toolbar-pill-active-bg);
      color: var(--accent);
      box-shadow: 0 0 0 1px var(--focus);
    }
    .overlay-pill input:checked + span {
      color: var(--accent);
    }
    .overlay-pill:hover {
      border-color: var(--toolbar-pill-hover-border);
    }
    .segmented {
      display: inline-flex;
      gap: 6px;
      padding: 4px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15, 22, 34, 0.8);
    }
    .segmented.small { padding: 2px; }
    .segmented .btn { border-radius: 999px; }
    .chart-note {
      margin: 2px 0 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .chart-layout {
      display: flex;
      gap: 14px;
      align-items: stretch;
    }
    .options-chart-controls {
      align-items: flex-end;
    }
    .options-chart-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--muted);
      margin: 6px 0 2px;
    }
    .options-chart-source {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(12, 18, 28, 0.7);
      color: var(--text);
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .options-chart-overlays {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 6px 0 10px;
    }
    .options-chart-layout {
      display: flex;
      gap: 16px;
      align-items: stretch;
    }
    .options-chart-main {
      flex: 1 1 auto;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .options-orderbook {
      width: 320px;
      min-width: 280px;
      background: rgba(9, 14, 22, 0.7);
      border-radius: var(--r-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .orderbook-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .orderbook-meta {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--muted);
      font-size: 11px;
    }
    .orderbook-table {
      display: grid;
      gap: 6px;
      font-size: 12px;
    }
    .orderbook-row {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      align-items: center;
      position: relative;
      padding: 4px 6px;
      border-radius: 6px;
      overflow: hidden;
    }
    .orderbook-row span {
      position: relative;
      z-index: 1;
    }
    .orderbook-row.header {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(12, 18, 28, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }
    .orderbook-row::before {
      content: "";
      position: absolute;
      inset: 0;
      width: var(--ob-fill, 0%);
      opacity: 0.5;
      pointer-events: none;
      transition: width 0.2s ease;
    }
    .orderbook-row.ask::before {
      background: rgba(255, 107, 107, 0.18);
      right: 0;
      left: auto;
    }
    .orderbook-row.bid::before {
      background: rgba(39, 208, 125, 0.18);
      left: 0;
      right: auto;
    }
    .orderbook-row.ask .ob-price { color: var(--danger); }
    .orderbook-row.bid .ob-price { color: var(--success); }
    .orderbook-mid {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 8px;
      border-radius: 6px;
      background: rgba(12, 18, 28, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-weight: 600;
      color: var(--text);
    }
    .orderbook-section {
      display: grid;
      gap: 4px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .badge.stale {
      display: none;
      border: 1px solid rgba(255, 107, 107, 0.4);
      color: #ffb3b3;
      background: rgba(255, 107, 107, 0.15);
    }
    .badge.stale.active {
      display: inline-flex;
    }
    .chart-left {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 0;
    }
    .chart-surface {
      position: relative;
      border-radius: var(--r-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background:
        radial-gradient(circle at 20% 20%, rgba(97, 255, 214, 0.12), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(255, 212, 121, 0.12), transparent 50%),
        #060b13;
      height: var(--chart-height);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }
    .options-chart-surface {
      height: 380px;
    }
    .chart-container {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    .chart-legend {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 3;
      padding: 12px 14px;
      border-radius: var(--r-md);
      background: rgba(9, 13, 20, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: var(--sh-sm);
      backdrop-filter: blur(10px);
      min-width: 220px;
      font-size: 12px;
      line-height: 1.3;
      pointer-events: none;
    }
    .chart-legend .legend-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: space-between;
    }
    .chart-legend .legend-label {
      color: var(--muted);
      letter-spacing: 0.04em;
      font-size: 11px;
    }
    .chart-legend .legend-time {
      flex: 1;
      font-size: 11px;
    }
    .chart-legend .legend-value {
      font-weight: 600;
    }
    .chart-legend .legend-value.value-positive {
      color: var(--success);
    }
    .chart-legend .legend-value.value-negative {
      color: var(--danger);
    }
    .chart-drawings {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 2;
    }
    .chart-bottom {
      margin-top: 18px;
      display: flex;
      gap: 18px;
      flex-wrap: wrap;
      align-items: stretch;
    }
    .trade-panel {
      flex: 1 1 540px;
      background: linear-gradient(145deg, rgba(16, 22, 34, 0.95), rgba(8, 11, 18, 0.95));
      border-radius: var(--r-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 18px;
      display: grid;
      gap: 12px;
      box-shadow: var(--sh-sm);
    }
    .trade-panel-head {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .trade-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .quick-panel {
      align-items: center;
      gap: 10px;
    }
    .panel-title { font-size: 12px; text-transform: uppercase; letter-spacing: 0.12em; color: var(--muted); }
    .field-group { display: grid; gap: 6px; font-size: 11px; color: var(--muted); }
    .switch { display: inline-flex; align-items: center; gap: 8px; font-size: 12px; color: var(--muted); }
    .switch input { display: none; }
    .switch .slider {
      width: 36px; height: 20px; border-radius: 999px; border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.08); position: relative; transition: background 0.2s ease;
    }
    .switch .slider::after {
      content: ""; width: 14px; height: 14px; border-radius: 50%; background: var(--text);
      position: absolute; top: 2px; left: 2px; transition: transform 0.2s ease;
    }
    .switch input:checked + .slider { background: rgba(97, 255, 214, 0.3); }
    .switch input:checked + .slider::after { transform: translateX(16px); }
    .trade-advanced {
      border-radius: var(--r-md);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 22, 34, 0.6);
      padding: 8px 10px;
    }
    .trade-advanced summary {
      cursor: pointer;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      list-style: none;
    }
    .trade-advanced summary::-webkit-details-marker {
      display: none;
    }
    .trade-advanced .row {
      margin-top: 8px;
    }
    .price-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .is-hidden {
      display: none !important;
    }
    .chart-drawings.active {
      pointer-events: auto;
      cursor: crosshair;
    }
    .chart-drawing-rect {
      fill: rgba(97, 255, 214, 0.08);
      stroke: rgba(97, 255, 214, 0.7);
      stroke-width: 1.4;
    }
    .qr {
      width: 140px;
      height: 140px;
      border-radius: var(--r-md);
      border: 1px solid var(--border);
      background: rgba(9, 14, 22, 0.6);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }
    .donate-card {
      min-width: 240px;
    }
    .qr-wrap {
      margin-top: 8px;
    }
    .wallet-address {
      margin-top: 8px;
      word-break: break-all;
    }
    .engraved-row {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 8px 0;
      border-top: 1px solid rgba(97, 255, 214, 0.12);
    }
    .engraved-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: rgba(214, 225, 240, 0.45);
    }
    .engraved-icon {
      width: 14px;
      height: 14px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.6;
    }
    .engraved-link {
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(231, 237, 247, 0.55);
      text-decoration: none;
      text-shadow:
        0 1px 1px rgba(0, 0, 0, 0.6),
        0 -1px 0 rgba(255, 255, 255, 0.04);
    }
    @media (max-width: 1024px) {
      .chart-surface { height: 360px; }
      .chart-layout { flex-direction: column; }
      .chart-bottom { flex-direction: column; }
      .options-chart-layout { flex-direction: column; }
      .options-orderbook { width: 100%; }
      .options-chart-surface { height: 320px; }
    }
    .chart-trade {
      position: absolute;
      top: 16px;
      left: 16px;
      z-index: 10;
      width: 220px;
      background: rgba(11, 16, 24, 0.86);
      border: 1px solid var(--border-strong);
      border-radius: var(--r-lg);
      padding: 12px;
      box-shadow: var(--sh-sm);
      backdrop-filter: blur(10px);
      display: grid;
      gap: 10px;
    }
    .trade-title {
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(214, 225, 240, 0.65);
    }
    .trade-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .trade-actions button.buy {
      background: linear-gradient(135deg, rgba(49, 212, 136, 0.22), rgba(49, 212, 136, 0.12));
      border-color: rgba(49, 212, 136, 0.6);
      color: var(--text);
    }
    .trade-actions button.sell {
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.25), rgba(255, 123, 123, 0.12));
      border-color: rgba(255, 107, 107, 0.6);
      color: var(--text);
    }
    .height-control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .height-control input[type="range"] {
      accent-color: var(--accent);
      min-width: 140px;
    }
    .site-footer {
      margin-top: 8px;
      padding: 14px 0;
      border-top: 1px solid rgba(97, 255, 214, 0.12);
      background: rgba(11, 17, 27, 0.7);
      border-radius: var(--r-lg);
    }
    .footer-grid {
      display: grid;
      grid-template-columns: minmax(260px, 1fr) auto minmax(260px, 1fr);
      gap: 18px;
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 18px;
      font-size: 12px;
      align-items: center;
    }
    .footer-title {
      font-weight: 600;
      color: var(--text);
      margin-bottom: 6px;
    }
    .footer-text {
      color: var(--muted);
      margin-bottom: 6px;
    }
    .footer-center {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .footer-links {
      display: grid;
      gap: 8px;
      justify-content: flex-end;
    }
    .footer-grid > div:first-child {
      text-align: left;
    }
    .footer-grid > div:last-child {
      text-align: right;
    }
    .social-pill {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 12px;
      background: rgba(10, 16, 24, 0.86);
      box-shadow: var(--sh-sm);
    }
    .pill-link {
      color: var(--text);
      text-decoration: none;
      font-size: 12px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid transparent;
    }
    .pill-link:hover {
      border-color: rgba(97, 255, 214, 0.5);
    }
    .pill-link img {
      width: 16px;
      height: 16px;
      object-fit: contain;
      display: block;
    }
    .footer-link-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      color: var(--muted);
    }
    .footer-link {
      color: var(--accent);
      text-decoration: none;
      font-weight: 600;
    }
    @media (max-width: 1100px) {
      .headerRow {
        grid-template-columns: 1fr;
        justify-items: flex-start;
      }
      .headerRight {
        justify-content: flex-start;
      }
      .tabs {
        position: static;
      }
    }
    @media (max-width: 900px) {
      body {
        padding: 18px;
      }
      .chart-toolbar {
        padding: 10px;
      }
      .toolbar-row {
        align-items: flex-start;
      }
      .toolbar-actions {
        width: 100%;
        justify-content: flex-start;
      }
      .settings-group {
        width: 100%;
      }
      .footer-grid {
        grid-template-columns: 1fr;
        text-align: left;
      }
      .footer-grid > div:last-child {
        text-align: left;
      }
      .footer-links {
        justify-content: flex-start;
      }
    }
    @media (max-width: 700px) {
      h1 { font-size: 24px; }
      .tabs .tab {
        font-size: 10px;
        padding: 6px 10px;
      }
      .controls {
        padding: 10px;
      }
      .row > .card {
        min-width: 160px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
  <header class="headerRow">
    <div class="headerLeft">
      <div>
        <h1 id="title_text">Resilient Trade Manager</h1>
        <div class="muted" id="subtitle">Trade Monitoring and Analytics</div>
      </div>
      <img id="exchange_logo" class="exchange-logo" alt="exchange">
    </div>
    <div class="headerRight">
      <div class="meta-pill">
        <span class="label" data-i18n="label_product">Product</span>
        <span class="meta-item" id="product_name">-</span>
        <span class="label" data-i18n="label_exchange">Exchange</span>
        <span class="meta-item exchange-row">
          <span id="exchange_name">-</span>
        </span>
      </div>
      <div class="pill">
        <select id="lang_select">
          <option value="en">EN</option>
          <option value="zh">中文</option>
        </select>
        <button id="open_trading_modal" class="btn primary" data-i18n="button_enable_trading">Enable Trading</button>
        <span id="status_dot" class="dot"></span>
        <span id="status_text">Waiting for product...</span>
      </div>
    </div>
  </header>

  <nav class="tabs">
    <button class="tab active" data-tab="overview" data-i18n="tab_overview">Overview</button>
    <button class="tab" data-tab="analysis" data-i18n="tab_analysis">Analysis</button>
    <button class="tab" data-tab="advanced-analysis" data-i18n="tab_advanced_analysis">Advanced Analysis</button>
    <button class="tab" data-tab="chart" data-i18n="tab_chart">Chart</button>
    <button class="tab" data-tab="options-chart" data-i18n="tab_options_chart">Options Chart</button>
    <button class="tab" data-tab="positions" data-i18n="tab_positions">Positions</button>
    <button class="tab" data-tab="resilient-maker" data-i18n="tab_resilient_maker">Resilient Maker</button>
    <button class="tab" data-tab="other-products" data-i18n="tab_other_products">Other Products</button>
    <button class="tab" data-tab="about" data-i18n="tab_about">About</button>
  </nav>

  <main class="main">
  <div id="panel-overview" class="panel active">
    <h2 data-i18n="heading_trade_consistency">Trade Consistency</h2>
    <div class="row">
      <div class="card">
        <div class="label" data-i18n="label_consistency_score">Consistency Score</div>
        <div class="value" id="consistency_score">-</div>
        <div class="score-bar"><div id="consistency_fill" class="score-fill"></div></div>
      </div>
      <div class="card"><div class="label" data-i18n="label_avg_interval">Avg Interval (s)</div><div class="value" id="avg_interval">-</div></div>
      <div class="card"><div class="label" data-i18n="label_interval_std">Interval Std (s)</div><div class="value" id="std_interval">-</div></div>
      <div class="card"><div class="label" data-i18n="label_buy_sell">Buy / Sell</div><div class="value" id="buy_sell_ratio">-</div></div>
      <div class="card"><div class="label" data-i18n="label_trades_per_hour">Trades / Hour</div><div class="value" id="trades_per_hour">-</div></div>
      <div class="card"><div class="label" data-i18n="label_logged_trades">Logged Trades</div><div class="value" id="logged_trades">-</div></div>
    </div>

    <h2 data-i18n="heading_trade_history">Trade History (Logged)</h2>
    <div class="controls">
      <label><span data-i18n="label_symbol">Symbol</span>
        <select id="filter_symbol" class="symbol-select">
          <option value="" data-i18n="all">ALL</option>
        </select>
      </label>
      <label><span data-i18n="label_side">Side</span>
        <select id="filter_side">
          <option value="" data-i18n="all">ALL</option>
          <option value="Buy" data-i18n="side_buy">Buy</option>
          <option value="Sell" data-i18n="side_sell">Sell</option>
        </select>
      </label>
      <label><span data-i18n="label_start_date">Start</span>
        <input id="filter_start" type="date">
      </label>
      <label><span data-i18n="label_end_date">End</span>
        <input id="filter_end" type="date">
      </label>
      <label><span data-i18n="label_min_qty">Min Qty</span>
        <input id="filter_min_qty" type="number" step="0.0001" value="0">
      </label>
      <label><span data-i18n="label_max_rows">Max Rows</span>
        <input id="filter_max_rows" type="number" min="1" max="2000" value="200">
      </label>
      <button id="apply_filters" data-i18n="button_apply">Apply</button>
      <button id="export_history" data-i18n="button_export_history">Export History</button>
      <button id="clear_history" data-i18n="button_clear_log">Clear Local Log</button>
    </div>

    <table id="fills_table">
      <thead>
        <tr>
          <th data-i18n="th_time">Time</th>
          <th data-i18n="th_symbol">Symbol</th>
          <th data-i18n="th_side">Side</th>
          <th data-i18n="th_qty">Qty</th>
          <th data-i18n="th_price">Price</th>
          <th data-i18n="th_notional">Notional</th>
          <th data-i18n="th_fee">Fee</th>
          <th data-i18n="th_tp">TP</th>
          <th data-i18n="th_order_id">Order ID</th>
        </tr>
      </thead>
      <tbody id="fills_body"></tbody>
    </table>
  </div>

  <div id="panel-resilient-maker" class="panel">
    <h2 data-i18n="heading_rm_snapshot">Resilient Maker Snapshot</h2>
    <div class="row">
      <div class="card"><div class="label" data-i18n="label_inventory">Inventory</div><div class="value" id="rm_inventory">-</div></div>
      <div class="card"><div class="label" data-i18n="label_session_pnl">Session PnL</div><div class="value" id="rm_session_pnl">-</div></div>
      <div class="card"><div class="label" data-i18n="label_realized_pnl">Realized PnL</div><div class="value" id="rm_realized_pnl">-</div></div>
      <div class="card"><div class="label" data-i18n="label_unrealized_pnl">Unrealized PnL</div><div class="value" id="rm_unrealized_pnl">-</div></div>
      <div class="card"><div class="label" data-i18n="label_fee_total">Fee Total</div><div class="value" id="rm_fee_total">-</div></div>
      <div class="card"><div class="label" data-i18n="label_funding_total">Funding Total</div><div class="value" id="rm_funding_total">-</div></div>
    </div>
    <h2 data-i18n="heading_glft_status">GLFT Status</h2>
    <pre id="rm_glft">{}</pre>
  </div>

  <div id="panel-analysis" class="panel">
    <h2 data-i18n="heading_advanced_analytics">Analysis</h2>
    <div class="controls">
      <label><span data-i18n="label_analysis_mode">Analysis Mode</span>
        <select id="analysis_mode">
          <option value="full" data-i18n="analysis_full">Full Analysis</option>
          <option value="performance" data-i18n="analysis_performance">Performance Metrics</option>
          <option value="risk" data-i18n="analysis_risk">Risk Metrics</option>
          <option value="maker_taker" data-i18n="analysis_maker_taker">Maker/Taker Breakdown</option>
        </select>
      </label>
      <label><span data-i18n="label_symbol">Symbol</span>
        <select id="analysis_symbol" class="symbol-select">
          <option value="" data-i18n="all">ALL</option>
        </select>
      </label>
      <label><span data-i18n="label_timeframe">Timeframe</span>
        <select id="analysis_timeframe">
          <option value="1" data-i18n="tf_1d">1 Day</option>
          <option value="7" selected data-i18n="tf_7d">7 Days</option>
          <option value="14" data-i18n="tf_14d">14 Days</option>
          <option value="30" data-i18n="tf_30d">30 Days</option>
          <option value="60" data-i18n="tf_60d">60 Days</option>
          <option value="90" data-i18n="tf_90d">90 Days</option>
          <option value="180" data-i18n="tf_180d">180 Days</option>
          <option value="365" data-i18n="tf_365d">365 Days</option>
        </select>
      </label>
      <label class="check">
        <input id="analysis_use_range" type="checkbox">
        <span data-i18n="label_use_date_range">Use Date Range</span>
      </label>
      <label><span data-i18n="label_start_date">Start</span>
        <input id="analysis_start" type="date">
      </label>
      <label><span data-i18n="label_end_date">End</span>
        <input id="analysis_end" type="date">
      </label>
      <label><span data-i18n="label_options_greeks">Options Greeks</span>
        <select id="options_greeks_source">
          <option value="bs" data-i18n="options_greeks_model">Model (BS)</option>
          <option value="bybit" data-i18n="options_greeks_bybit">Bybit Greeks</option>
        </select>
      </label>
      <label><span data-i18n="label_options_symbol">Options Symbol</span>
        <select id="options_symbol">
          <option value="BTCUSDT">BTCUSDT</option>
          <option value="ETHUSDT">ETHUSDT</option>
        </select>
      </label>
      <button id="refresh_analysis" data-i18n="button_refresh_analysis">Generate Analysis</button>
      <button id="export_analysis" data-i18n="button_export_analysis">Export Analysis</button>
      <button id="export_analysis_fills" data-i18n="button_export_fills">Export Fills</button>
      <button id="export_order_history" data-i18n="button_export_orders">Export Orders</button>
      <button id="compare_sources" data-i18n="button_compare_sources">Compare Sources</button>
      <button id="options_use_bybit" data-i18n="button_options_use_bybit">Use Bybit Greeks</button>
    </div>
    <div id="analysis_loading" class="analysis-loading">
      <div class="analysis-loading-bar"></div>
      <div class="analysis-loading-gear"></div>
      <span data-i18n="analysis_generating">Generating analysis...</span>
    </div>
    
    <div id="analysis_content">
      <div class="muted" data-i18n="analysis_hint">Click "Generate Analysis" to load comprehensive trade analysis.</div>
    </div>
  </div>

  <div id="panel-advanced-analysis" class="panel">
    <h2 data-i18n="heading_advanced_analysis">Advanced Analysis</h2>
    <div class="controls">
      <label><span data-i18n="label_symbol">Symbol</span>
        <select id="advanced_symbol" class="symbol-select">
          <option value="" data-i18n="all">ALL</option>
        </select>
      </label>
      <label><span data-i18n="label_timeframe">Timeframe</span>
        <select id="advanced_timeframe">
          <option value="1" data-i18n="tf_1d">1 Day</option>
          <option value="7" selected data-i18n="tf_7d">7 Days</option>
          <option value="14" data-i18n="tf_14d">14 Days</option>
          <option value="30" data-i18n="tf_30d">30 Days</option>
          <option value="60" data-i18n="tf_60d">60 Days</option>
          <option value="90" data-i18n="tf_90d">90 Days</option>
          <option value="180" data-i18n="tf_180d">180 Days</option>
          <option value="365" data-i18n="tf_365d">365 Days</option>
        </select>
      </label>
      <label class="check">
        <input id="advanced_use_range" type="checkbox">
        <span data-i18n="label_use_date_range">Use Date Range</span>
      </label>
      <label><span data-i18n="label_start_date">Start</span>
        <input id="advanced_start" type="date">
      </label>
      <label><span data-i18n="label_end_date">End</span>
        <input id="advanced_end" type="date">
      </label>
      <button id="generate_advanced" data-i18n="button_generate_advanced">Generate Advanced Analysis</button>
    </div>
    <div id="advanced_loading" class="analysis-loading">
      <div class="analysis-loading-bar"></div>
      <div class="analysis-loading-gear"></div>
      <span data-i18n="advanced_generating">Generating advanced analysis...</span>
    </div>
    <div id="advanced_content">
      <div class="muted" data-i18n="advanced_analysis_hint">Click "Generate Advanced Analysis" to explore time-based performance.</div>
    </div>
  </div>


  <div id="panel-chart" class="panel">
    <section class="card chart-card">
      <div class="card-head chart-head">
        <div>
          <h2 data-i18n="heading_chart">Chart</h2>
        </div>
        <div class="row chart-controls">
          <label class="field-group"><span data-i18n="label_symbol">Symbol</span>
            <select id="chart_symbol" class="symbol-select field sm">
              <option value="" data-i18n="all">ALL</option>
            </select>
          </label>
          <label class="field-group"><span data-i18n="label_custom_symbol">Search</span>
            <input id="chart_custom_symbol" type="text" placeholder="e.g. BTCUSDT" class="field sm">
          </label>
          <button id="chart_add_symbol" class="btn ghost sm" data-i18n="button_add_symbol">Add</button>
        </div>
      </div>

      <div class="chart-toolbar">
        <div class="toolbar-pill-group">
          <div class="toolbar-row toolbar-row-timeframes">
            <div class="tf-group">
              <button class="btn ghost sm tf-btn" data-interval="tick">tick</button>
              <button class="btn ghost sm tf-btn" data-interval="1s">1s</button>
              <button class="btn ghost sm tf-btn" data-interval="5s">5s</button>
              <button class="btn ghost sm tf-btn" data-interval="1">1m</button>
              <button class="btn ghost sm tf-btn" data-interval="3">3m</button>
              <button class="btn ghost sm tf-btn" data-interval="5">5m</button>
              <button class="btn ghost sm tf-btn" data-interval="15">15m</button>
              <button class="btn ghost sm tf-btn" data-interval="30">30m</button>
              <button class="btn ghost sm tf-btn" data-interval="60">1h</button>
              <button class="btn ghost sm tf-btn" data-interval="120">2h</button>
              <button class="btn ghost sm tf-btn" data-interval="240">4h</button>
              <button class="btn ghost sm tf-btn" data-interval="D">1D</button>
            </div>
            <div class="toolbar-dropdown dropdown indicator-dropdown" id="chart_indicator_dropdown">
              <button class="btn ghost sm dropdown-toggle indicator-toggle" type="button">Indicators</button>
              <div class="dropdown-menu">
                <label class="check-pill">
                  <input type="checkbox" id="chart_ind_ma">
                  <span>MA 20</span>
                </label>
                <label class="check-pill">
                  <input type="checkbox" id="chart_ind_ema">
                  <span>EMA 20</span>
                </label>
                <label class="check-pill">
                  <input type="checkbox" id="chart_ind_vwap">
                  <span>VWAP</span>
                </label>
              </div>
            </div>
          </div>
          <div class="toolbar-row toolbar-row-tools">
            <div class="tool-group">
              <button class="btn ghost sm tool-btn active" data-tool="cursor">Cursor</button>
              <button class="btn ghost sm tool-btn" data-tool="crosshair">Crosshair</button>
              <button class="btn ghost sm tool-btn" data-tool="hline">H-Line</button>
              <button class="btn ghost sm tool-btn" data-tool="rect">Rectangle</button>
            </div>
            <div class="toolbar-actions">
              <div class="live-badge" id="chart_live_badge">LIVE</div>
              <div class="chart-stream-status" id="chart_status" data-i18n="chart_hint">Select a symbol to load klines.</div>
            </div>
          </div>
          <div class="toolbar-row toolbar-row-overlays">
            <div class="overlay-pill-group">
              <label class="overlay-pill">
                <input type="checkbox" id="chart_show_orders" checked>
                <span data-i18n="label_active_orders">Orders</span>
              </label>
              <label class="overlay-pill">
                <input type="checkbox" id="chart_show_trades" checked>
                <span data-i18n="label_trades">Trades</span>
              </label>
              <label class="overlay-pill">
                <input type="checkbox" id="chart_show_breakeven" checked>
                <span data-i18n="label_breakeven">BE</span>
              </label>
              <label class="overlay-pill">
                <input type="checkbox" id="chart_show_liq" checked>
                <span data-i18n="label_liquidation">Liq</span>
              </label>
            </div>
            <div class="segmented" id="chart_side_toggle">
              <button class="btn sm side-btn active" data-side="Buy" id="chart_side_buy">Buy</button>
              <button class="btn sm side-btn" data-side="Sell" id="chart_side_sell">Sell</button>
            </div>
          </div>
          <div class="toolbar-row toolbar-row-settings">
            <div class="settings-group">
              <label class="field-group"><span data-i18n="label_interval">Interval</span>
                <select id="chart_interval" class="field sm is-hidden">
                  <option value="tick">Tick</option>
                  <option value="1s">1s</option>
                  <option value="5s">5s</option>
                  <option value="1">1m</option>
                  <option value="3">3m</option>
                  <option value="5">5m</option>
                  <option value="15">15m</option>
                  <option value="30">30m</option>
                  <option value="60">1h</option>
                  <option value="120">2h</option>
                  <option value="240">4h</option>
                  <option value="D">1D</option>
                </select>
              </label>
              <label class="field-group"><span data-i18n="label_refresh_ms">Refresh (ms)</span>
                <select id="chart_refresh" class="field sm">
                  <option value="250">250</option>
                  <option value="500">500</option>
                  <option value="1000">1000</option>
                  <option value="2000" selected>2000</option>
                  <option value="5000">5000</option>
                  <option value="10000">10000</option>
                  <option value="15000">15000</option>
                </select>
              </label>
              <label class="switch">
                <input id="chart_auto" type="checkbox" checked>
                <span class="slider"></span>
                <span class="label" data-i18n="label_auto_refresh">Auto Refresh</span>
              </label>
              <label class="field-group height-control">
                <span data-i18n="label_chart_height">Height</span>
                <input id="chart_height" type="range" min="320" max="720" step="20" value="460">
                <span id="chart_height_value">460px</span>
              </label>
            </div>
            <div class="tool-group">
              <button id="chart_reload" class="btn ghost sm" data-i18n="button_reload">Reload</button>
              <button id="chart_draw_box" class="btn ghost sm">Draw Box</button>
              <button id="chart_clear_drawings" class="btn ghost sm">Clear Drawings</button>
            </div>
          </div>
        </div>
      </div>

      <div class="chart-note muted" id="chart_note"></div>

      <div class="chart-layout">
        <div class="chart-left">
          <div class="chart-surface">
            <div class="chart-legend" id="chartLegend"></div>
            <div class="chart-container" id="chart_container"></div>
            <svg id="chart_drawings" class="chart-drawings" width="100%" height="100%"></svg>
          </div>

          <div class="chart-bottom">
            <div class="trade-panel">
              <div class="trade-panel-head">
                <div class="panel-title" data-i18n="trade_panel_title">Chart Trading</div>
              </div>
              <div class="row">
                <label class="field-group"><span data-i18n="label_qty">Qty</span>
                  <input id="chart_order_qty" type="number" min="0" step="0.0001" value="0" class="field sm">
                </label>
                <label class="field-group"><span data-i18n="label_order_type">Order Type</span>
                  <select id="chart_order_mode" class="field sm">
                    <option value="market" data-i18n="order_mode_market">Market</option>
                    <option value="best" data-i18n="order_mode_best">Best Bid/Offer</option>
                    <option value="chase" data-i18n="order_mode_chase">Chase Limit</option>
                    <option value="limit" data-i18n="order_mode_limit">Limit</option>
                  </select>
                </label>
                <label class="field-group" id="chart_price_row"><span data-i18n="label_price">Price</span>
                  <input id="chart_order_price" type="number" min="0" step="0.01" value="" class="field sm">
                </label>
                <label class="switch">
                  <input id="chart_reduce_only" type="checkbox">
                  <span class="slider"></span>
                  <span class="label" data-i18n="label_reduce_only">Reduce Only</span>
                </label>
              </div>
              <div class="row quick-panel">
                <label class="field-group"><span>Quick Qty</span>
                  <input id="quickQtyMax" type="number" min="0" step="0.0001" class="field sm" placeholder="Max">
                </label>
                <div class="segmented small" id="quickQtyPresets">
                  <button class="btn sm ghost" data-pct="25">25%</button>
                  <button class="btn sm ghost" data-pct="50">50%</button>
                  <button class="btn sm ghost" data-pct="75">75%</button>
                  <button class="btn sm ghost" data-pct="100">100%</button>
                </div>
                <button id="quickBuy" class="btn primary sm">Buy MKT</button>
                <button id="quickSell" class="btn danger sm">Sell MKT</button>
              </div>
              <div class="row">
                <label class="field-group"><span>BE Price</span>
                  <input id="bePriceInput" type="number" min="0" step="0.01" class="field sm" placeholder="Break-even">
                </label>
                <label class="field-group"><span>Liq Price</span>
                  <input id="liqPriceInput" type="number" min="0" step="0.01" class="field sm" placeholder="Liquidation">
                </label>
              </div>
              <div class="trade-actions">
                <button class="buy" id="chart_buy" data-i18n="button_buy">Buy</button>
                <button class="sell" id="chart_sell" data-i18n="button_sell">Sell</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div id="panel-options-chart" class="panel">
    <section class="card options-chart-card">
      <div class="card-head">
        <div>
          <h2 data-i18n="heading_options_chart">Options Chart</h2>
        </div>
        <div class="row options-chart-controls">
          <label class="field-group"><span data-i18n="label_options_symbol">Options Symbol</span>
            <select id="options_chart_symbol" class="field sm"></select>
          </label>
          <label class="field-group"><span data-i18n="label_expiry">Expiry</span>
            <select id="options_chart_expiry" class="field sm"></select>
          </label>
          <label class="field-group"><span data-i18n="label_option_type">Call/Put</span>
            <select id="options_chart_type" class="field sm"></select>
          </label>
          <label class="field-group"><span data-i18n="label_interval">Interval</span>
            <select id="options_chart_interval" class="field sm">
              <option value="1">1m</option>
              <option value="3">3m</option>
              <option value="5">5m</option>
              <option value="15" selected>15m</option>
              <option value="30">30m</option>
              <option value="60">1h</option>
              <option value="120">2h</option>
              <option value="240">4h</option>
              <option value="D">1D</option>
            </select>
          </label>
          <label class="switch">
            <input id="options_chart_auto" type="checkbox" checked>
            <span class="slider"></span>
            <span class="label" data-i18n="label_auto_refresh">Auto Refresh</span>
          </label>
          <label class="field-group"><span data-i18n="label_refresh_ms">Refresh (ms)</span>
            <select id="options_chart_refresh" class="field sm">
              <option value="2000" selected>2000</option>
              <option value="5000">5000</option>
              <option value="10000">10000</option>
              <option value="15000">15000</option>
            </select>
          </label>
          <button id="options_chart_reload" class="btn ghost sm" data-i18n="button_reload">Reload</button>
        </div>
      </div>
      <div class="chart-note muted" id="options_chart_note" data-i18n="options_chart_hint">Select an options contract to load trade-derived candles. IV/greeks use snapshots.</div>
      <div class="options-chart-meta">
        <span class="options-chart-source" id="options_chart_source_label">Charting : Bybit · Orderbook : Bybit</span>
        <span class="options-chart-asof">As of <span id="options_chart_asof">--</span></span>
        <span class="badge stale" id="options_chart_stale">STALE</span>
      </div>
      <div class="options-chart-overlays">
        <label class="overlay-pill">
          <input type="checkbox" id="options_show_iv">
          <span>IV</span>
        </label>
        <label class="overlay-pill">
          <input type="checkbox" id="options_show_delta">
          <span>Delta</span>
        </label>
        <label class="overlay-pill">
          <input type="checkbox" id="options_show_vega">
          <span>Vega</span>
        </label>
      </div>
      <div class="options-chart-layout">
        <div class="options-chart-main">
          <div class="chart-surface options-chart-surface">
            <div class="chart-legend" id="optionsChartLegend"></div>
            <div class="chart-container" id="options_chart_container"></div>
          </div>
        </div>
        <aside class="options-orderbook">
          <div class="orderbook-head">
            <div class="panel-title" data-i18n="heading_options_orderbook">Options Orderbook</div>
            <div class="orderbook-meta">
              <span class="orderbook-asof">As of <span id="options_orderbook_asof">--</span></span>
              <span class="badge stale" id="options_orderbook_stale">STALE</span>
            </div>
          </div>
          <div class="orderbook-table">
            <div class="orderbook-row header">
              <span data-i18n="label_price">Price</span>
              <span data-i18n="label_qty">Size</span>
              <span data-i18n="label_total">Total</span>
            </div>
            <div id="options_orderbook_asks" class="orderbook-section"></div>
            <div class="orderbook-mid" id="options_orderbook_mid">--</div>
            <div id="options_orderbook_bids" class="orderbook-section"></div>
          </div>
        </aside>
      </div>
    </section>
  </div>

  <div id="panel-positions" class="panel">
    <h2 data-i18n="heading_current_positions">Current Positions</h2>
    <div class="controls">
      <button id="refresh_positions" data-i18n="button_fetch_positions">Fetch Current Positions</button>
    </div>
    <div id="positions_content">
      <div class="muted" data-i18n="positions_hint">Click "Refresh Positions" to load current positions.</div>
    </div>

    <h2 data-i18n="heading_active_orders">Active Orders</h2>
    <div class="controls">
      <button id="refresh_orders" data-i18n="button_fetch_orders">Fetch Active Orders</button>
    </div>
    <div id="orders_content">
      <div class="muted" data-i18n="orders_hint">Fetch active orders (API credentials required).</div>
    </div>
  </div>

  <div id="position_modal" class="modal">
    <div class="modal-card">
      <div class="modal-header">
        <h2 data-i18n="position_modal_title">Position Controls</h2>
        <button id="close_position_modal" data-i18n="button_close">Close</button>
      </div>
      <div class="modal-body">
        <div class="row">
          <div class="card"><div class="label" data-i18n="label_symbol">Symbol</div><div class="value" id="position_modal_symbol">-</div></div>
          <div class="card"><div class="label" data-i18n="label_side">Side</div><div class="value" id="position_modal_side">-</div></div>
          <div class="card"><div class="label" data-i18n="label_qty">Qty</div><div class="value" id="position_modal_qty">-</div></div>
        </div>
        <label><span data-i18n="label_take_profit">Take Profit</span>
          <input id="position_tp" type="number" min="0" step="0.01" value="">
        </label>
        <label><span data-i18n="label_stop_loss">Stop Loss</span>
          <input id="position_sl" type="number" min="0" step="0.01" value="">
        </label>
      </div>
      <div class="modal-actions">
        <button id="position_set_tpsl" data-i18n="button_set_tpsl">Set TP/SL</button>
        <button id="position_smart_tp" data-i18n="button_smart_tp">Smart TP</button>
        <button id="position_smart_sl" data-i18n="button_smart_sl">Smart SL</button>
        <button id="position_close" data-i18n="button_close_position">Close Position</button>
      </div>
    </div>
  </div>

  <div id="panel-other-products" class="panel">
    <h2 data-i18n="heading_other_products">Other Products</h2>
    <div class="muted" data-i18n="other_products_hint">No additional products detected. Future modules will appear here automatically.</div>
  </div>

  <div id="panel-about" class="panel">
    <h2 data-i18n="heading_about">About</h2>
  </div>
  </main>

  <footer class="site-footer">
    <div class="footer-grid">
      <div>
        <div class="footer-title" data-i18n="about_credit">This Trade Manager is powered by Resilient Lab 505.</div>
        <div class="footer-text" data-i18n="about_contact">Business contact: contact@resilientlab505.com</div>
        <div class="footer-text" data-i18n="about_trademark_notice">Logos are trademarks of their respective owners.</div>
      </div>
      <div class="footer-center">
        <div class="social-pill">
          <a class="pill-link" href="javascript:void(0)" id="open_donate" title="Donate">
            <img src="/assets/social/donate_dark.svg" alt="Donate">
          </a>
          <a class="pill-link" href="https://www.youtube.com/@resilientlab505" target="_blank" rel="noreferrer" title="YouTube">
            <img src="/assets/social/youtube_logo_dark.svg" alt="YouTube">
          </a>
          <a class="pill-link" href="https://x.com/resilientlab505" target="_blank" rel="noreferrer" title="X">
            <img src="/assets/social/x_logo_dark.svg" alt="X">
          </a>
          <a class="pill-link" href="https://t.me/resilientlab505" target="_blank" rel="noreferrer" title="Telegram">
            <img src="/assets/social/tele_logo_dark.svg" alt="Telegram">
          </a>
          <a class="pill-link" href="https://www.resilientlab505.com" target="_blank" rel="noreferrer" title="Website">
            <img src="/assets/social/globe_logo_dark.svg" alt="Website">
          </a>
        </div>
      </div>
      <div class="footer-links">
        <div class="footer-link-row">
          <span data-i18n="about_youtube_label">YouTube</span>
          <a class="footer-link" href="https://www.youtube.com/@resilientlab505" target="_blank" rel="noreferrer">youtube.com/@resilientlab505</a>
        </div>
        <div class="footer-link-row">
          <span>X</span>
          <a class="footer-link" href="https://x.com/resilientlab505" target="_blank" rel="noreferrer">x.com/resilientlab505</a>
        </div>
        <div class="footer-link-row">
          <span data-i18n="about_telegram_label">Telegram</span>
          <a class="footer-link" href="https://t.me/resilientlab505" target="_blank" rel="noreferrer">@resilientlab505</a>
        </div>
        <div class="footer-link-row">
          <span data-i18n="about_website_label">Website</span>
          <a class="footer-link" href="https://www.resilientlab505.com" target="_blank" rel="noreferrer">www.resilientlab505.com</a>
        </div>
      </div>
    </div>
  </footer>
  </div>

  <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>

  <div id="trading_modal" class="modal">
    <div class="modal-card">
      <div class="modal-header">
        <h2 data-i18n="heading_enable_trading">Enable Trading</h2>
        <button id="close_trading_modal" data-i18n="button_close">Close</button>
      </div>
      <div class="modal-body">
        <div class="warning" data-i18n="trading_warning">
          Trading via API carries risk. Use restricted keys, avoid high leverage, and keep funds separated. Keys are stored in server memory for this session only.
        </div>
        <label class="check">
          <input id="trade_ack" type="checkbox">
          <span data-i18n="trading_ack">I understand the risks and want to continue.</span>
        </label>
        <label class="check">
          <input id="trade_use_env" type="checkbox">
          <span data-i18n="trading_use_env">Use API keys from .env (if available)</span>
        </label>
        <label><span data-i18n="label_api_key">API Key</span>
          <input id="trade_api_key" type="password" placeholder="Bybit API key" disabled data-i18n-placeholder="placeholder_api_key">
        </label>
        <label><span data-i18n="label_api_secret">API Secret</span>
          <input id="trade_api_secret" type="password" placeholder="Bybit API secret" disabled data-i18n-placeholder="placeholder_api_secret">
        </label>
        <label><span data-i18n="label_mode">Mode</span>
          <select id="trade_mode" disabled>
            <option value="close_only" data-i18n="mode_close_only">Enable Close Only</option>
            <option value="open_close" data-i18n="mode_open_close">Enable Open/Close</option>
          </select>
        </label>
        <label class="check">
          <input id="trade_demo" type="checkbox" disabled>
          <span data-i18n="label_demo">Demo (REST-only, for order testing)</span>
        </label>
      </div>
      <div class="modal-actions">
        <button id="enable_trading" disabled data-i18n="button_enable_trading">Enable Trading</button>
        <button id="disable_trading" data-i18n="button_logout">Log Out</button>
      </div>
      <div class="muted" id="trade_status" data-i18n="status_trading_prompt">Trading disabled.</div>
    </div>
  </div>

  <div id="donate_modal" class="modal">
    <div class="modal-card">
      <div class="modal-header">
        <h2 data-i18n="donate_title">Support This Dashboard</h2>
        <button id="close_donate_modal" data-i18n="button_close">Close</button>
      </div>
      <div class="modal-body">
        <div class="muted" data-i18n="donate_note">
          Donations are optional and never required. Thank you for supporting Resilient Lab 505.
        </div>
        <div class="row">
          <div class="card donate-card">
            <div class="label" data-i18n="donate_evm_label">ETH / BSC / POL / ARB (EVM)</div>
            <div class="qr-wrap">
              <img class="qr" src="https://api.qrserver.com/v1/create-qr-code/?size=140x140&data=0x6E5a912588b1dAe7556DcD35EE8C2d8a9bC82Da8" alt="EVM QR">
            </div>
            <div class="muted wallet-address">
              0x6E5a912588b1dAe7556DcD35EE8C2d8a9bC82Da8
            </div>
          </div>
          <div class="card donate-card">
            <div class="label" data-i18n="donate_trc_label">TRC</div>
            <div class="qr-wrap">
              <img class="qr" src="https://api.qrserver.com/v1/create-qr-code/?size=140x140&data=TVWKt5ZZDdp9MXaqk9jTKnZsfz3q3Zwa5Q" alt="TRC QR">
            </div>
            <div class="muted wallet-address">
              TVWKt5ZZDdp9MXaqk9jTKnZsfz3q3Zwa5Q
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const HISTORY_KEY = 'trade_optimizer_history_v1';
    const MAX_HISTORY = 5000;
    const state = {
      history: [],
      historyIndex: new Set(),
      product: null,
      exchange: null,
      metrics: null,
      metricsSymbols: [],
      tradingEnabled: false,
      tradingMode: '',
      tradingHasEnv: false,
      chartRange: null,
      chartMarkerSignature: '',
      chartOrderSignature: '',
      ordersCache: [],
      ordersCacheSymbol: '',
      ordersLoaded: false,
      chartVisible: false,
      optionsChartVisible: false,
      chartLastOverlayTs: 0,
      positionSymbols: [],
      positionCache: {},
      activePositionSymbol: '',
      customSymbols: [],
      streamInterval: '',
      lastKlineSymbol: '',
      lastKlineInterval: '',
      chartHasLoaded: false,
      lastKlineTime: 0,
      newCandleCount: 0,
      analysisData: null,
      analysisMode: 'full',
      analysisCompare: null,
      advancedData: null,
      advancedDetailsKey: ''
    };
    let chart = null;
    let candleSeries = null;
    let chartTimer = null;
    let chartOverlayTimer = null;
    let chartPositionLines = [];
    let chartOrderLines = [];
    let chartMarkersCache = [];
    let tickSeries = null;
    let tradeStream = null;
    let streamCandles = [];
    let tickPoints = [];
    let tickUpdateQueued = false;
    let chartInitAttempts = 0;
    let streamRetryTimer = null;
    let suppressRangeTracking = false;
    let chartKlinesCache = [];
    let drawMode = null;
    let drawStart = null;
    let drawTempRect = null;
    let drawings = [];
    let volumeSeries = null;
    let chartLegendEl = null;
    let chartContainerEl = null;
    let lastStreamCandle = null;
    let lastStreamBucket = null;
    let markerBuffer = [];
    let markerHash = '';
    let markerTimer = null;
    let indicatorSeries = new Map();
    let indicatorsEnabled = { ma20: false, ema20: false, vwap: false };
    let indicatorTimer = null;
    let indicatorDropdownBound = false;
    const symbolPrecision = {};
    let optionsChart = null;
    let optionsMarkSeries = null;
    let optionsOverlaySeries = new Map();
    let optionsMetricsEnabled = { iv: false, delta: false, vega: false };
    let optionsChartTimer = null;
    let optionsOrderbookTimer = null;
    let optionsChartLegendEl = null;
    let optionsChartInitAttempts = 0;
    let optionsChartHasLoaded = false;
    let optionsChartLastSymbol = '';
    let optionsChartLastInterval = '';
    let optionsSeriesData = { mark: [], iv: [], delta: [], vega: [] };
    let optionsCandlesData = [];
    let optionsSnapshot = null;
    let optionsChartRefreshing = false;
    let optionsInstruments = [];
    let optionsInstrumentsLoaded = false;
    let overlayLines = { orders: [], be: [], liq: [] };
    let activeTool = 'cursor';
    let currentSide = 'Buy';
    let isDraggingOrder = false;
    let orderLine = null;
    let dragPrice = null;
    const TICK_MAX_POINTS = 2000;
    const TICK_TRIM_EVERY = 100;
    const I18N = {
      en: {
        title: 'Resilient Trade Manager',
        subtitle_monitoring: 'Trade Monitoring and Analytics',
        subtitle_bybit: 'Bybit API direct monitoring',
        status_waiting_product: 'Waiting for product...',
        status_waiting_data: 'Waiting for data',
        status_api_missing: 'API keys missing',
        status_trading_enabled: 'Trading Enabled',
        status_trading_disabled: 'Trading disabled.',
        status_trading_prompt: 'Trading disabled.',
        status_no_analysis: 'No analysis data available',
        status_analysis_hint: 'Click "Generate Analysis" to load comprehensive trade analysis.',
        status_positions_hint: 'Click "Refresh Positions" to load current positions.',
        status_orders_hint: 'Fetch active orders (API credentials required).',
        status_no_positions: 'No open positions',
        status_no_orders: 'No active orders.',
        status_orders_error: 'Error loading orders:',
        status_positions_error: 'Error loading positions:',
        status_analysis_error: 'Error loading analysis:',
        status_analysis_unavailable: 'Analysis not available. Make sure you are in sync or realtime mode.',
        label_product: 'Product',
        label_source: 'Source',
        label_exchange: 'Exchange',
        label_last_traded: 'Last Traded',
        label_session: 'Session',
        tab_overview: 'Overview',
        tab_analysis: 'Analysis',
        tab_advanced_analysis: 'Advanced Analysis',
        tab_chart: 'Chart',
        tab_options_chart: 'Options Chart',
        tab_positions: 'Positions',
        tab_resilient_maker: 'Resilient Maker',
        tab_other_products: 'Other Products',
        tab_about: 'About',
        heading_trade_consistency: 'Trade Consistency',
        heading_options_chart: 'Options Chart',
        heading_options_orderbook: 'Options Orderbook',
        label_expiry: 'Expiry',
        label_option_type: 'Call/Put',
        label_total: 'Total',
        label_consistency_score: 'Consistency Score',
        label_avg_interval: 'Avg Interval (s)',
        label_interval_std: 'Interval Std (s)',
        label_buy_sell: 'Buy / Sell',
        label_trades_per_hour: 'Trades / Hour',
        label_logged_trades: 'Logged Trades',
        heading_trade_history: 'Trade History (Logged)',
        label_symbol: 'Symbol',
        label_side: 'Side',
        side_buy: 'Buy',
        side_sell: 'Sell',
        label_min_qty: 'Min Qty',
        label_max_rows: 'Max Rows',
        label_start_date: 'Start',
        label_end_date: 'End',
        label_use_date_range: 'Use Date Range',
        button_apply: 'Apply',
        button_export_history: 'Export History',
        button_clear_log: 'Clear Local Log',
        options_chart_hint: 'Select an options contract to load trade-derived candles. IV/greeks use snapshots.',
        options_chart_loading: 'Loading options contracts...',
        options_chart_load_failed: 'Failed to load options contracts.',
        th_time: 'Time',
        th_symbol: 'Symbol',
        th_side: 'Side',
        th_qty: 'Qty',
        th_price: 'Price',
        th_notional: 'Notional',
        th_fee: 'Fee',
        th_tp: 'TP',
        th_order_id: 'Order ID',
        heading_rm_snapshot: 'Resilient Maker Snapshot',
        label_inventory: 'Inventory',
        label_session_pnl: 'Session PnL',
        label_realized_pnl: 'Realized PnL',
        label_unrealized_pnl: 'Unrealized PnL',
        label_fee_total: 'Fee Total',
        label_funding_total: 'Funding Total',
        heading_glft_status: 'GLFT Status',
        heading_advanced_analytics: 'Analysis',
        heading_advanced_analysis: 'Advanced Analysis',
        label_analysis_mode: 'Analysis Mode',
        analysis_full: 'Full Analysis',
        analysis_performance: 'Performance Metrics',
        analysis_risk: 'Risk Metrics',
        analysis_maker_taker: 'Maker/Taker Breakdown',
        label_options_greeks: 'Options Greeks',
        options_greeks_model: 'Model (BS)',
        options_greeks_bybit: 'Bybit Greeks',
        label_options_symbol: 'Options Symbol',
        label_timeframe: 'Timeframe',
        tf_1d: '1 Day',
        tf_7d: '7 Days',
        tf_14d: '14 Days',
        tf_30d: '30 Days',
        tf_60d: '60 Days',
        tf_90d: '90 Days',
        tf_180d: '180 Days',
        tf_365d: '365 Days',
        button_refresh_analysis: 'Generate Analysis',
        analysis_generating: 'Generating analysis...',
        button_generate_advanced: 'Generate Advanced Analysis',
        advanced_generating: 'Generating advanced analysis...',
        button_export_analysis: 'Export Analysis',
        button_export_fills: 'Export Fills',
        button_export_orders: 'Export Orders',
        button_compare_sources: 'Compare Sources',
        button_options_use_bybit: 'Use Bybit Greeks',
        analysis_hint: 'Click "Generate Analysis" to load comprehensive trade analysis.',
        advanced_analysis_hint: 'Click "Generate Advanced Analysis" to explore time-based performance.',
        analysis_heading_entry_exit: 'Average Entry / Exit',
        analysis_heading_options: 'Options Exposure',
        analysis_label_avg_entry_price: 'Avg Entry Price',
        analysis_label_avg_exit_price: 'Avg Exit Price',
        analysis_label_avg_entry_qty: 'Avg Entry Qty',
        analysis_label_avg_exit_qty: 'Avg Exit Qty',
        analysis_label_avg_entry_notional: 'Avg Entry Notional',
        analysis_label_avg_exit_notional: 'Avg Exit Notional',
        analysis_label_avg_entry_fee: 'Avg Entry Fee',
        analysis_label_avg_exit_fee: 'Avg Exit Fee',
        analysis_label_delta: 'Delta',
        analysis_label_gamma: 'Gamma',
        analysis_label_theta: 'Theta',
        analysis_label_vega: 'Vega',
        analysis_label_iv_pnl: 'IV Shock PnL',
        options_greeks_source_model: 'Source: Model (BS)',
        options_greeks_source_bybit: 'Source: Bybit Greeks',
        options_greeks_note_bybit: 'Bybit greeks may include linear delta.',
        options_greeks_no_data: 'No options greeks for selected symbol.',
        advanced_heading_time_correlation: 'Time vs PnL Correlation',
        advanced_label_corr_hour_pnl: 'Hour-of-Day vs PnL',
        advanced_label_corr_tradecount_pnl: 'Trade Count vs PnL',
        advanced_label_corr_volume_pnl: 'Notional vs PnL',
        advanced_heading_daily_performance: 'Day-on-Day Performance',
        advanced_heading_hourly_performance: 'Hour-on-Hour Performance',
        advanced_heading_hour_of_day: 'Hour-of-Day Performance',
        advanced_heading_symbol_hourly: 'Avg Buy/Sell per Hour (by Symbol)',
        advanced_heading_inventory_hourly: 'Inventory Build (Hourly)',
        advanced_heading_inventory_daily: 'Inventory Build (Daily)',
        advanced_heading_inventory_weekly: 'Inventory Build (Weekly)',
        advanced_heading_hourly_balance: 'Hourly PnL Curve',
        advanced_series_primary: 'PnL',
        advanced_series_secondary: 'Notional',
        advanced_series_trades: 'Trades',
        advanced_inventory_note: 'Inventory is aggregated across symbols. Select a symbol for a focused inventory view.',
        advanced_details_title: 'Detailed Tables',
        advanced_details_empty: 'Select a section to view detailed rows.',
        advanced_details_button: 'Details',
        advanced_label_date: 'Date',
        advanced_label_hour: 'Hour',
        advanced_label_week: 'Week',
        advanced_label_trades: 'Trades',
        advanced_label_notional: 'Notional',
        advanced_label_pnl: 'PnL',
        advanced_label_delta_trades: 'Δ Trades',
        advanced_label_delta_notional: 'Δ Notional',
        advanced_label_delta_pnl: 'Δ PnL',
        advanced_label_net_qty: 'Net Qty',
        advanced_label_cum_net_qty: 'Cumulative Net Qty',
        advanced_label_buy_count: 'Buy Count',
        advanced_label_sell_count: 'Sell Count',
        advanced_label_buy_qty: 'Buy Qty',
        advanced_label_sell_qty: 'Sell Qty',
        advanced_label_avg_buy_qty: 'Avg Buy Qty',
        advanced_label_avg_sell_qty: 'Avg Sell Qty',
        advanced_label_buy_notional: 'Buy Notional',
        advanced_label_sell_notional: 'Sell Notional',
        heading_chart: 'Chart',
        label_interval: 'Interval',
        label_refresh_ms: 'Refresh (ms)',
        label_auto_refresh: 'Auto Refresh',
        label_breakeven: 'Break-even',
        label_liquidation: 'Liquidation',
        label_active_orders: 'Active Orders',
        label_trades: 'Trades',
        button_reload: 'Reload',
        chart_hint: 'Select a symbol to load klines.',
        chart_zoom_hint: 'Auto refresh paused while zooming. Re-enable auto refresh to keep updating.',
        heading_current_positions: 'Current Positions',
        button_fetch_positions: 'Fetch Current Positions',
        positions_hint: 'Click "Refresh Positions" to load current positions.',
        heading_active_orders: 'Active Orders',
        button_fetch_orders: 'Fetch Active Orders',
        orders_hint: 'Fetch active orders (API credentials required).',
        heading_other_products: 'Other Products',
        other_products_hint: 'No additional products detected. Future modules will appear here automatically.',
        heading_about: 'About',
        help_section_api: 'API Key Setup',
        help_api_1: 'Use read-only keys for analysis/export. Trading requires keys with order permissions.',
        help_api_2: 'Keys are stored in memory for the session. Use .env if you prefer.',
        help_section_connection: 'Connection Method',
        help_conn_1: 'REST is used for historical analysis and exports.',
        help_conn_2: 'WebSocket is optional for realtime fills/positions.',
        help_section_analysis: 'Analysis / Advanced Analysis',
        help_analysis_1: 'Use Analysis for summaries and basic metrics.',
        help_analysis_2: 'Advanced Analysis provides time-based breakdowns and inventory charts.',
        help_section_chart: 'Chart & Trading',
        help_chart_1: 'Chart supports overlays, orders, and trade markers.',
        help_chart_2: 'Trading panel can submit orders if enabled.',
        about_credit: 'This Trade Manager is powered by Resilient Lab 505.',
        about_contact: 'Business contact: contact@resilientlab505.com',
        about_trademark_notice: 'Logos are trademarks of their respective owners.',
        donate_title: 'Support This Dashboard',
        donate_note: 'Donations are optional and never required. Thank you for supporting Resilient Lab 505.',
        donate_evm_label: 'ETH / BSC / POL / ARB (EVM)',
        donate_trc_label: 'TRC',
        button_donate: '💜 Donate',
        about_youtube_label: 'YouTube',
        about_telegram_label: 'Telegram',
        about_website_label: 'Website',
        heading_enable_trading: 'Enable Trading',
        button_close: 'Close',
        trading_warning: 'Trading via API carries risk. Use restricted keys, avoid high leverage, and keep funds separated. Keys are stored in server memory for this session only.',
        trading_ack: 'I understand the risks and want to continue.',
        trading_use_env: 'Use API keys from .env (if available)',
        label_api_key: 'API Key',
        label_api_secret: 'API Secret',
        placeholder_api_key: 'Bybit API key',
        placeholder_api_secret: 'Bybit API secret',
        label_mode: 'Mode',
        mode_close_only: 'Enable Close Only',
        mode_open_close: 'Enable Open/Close',
        label_demo: 'Demo (REST-only, for order testing)',
        button_enable_trading: 'Enable Trading',
        button_logout: 'Log Out',
        all: 'ALL',
        analysis_heading_basic: 'Basic Statistics',
        analysis_heading_summary: 'Summary',
        analysis_heading_advice: 'Actionable Advice',
        analysis_heading_compare: 'Data Source Comparison',
        analysis_label_fills_rows: 'Fills Rows',
        analysis_label_orders_rows: 'Orders Rows',
        analysis_label_orders_filled: 'Orders Filled',
        analysis_label_fields_present: 'Fields Present',
        analysis_label_fetch_time: 'Fetch Time (ms)',
        analysis_heading_performance: 'Performance Metrics',
        analysis_heading_risk: 'Risk Metrics',
        analysis_heading_maker_taker: 'Maker vs Taker',
        analysis_heading_symbol_pnl: 'Symbol PnL',
        analysis_summary_empty: 'Not enough data to summarize yet.',
        analysis_advice_empty: 'No specific advice triggered by the current data.',
        analysis_label_total_trades: 'Total Trades',
        analysis_label_total_volume: 'Total Volume',
        analysis_label_net_pnl: 'Net PnL',
        analysis_label_total_fee: 'Total Fee',
        analysis_label_maker_trades: 'Maker Trades',
        analysis_label_taker_trades: 'Taker Trades',
        analysis_label_maker_pnl: 'Maker PnL',
        analysis_label_taker_pnl: 'Taker PnL',
        positions_table_symbol: 'Symbol',
        positions_table_side: 'Side',
        positions_table_size: 'Size',
        positions_table_avg_price: 'Avg Price',
        positions_table_mark_price: 'Mark Price',
        positions_table_unrealised: 'Unrealised PnL',
        positions_table_realised: 'Realised PnL',
        positions_table_leverage: 'Leverage',
        positions_table_actions: 'Actions',
        positions_table_manage: 'Manage',
        orders_table_symbol: 'Symbol',
        orders_table_side: 'Side',
        orders_table_type: 'Type',
        orders_table_qty: 'Qty',
        orders_table_price: 'Price',
        orders_table_status: 'Status',
        orders_table_action: 'Action',
        orders_cancel: 'Cancel',
        tooltip_current_realised: 'Current Realised',
        tooltip_funding: 'Funding',
        tooltip_closed_pnl: 'Closed PnL',
        tooltip_break_even: 'Break-even',
        tooltip_unrealised_pnl: 'Unrealised PnL',
        tooltip_realised_pnl: 'Realised PnL',
        chart_order_buy: 'Order (Buy)',
        chart_order_sell: 'Order (Sell)',
        chart_break_even: 'Break-even',
        chart_liq: 'Liq',
        label_chart_height: 'Height',
        label_custom_symbol: 'Search',
        button_add_symbol: 'Add',
        alert_missing_order: 'Missing order identifier.',
        alert_trading_required: 'Cancel requires trading to be enabled.',
        alert_cancel_confirm: 'Cancel order',
        alert_cancel_failed: 'Cancel failed.',
        alert_ack_risk: 'Please acknowledge the risks before enabling trading.',
        alert_keys_required: 'API key and secret are required.',
        alert_no_env: 'No .env keys detected on the server.',
        alert_enable_failed: 'Trading enable failed.',
        alert_disable_failed: 'Disable failed.',
        alert_export_error: 'Error exporting analysis'
        ,
        trade_panel_title: 'Chart Trading',
        label_qty: 'Qty',
        label_order_type: 'Order Type',
        order_mode_market: 'Market',
        order_mode_best: 'Best Bid/Offer',
        order_mode_chase: 'Chase Limit',
        order_mode_limit: 'Limit',
        label_price: 'Price',
        label_reduce_only: 'Reduce Only',
        button_buy: 'Buy',
        button_sell: 'Sell',
        position_modal_title: 'Position Controls',
        label_take_profit: 'Take Profit',
        label_stop_loss: 'Stop Loss',
        button_set_tpsl: 'Set TP/SL',
        button_smart_tp: 'Smart TP',
        button_smart_sl: 'Smart SL',
        button_close_position: 'Close Position',
        alert_trading_disabled: 'Trading is not enabled.',
        alert_qty_required: 'Enter a valid quantity.',
        alert_symbol_required: 'Select a symbol first.',
        alert_price_required: 'Enter a valid price.',
        alert_position_missing: 'Position not found.',
        alert_tpsl_required: 'Enter take profit and/or stop loss.',
        alert_order_failed: 'Order failed.',
        alert_action_failed: 'Action failed.'
      },
      zh: {
        title: 'Resilient 交易管理器',
        subtitle_monitoring: '交易监控与分析',
        subtitle_bybit: 'Bybit API 直连监控',
        status_waiting_product: '等待产品数据...',
        status_waiting_data: '等待数据',
        status_api_missing: '缺少 API 密钥',
        status_trading_enabled: '交易已启用',
        status_trading_disabled: '交易已禁用。',
        status_trading_prompt: '交易已禁用。',
        status_no_analysis: '暂无分析数据',
        status_analysis_hint: '点击“生成分析”加载完整交易分析。',
        status_positions_hint: '点击“刷新持仓”加载当前持仓。',
        status_orders_hint: '获取活跃订单（需要 API 凭据）。',
        status_no_positions: '暂无持仓',
        status_no_orders: '暂无活跃订单。',
        status_orders_error: '订单加载失败：',
        status_positions_error: '持仓加载失败：',
        status_analysis_error: '分析加载失败：',
        status_analysis_unavailable: '分析不可用，请确认处于同步或实时模式。',
        label_product: '产品',
        label_source: '来源',
        label_exchange: '交易所',
        label_last_traded: '最近成交',
        label_session: '会话',
        tab_overview: '概览',
        tab_analysis: '分析',
        tab_advanced_analysis: '高级分析',
        tab_chart: '图表',
        tab_options_chart: '期权图表',
        tab_positions: '持仓',
        tab_resilient_maker: 'Resilient Maker',
        tab_other_products: '其他产品',
        tab_about: '关于',
        heading_trade_consistency: '交易一致性',
        heading_options_chart: '期权图表',
        heading_options_orderbook: '期权盘口',
        label_expiry: '到期日',
        label_option_type: '看涨/看跌',
        label_total: '累计',
        label_consistency_score: '一致性评分',
        label_avg_interval: '平均间隔（秒）',
        label_interval_std: '间隔标准差（秒）',
        label_buy_sell: '买 / 卖',
        label_trades_per_hour: '每小时交易数',
        label_logged_trades: '记录交易数',
        heading_trade_history: '交易历史（已记录）',
        label_symbol: '交易对',
        label_side: '方向',
        side_buy: '买',
        side_sell: '卖',
        label_min_qty: '最小数量',
        label_max_rows: '最大行数',
        label_start_date: '开始日期',
        label_end_date: '结束日期',
        label_use_date_range: '使用日期范围',
        button_apply: '应用',
        button_export_history: '导出历史',
        button_clear_log: '清除本地记录',
        options_chart_hint: '选择期权合约以加载成交推导蜡烛图，IV/希腊值来自快照。',
        options_chart_loading: '正在加载期权合约...',
        options_chart_load_failed: '期权合约加载失败。',
        th_time: '时间',
        th_symbol: '交易对',
        th_side: '方向',
        th_qty: '数量',
        th_price: '价格',
        th_notional: '名义价值',
        th_fee: '手续费',
        th_tp: '止盈',
        th_order_id: '订单号',
        heading_rm_snapshot: 'Resilient Maker 快照',
        label_inventory: '库存',
        label_session_pnl: '会话盈亏',
        label_realized_pnl: '已实现盈亏',
        label_unrealized_pnl: '未实现盈亏',
        label_fee_total: '手续费合计',
        label_funding_total: '资金费合计',
        heading_glft_status: 'GLFT 状态',
        heading_advanced_analytics: '分析',
        heading_advanced_analysis: '高级分析',
        label_analysis_mode: '分析模式',
        analysis_full: '完整分析',
        analysis_performance: '绩效指标',
        analysis_risk: '风险指标',
        analysis_maker_taker: 'Maker/Taker 分析',
        label_options_greeks: '期权希腊值',
        options_greeks_model: '模型 (BS)',
        options_greeks_bybit: 'Bybit 希腊值',
        label_options_symbol: '期权标的',
        label_timeframe: '时间范围',
        tf_1d: '1 天',
        tf_7d: '7 天',
        tf_14d: '14 天',
        tf_30d: '30 天',
        tf_60d: '60 天',
        tf_90d: '90 天',
        tf_180d: '180 天',
        tf_365d: '365 天',
        button_refresh_analysis: '生成分析',
        analysis_generating: '分析生成中...',
        button_generate_advanced: '生成高级分析',
        advanced_generating: '高级分析生成中...',
        button_export_analysis: '导出分析',
        button_export_fills: '导出逐笔',
        button_export_orders: '导出订单',
        button_compare_sources: '来源对比',
        button_options_use_bybit: '使用 Bybit 希腊值',
        analysis_hint: '点击“生成分析”加载完整交易分析。',
        advanced_analysis_hint: '点击“生成高级分析”查看时间维度表现。',
        analysis_heading_entry_exit: '平均进出场',
        analysis_heading_options: '期权敞口',
        analysis_label_avg_entry_price: '平均进场价',
        analysis_label_avg_exit_price: '平均出场价',
        analysis_label_avg_entry_qty: '平均进场数量',
        analysis_label_avg_exit_qty: '平均出场数量',
        analysis_label_avg_entry_notional: '平均进场名义',
        analysis_label_avg_exit_notional: '平均出场名义',
        analysis_label_avg_entry_fee: '平均进场手续费',
        analysis_label_avg_exit_fee: '平均出场手续费',
        analysis_label_delta: 'Delta',
        analysis_label_gamma: 'Gamma',
        analysis_label_theta: 'Theta',
        analysis_label_vega: 'Vega',
        analysis_label_iv_pnl: 'IV 冲击盈亏',
        options_greeks_source_model: '来源：模型 (BS)',
        options_greeks_source_bybit: '来源：Bybit 希腊值',
        options_greeks_note_bybit: 'Bybit 希腊值可能包含线性头寸的 Delta。',
        options_greeks_no_data: '当前标的无期权希腊值数据。',
        advanced_heading_time_correlation: '交易时间 vs 盈亏相关',
        advanced_label_corr_hour_pnl: '小时段 vs 盈亏',
        advanced_label_corr_tradecount_pnl: '交易频次 vs 盈亏',
        advanced_label_corr_volume_pnl: '名义金额 vs 盈亏',
        advanced_heading_daily_performance: '按日表现',
        advanced_heading_hourly_performance: '按小时表现',
        advanced_heading_hour_of_day: '日内小时表现',
        advanced_heading_symbol_hourly: '按交易对每小时平均买卖',
        advanced_heading_inventory_hourly: '库存变化（小时）',
        advanced_heading_inventory_daily: '库存变化（每日）',
        advanced_heading_inventory_weekly: '库存变化（每周）',
        advanced_heading_hourly_balance: '每小时盈亏曲线',
        advanced_series_primary: '盈亏',
        advanced_series_secondary: '名义金额',
        advanced_series_trades: '交易数',
        advanced_inventory_note: '库存为全品种聚合，选择交易对后可查看该品种库存变化。',
        advanced_details_title: '明细表',
        advanced_details_empty: '请选择一个图表查看明细。',
        advanced_details_button: '明细',
        advanced_label_date: '日期',
        advanced_label_hour: '小时',
        advanced_label_week: '周',
        advanced_label_trades: '交易数',
        advanced_label_notional: '名义金额',
        advanced_label_pnl: '盈亏',
        advanced_label_delta_trades: '交易数变化',
        advanced_label_delta_notional: '名义变化',
        advanced_label_delta_pnl: '盈亏变化',
        advanced_label_net_qty: '净数量',
        advanced_label_cum_net_qty: '累计净数量',
        advanced_label_buy_count: '买入笔数',
        advanced_label_sell_count: '卖出笔数',
        advanced_label_buy_qty: '买入数量',
        advanced_label_sell_qty: '卖出数量',
        advanced_label_avg_buy_qty: '平均买入数量',
        advanced_label_avg_sell_qty: '平均卖出数量',
        advanced_label_buy_notional: '买入名义',
        advanced_label_sell_notional: '卖出名义',
        heading_chart: '图表',
        label_interval: '周期',
        label_refresh_ms: '刷新（毫秒）',
        label_auto_refresh: '自动刷新',
        label_breakeven: '保本价',
        label_liquidation: '强平价',
        label_active_orders: '活跃订单',
        label_trades: '成交',
        button_reload: '重新加载',
        chart_hint: '请选择交易对以加载 K 线。',
        chart_zoom_hint: '缩放时已暂停自动刷新，需要时请重新开启自动刷新。',
        heading_current_positions: '当前持仓',
        button_fetch_positions: '刷新持仓',
        positions_hint: '点击“刷新持仓”加载当前持仓。',
        heading_active_orders: '活跃订单',
        button_fetch_orders: '刷新活跃订单',
        orders_hint: '获取活跃订单（需要 API 凭据）。',
        heading_other_products: '其他产品',
        other_products_hint: '暂无其他产品。后续模块将自动展示。',
        heading_about: '关于',
        help_section_api: 'API 密钥设置',
        help_api_1: '分析/导出使用只读密钥；交易需要下单权限。',
        help_api_2: '密钥仅保存在本次会话内存中，可使用 .env。',
        help_section_connection: '连接方式',
        help_conn_1: '历史分析与导出使用 REST。',
        help_conn_2: 'WebSocket 用于实时成交/持仓（可选）。',
        help_section_analysis: '分析 / 高级分析',
        help_analysis_1: '分析页展示摘要与基础指标。',
        help_analysis_2: '高级分析提供时间维度与库存图表。',
        help_section_chart: '图表与交易',
        help_chart_1: '图表支持叠加、订单与成交标记。',
        help_chart_2: '启用交易后可在面板下单。',
        about_credit: '本交易管理器由 Resilient Lab 505 驱动。',
        about_contact: '商务联系：contact@resilientlab505.com',
        about_trademark_notice: '所有标识均为其各自所有者的商标。',
        donate_title: '支持此看板',
        donate_note: '捐赠完全自愿且非必须。感谢支持 Resilient Lab 505。',
        donate_evm_label: 'ETH / BSC / POL / ARB（EVM）',
        donate_trc_label: 'TRC',
        button_donate: '💜 捐赠',
        about_youtube_label: 'YouTube',
        about_telegram_label: 'Telegram',
        about_website_label: '网站',
        heading_enable_trading: '启用交易',
        button_close: '关闭',
        trading_warning: 'API 交易存在风险。请使用受限密钥、避免高杠杆，并隔离资金。密钥仅在本次会话保存在服务器内存中。',
        trading_ack: '我已了解风险并继续。',
        trading_use_env: '使用 .env 中的 API 密钥（如可用）',
        label_api_key: 'API Key',
        label_api_secret: 'API Secret',
        placeholder_api_key: 'Bybit API key',
        placeholder_api_secret: 'Bybit API secret',
        label_mode: '模式',
        mode_close_only: '仅允许平仓',
        mode_open_close: '允许开仓/平仓',
        label_demo: 'Demo（仅 REST，用于下单测试）',
        button_enable_trading: '启用交易',
        button_logout: '退出登录',
        all: '全部',
        analysis_heading_basic: '基础统计',
        analysis_heading_summary: '摘要',
        analysis_heading_advice: '针对性建议',
        analysis_heading_compare: '数据源对比',
        analysis_label_fills_rows: '逐笔行数',
        analysis_label_orders_rows: '订单行数',
        analysis_label_orders_filled: '成交订单',
        analysis_label_fields_present: '字段覆盖',
        analysis_label_fetch_time: '获取耗时(ms)',
        analysis_heading_performance: '绩效指标',
        analysis_heading_risk: '风险指标',
        analysis_heading_maker_taker: 'Maker vs Taker',
        analysis_heading_symbol_pnl: '按交易对盈亏',
        analysis_summary_empty: '数据不足，暂无法生成摘要。',
        analysis_advice_empty: '当前数据未触发具体建议。',
        analysis_label_total_trades: '总交易数',
        analysis_label_total_volume: '总成交量',
        analysis_label_net_pnl: '净盈亏',
        analysis_label_total_fee: '总手续费',
        analysis_label_maker_trades: 'Maker 交易',
        analysis_label_taker_trades: 'Taker 交易',
        analysis_label_maker_pnl: 'Maker 盈亏',
        analysis_label_taker_pnl: 'Taker 盈亏',
        positions_table_symbol: '交易对',
        positions_table_side: '方向',
        positions_table_size: '数量',
        positions_table_avg_price: '均价',
        positions_table_mark_price: '标记价',
        positions_table_unrealised: '未实现盈亏',
        positions_table_realised: '已实现盈亏',
        positions_table_leverage: '杠杆',
        positions_table_actions: '操作',
        positions_table_manage: '管理',
        orders_table_symbol: '交易对',
        orders_table_side: '方向',
        orders_table_type: '类型',
        orders_table_qty: '数量',
        orders_table_price: '价格',
        orders_table_status: '状态',
        orders_table_action: '操作',
        orders_cancel: '撤单',
        tooltip_current_realised: '当前已实现',
        tooltip_funding: '资金费',
        tooltip_closed_pnl: '平仓盈亏',
        tooltip_break_even: '保本价',
        tooltip_unrealised_pnl: '未实现盈亏',
        tooltip_realised_pnl: '已实现盈亏',
        chart_order_buy: '买单',
        chart_order_sell: '卖单',
        chart_break_even: '保本价',
        chart_liq: '强平价',
        label_chart_height: '高度',
        label_custom_symbol: '搜索',
        button_add_symbol: '添加',
        alert_missing_order: '缺少订单标识。',
        alert_trading_required: '撤单需要先启用交易。',
        alert_cancel_confirm: '确认撤销订单',
        alert_cancel_failed: '撤单失败。',
        alert_ack_risk: '请确认风险提示后再启用交易。',
        alert_keys_required: '请输入 API Key 和 Secret。',
        alert_no_env: '服务器未检测到 .env 密钥。',
        alert_enable_failed: '启用交易失败。',
        alert_disable_failed: '禁用失败。',
        alert_export_error: '导出分析失败'
        ,
        trade_panel_title: '图表交易',
        label_qty: '数量',
        label_order_type: '订单类型',
        order_mode_market: '市价',
        order_mode_best: '最佳买卖',
        order_mode_chase: '追价限价',
        order_mode_limit: '限价',
        label_price: '价格',
        label_reduce_only: '仅减仓',
        button_buy: '买入',
        button_sell: '卖出',
        position_modal_title: '持仓管理',
        label_take_profit: '止盈',
        label_stop_loss: '止损',
        button_set_tpsl: '设置止盈/止损',
        button_smart_tp: '智能止盈',
        button_smart_sl: '智能止损',
        button_close_position: '平仓',
        alert_trading_disabled: '交易未启用。',
        alert_qty_required: '请输入有效数量。',
        alert_symbol_required: '请先选择交易对。',
        alert_price_required: '请输入有效价格。',
        alert_position_missing: '未找到持仓。',
        alert_tpsl_required: '请输入止盈和/或止损价格。',
        alert_order_failed: '下单失败。',
        alert_action_failed: '操作失败。'
      }
    };
    let currentLang = 'en';

    function t(key) {
      const table = I18N[currentLang] || I18N.en;
      return table[key] || I18N.en[key] || key;
    }

    function applyTranslations() {
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (key) el.textContent = t(key);
      });
      document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (key) el.setAttribute('placeholder', t(key));
      });
      const titleEl = document.getElementById('title_text');
      if (titleEl) titleEl.textContent = t('title');
      document.title = t('title');
      const subtitle = document.getElementById('subtitle');
      if (subtitle && subtitle.getAttribute('data-mode') !== 'bybit') {
        subtitle.textContent = t('subtitle_monitoring');
      }
      const statusText = document.getElementById('status_text');
      if (statusText && statusText.textContent === I18N.en.status_waiting_product) {
        statusText.textContent = t('status_waiting_product');
      }
      const chartStatus = document.getElementById('chart_status');
      if (chartStatus && chartStatus.textContent === I18N.en.chart_hint) {
        chartStatus.textContent = t('chart_hint');
      }
      const tradeStatus = document.getElementById('trade_status');
      if (tradeStatus && tradeStatus.textContent === I18N.en.status_trading_prompt) {
        tradeStatus.textContent = t('status_trading_prompt');
      }
    }

    function formatModeLabel(mode) {
      if (!mode) return '-';
      const normalized = String(mode).replace('_', ' ');
      if (normalized === 'realtime') return currentLang === 'zh' ? '实时' : 'Realtime';
      if (normalized === 'sync') return currentLang === 'zh' ? '同步' : 'Sync';
      if (normalized === 'bybit api') return currentLang === 'zh' ? 'API 直连' : 'API Direct';
      return normalized;
    }

    function getChartTimeFormatter() {
      const interval = document.getElementById('chart_interval')?.value || '1';
      const isDaily = interval === 'D';
      const isStream = isStreamInterval(interval);
      const locale = currentLang === 'zh' ? 'zh-CN' : 'en-US';
      const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
      const format = isDaily
        ? { year: 'numeric', month: 'short', day: '2-digit' }
        : isStream
          ? { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' }
          : { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' };
      const formatter = new Intl.DateTimeFormat(locale, { ...format, timeZone });
      return (time) => {
        const ts = typeof time === 'object'
          ? Date.UTC(time.year, time.month - 1, time.day)
          : time * 1000;
        return formatter.format(new Date(ts));
      };
    }

    function getChartTickMarkFormatter() {
      const interval = document.getElementById('chart_interval')?.value || '1';
      const isDaily = interval === 'D';
      const isStream = isStreamInterval(interval);
      const locale = currentLang === 'zh' ? 'zh-CN' : 'en-US';
      const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
      const format = isDaily
        ? { year: 'numeric', month: 'short', day: '2-digit' }
        : isStream
          ? { hour: '2-digit', minute: '2-digit', second: '2-digit' }
          : { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' };
      const formatter = new Intl.DateTimeFormat(locale, { ...format, timeZone });
      return (time) => {
        const ts = typeof time === 'object'
          ? Date.UTC(time.year, time.month - 1, time.day)
          : time * 1000;
        return formatter.format(new Date(ts));
      };
    }

    function getOptionsIntervalValue() {
      return document.getElementById('options_chart_interval')?.value || '15';
    }

    function getOptionsChartTimeFormatter() {
      const interval = getOptionsIntervalValue();
      const isDaily = interval === 'D';
      const locale = currentLang === 'zh' ? 'zh-CN' : 'en-US';
      const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
      const format = isDaily
        ? { year: 'numeric', month: 'short', day: '2-digit' }
        : { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' };
      const formatter = new Intl.DateTimeFormat(locale, { ...format, timeZone });
      return (time) => {
        const ts = typeof time === 'object'
          ? Date.UTC(time.year, time.month - 1, time.day)
          : time * 1000;
        return formatter.format(new Date(ts));
      };
    }

    function getOptionsChartTickMarkFormatter() {
      const interval = getOptionsIntervalValue();
      const isDaily = interval === 'D';
      const locale = currentLang === 'zh' ? 'zh-CN' : 'en-US';
      const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
      const format = isDaily
        ? { year: 'numeric', month: 'short', day: '2-digit' }
        : { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' };
      const formatter = new Intl.DateTimeFormat(locale, { ...format, timeZone });
      return (time) => {
        const ts = typeof time === 'object'
          ? Date.UTC(time.year, time.month - 1, time.day)
          : time * 1000;
        return formatter.format(new Date(ts));
      };
    }

    function applyChartLocalization() {
      if (!chart) return;
      const interval = document.getElementById('chart_interval')?.value || '1';
      const isStream = isStreamInterval(interval);
      const localization = {
        locale: currentLang === 'zh' ? 'zh-CN' : 'en-US'
      };
      localization.timeFormatter = getChartTimeFormatter();
      chart.applyOptions({
        localization,
        timeScale: {
          tickMarkFormatter: getChartTickMarkFormatter(),
          timeVisible: true,
          secondsVisible: isStream,
          rightOffset: isStream ? 2 : 6,
          barSpacing: isStream ? 6 : 12
        }
      });
    }

    function applyOptionsChartLocalization() {
      if (!optionsChart) return;
      optionsChart.applyOptions({
        localization: {
          locale: currentLang === 'zh' ? 'zh-CN' : 'en-US',
          timeFormatter: getOptionsChartTimeFormatter()
        },
        timeScale: {
          tickMarkFormatter: getOptionsChartTickMarkFormatter(),
          timeVisible: true
        }
      });
    }

    function updateChartHeight(value) {
      const heightValue = Number(value) || 460;
      const adjustedHeight = heightValue + 5;
      const root = document.documentElement;
      root.style.setProperty('--chart-height', `${adjustedHeight}px`);
      const label = document.getElementById('chart_height_value');
      if (label) label.textContent = `${adjustedHeight}px`;
      resizeChart();
    }

    function setLanguage(lang) {
      currentLang = I18N[lang] ? lang : 'en';
      const select = document.getElementById('lang_select');
      if (select) select.value = currentLang;
      applyTranslations();
      updateSymbolOptions();
      renderHistory();
      renderConsistency();
      if (state.ordersLoaded) {
        renderOrders(state.ordersCache || []);
      }
      applyChartLocalization();
      applyOptionsChartLocalization();
      const tradingBtn = document.getElementById('open_trading_modal');
      if (state.tradingEnabled) {
        setTradeStatus(`${t('status_trading_enabled')} (${state.tradingMode.replace('_', '/')} ${currentLang === 'zh' ? '模式' : 'mode'}).`, true);
        if (tradingBtn) tradingBtn.textContent = t('status_trading_enabled');
      } else {
        setTradeStatus(t('status_trading_disabled'), false);
        if (tradingBtn) tradingBtn.textContent = t('button_enable_trading');
      }
      syncChartTradingState();
      fetchStatus();
    }

    function setText(id, value) {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
    }

    function loadHistory() {
      try {
        const raw = localStorage.getItem(HISTORY_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        const list = Array.isArray(parsed?.history) ? parsed.history : [];
        state.history = list;
        state.historyIndex = new Set(list.map(makeKey));
      } catch (e) {
        state.history = [];
        state.historyIndex = new Set();
      }
    }

    function saveHistory() {
      const payload = { version: 1, history: state.history };
      localStorage.setItem(HISTORY_KEY, JSON.stringify(payload));
    }

    function makeKey(fill) {
      const parts = [
        fill.order_id || '',
        fill.ts || '',
        fill.side || '',
        fill.price || '',
        fill.qty || ''
      ];
      return parts.join('|');
    }

    function normalizeFill(fill) {
      const qty = fill.qty ?? 0;
      const price = fill.price ?? 0;
      const notional = fill.notional ?? (qty && price ? qty * price : 0);
      return {
        ts: fill.ts || 0,
        order_id: fill.order_id || '',
        symbol: fill.symbol || fill.Symbol || '',
        side: fill.side || '',
        qty,
        price,
        notional,
        fee: fill.fee ?? '',
        fee_ccy: fill.fee_ccy || '',
        is_tp: !!fill.is_tp
      };
    }

    function mergeHistory(fills) {
      let added = 0;
      for (const f of fills) {
        const norm = normalizeFill(f);
        const key = makeKey(norm);
        if (!state.historyIndex.has(key)) {
          state.history.push(norm);
          state.historyIndex.add(key);
          added += 1;
        }
      }
      if (added > 0) {
        state.history.sort((a, b) => (b.ts || 0) - (a.ts || 0));
        if (state.history.length > MAX_HISTORY) {
          state.history = state.history.slice(0, MAX_HISTORY);
          state.historyIndex = new Set(state.history.map(makeKey));
        }
        saveHistory();
      }
    }

    function computeConsistency(fills) {
      const total = fills.length;
      if (total < 2) {
        return {
          score: 0,
          avgInterval: 0,
          stdInterval: 0,
          buyCount: 0,
          sellCount: 0,
          tradesPerHour: 0
        };
      }
      const sorted = fills.slice().sort((a, b) => (a.ts || 0) - (b.ts || 0));
      const intervals = [];
      for (let i = 1; i < sorted.length; i++) {
        const dt = (sorted[i].ts || 0) - (sorted[i - 1].ts || 0);
        if (dt > 0) intervals.push(dt);
      }
      const avg = intervals.reduce((a, b) => a + b, 0) / (intervals.length || 1);
      const variance = intervals.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / (intervals.length || 1);
      const std = Math.sqrt(variance);
      const cv = avg > 0 ? std / avg : 1;
      const timeScore = Math.max(0, 100 - Math.min(100, cv * 100));
      let buy = 0;
      let sell = 0;
      for (const f of fills) {
        const side = String(f.side || '').toLowerCase();
        if (side.startsWith('b')) buy += 1;
        if (side.startsWith('s')) sell += 1;
      }
      const balance = total > 0 ? Math.abs(buy - sell) / total : 1;
      const balanceScore = Math.max(0, 100 - Math.min(100, balance * 100));
      const score = Math.round(timeScore * 0.7 + balanceScore * 0.3);
      const firstTs = sorted[0].ts || 0;
      const lastTs = sorted[sorted.length - 1].ts || 0;
      const hours = (lastTs - firstTs) / 3600;
      const tradesPerHour = hours > 0 ? (total / hours) : total;
      return {
        score,
        avgInterval: avg,
        stdInterval: std,
        buyCount: buy,
        sellCount: sell,
        tradesPerHour
      };
    }

    function getDateRangeFromInputs(startId, endId) {
      const startVal = document.getElementById(startId)?.value || '';
      const endVal = document.getElementById(endId)?.value || '';
      let startTs = null;
      let endTs = null;
      if (startVal) {
        const parsed = Date.parse(`${startVal}T00:00:00Z`);
        if (!Number.isNaN(parsed)) startTs = parsed / 1000;
      }
      if (endVal) {
        const parsed = Date.parse(`${endVal}T23:59:59Z`);
        if (!Number.isNaN(parsed)) endTs = parsed / 1000;
      }
      return { startTs, endTs };
    }

    function filterFillsByDate(rows, startTs, endTs) {
      if (!startTs && !endTs) return rows;
      return rows.filter(r => {
        const ts = Number(r.ts || 0);
        if (startTs && ts < startTs) return false;
        if (endTs && ts > endTs) return false;
        return true;
      });
    }

    function getHistoryFilters() {
      const symbol = getHistorySymbol();
      const side = document.getElementById('filter_side').value;
      const minQty = parseFloat(document.getElementById('filter_min_qty').value || '0');
      const { startTs, endTs } = getDateRangeFromInputs('filter_start', 'filter_end');
      return { symbol, side, minQty, startTs, endTs };
    }

    function applyHistoryFilters(rows, filters) {
      let output = rows;
      if (filters.symbol) output = output.filter(r => r.symbol === filters.symbol);
      if (filters.side) output = output.filter(r => r.side === filters.side);
      if (!Number.isNaN(filters.minQty) && filters.minQty > 0) {
        output = output.filter(r => Number(r.qty || 0) >= filters.minQty);
      }
      output = filterFillsByDate(output, filters.startTs, filters.endTs);
      return output;
    }

    function getFilteredHistoryRows(limit) {
      const filters = getHistoryFilters();
      let rows = applyHistoryFilters(state.history.slice(), filters);
      if (limit) rows = rows.slice(0, limit);
      return rows;
    }

    function renderHistory() {
      const body = document.getElementById('fills_body');
      body.innerHTML = '';
      const maxRows = parseInt(document.getElementById('filter_max_rows').value || '200', 10);
      const limit = isNaN(maxRows) ? 200 : maxRows;
      const rows = getFilteredHistoryRows(limit);
      for (const r of rows) {
        const t = r.ts ? new Date(r.ts * 1000).toLocaleTimeString() : '';
        const fee = r.fee !== '' ? `${r.fee} ${r.fee_ccy || ''}` : '';
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td data-value="${r.ts || ''}">${t}</td>
          <td>${r.symbol || ''}</td>
          <td>${r.side ? (String(r.side).toLowerCase().startsWith('b') ? 'B' : 'S') : ''}</td>
          <td data-value="${r.qty || ''}">${r.qty ?? ''}</td>
          <td data-value="${r.price || ''}">${r.price ?? ''}</td>
          <td data-value="${r.notional || ''}">${r.notional ?? ''}</td>
          <td data-value="${r.fee || ''}">${fee}</td>
          <td>${r.is_tp ? 'Y' : ''}</td>
          <td>${r.order_id || ''}</td>
        `;
        body.appendChild(tr);
      }
    }

    function renderConsistency() {
      const symbol = getHistorySymbol();
      const { startTs, endTs } = getDateRangeFromInputs('filter_start', 'filter_end');
      let scoped = filterFillsByDate(state.history.slice(), startTs, endTs);
      if (symbol) scoped = scoped.filter(r => r.symbol === symbol);
      const stats = computeConsistency(scoped);
      setText('consistency_score', stats.score ? `${stats.score}` : '-');
      const fill = document.getElementById('consistency_fill');
      if (fill) {
        const score = Math.max(0, Math.min(100, stats.score || 0));
        fill.style.width = `${score}%`;
        if (score >= 80) {
          fill.style.background = 'linear-gradient(90deg, #35f49b, #27d07d)';
          fill.style.boxShadow = '0 0 12px rgba(39, 208, 125, 0.35)';
        } else if (score >= 50) {
          fill.style.background = 'linear-gradient(90deg, #ffd36a, #f5a524)';
          fill.style.boxShadow = '0 0 10px rgba(245, 165, 36, 0.3)';
        } else {
          fill.style.background = 'linear-gradient(90deg, #ff7b7b, #ff6b6b)';
          fill.style.boxShadow = '0 0 10px rgba(255, 107, 107, 0.3)';
        }
      }
      setText('avg_interval', stats.avgInterval ? stats.avgInterval.toFixed(2) : '-');
      setText('std_interval', stats.stdInterval ? stats.stdInterval.toFixed(2) : '-');
      setText('buy_sell_ratio', `${stats.buyCount} / ${stats.sellCount}`);
      setText('trades_per_hour', stats.tradesPerHour ? stats.tradesPerHour.toFixed(2) : '-');
      setText('logged_trades', String(scoped.length));
    }

    function getHistorySymbol() {
      return document.getElementById('filter_symbol')?.value || '';
    }

    function getAnalysisSymbol() {
      return document.getElementById('analysis_symbol')?.value || '';
    }

    function updateSymbolOptions() {
      const historySymbols = state.history.map(r => r.symbol).filter(Boolean);
      const symbols = Array.from(new Set([
        ...historySymbols,
        ...state.metricsSymbols,
        ...state.positionSymbols,
        ...state.customSymbols
      ])).sort();
      const selects = [
        document.getElementById('filter_symbol'),
        document.getElementById('analysis_symbol'),
        document.getElementById('advanced_symbol'),
        document.getElementById('chart_symbol')
      ];
      selects.forEach(sel => {
        if (!sel) return;
        const current = sel.value;
        sel.innerHTML = `<option value="">${t('all')}</option>` + symbols.map(sym => `<option value="${sym}">${sym}</option>`).join('');
        if (current && symbols.includes(current)) {
          sel.value = current;
        } else {
          sel.value = '';
        }
      });
      const advancedSelect = document.getElementById('advanced_symbol');
      if (advancedSelect && !advancedSelect.value) {
        if (symbols.includes('BTCUSDT')) {
          advancedSelect.value = 'BTCUSDT';
        } else {
          const btcSymbol = symbols.find(sym => sym.includes('BTC'));
          if (btcSymbol) advancedSelect.value = btcSymbol;
        }
      }
      const chartSelect = document.getElementById('chart_symbol');
      if (chartSelect && !chartSelect.value) {
        if (symbols.includes('ETHUSDT')) {
          chartSelect.value = 'ETHUSDT';
        } else if (symbols.length > 0) {
          chartSelect.value = symbols[0];
        } else {
          chartSelect.value = 'ETHUSDT';
          if (!state.customSymbols.includes('ETHUSDT')) {
            state.customSymbols.push('ETHUSDT');
          }
        }
      }
      if (chartSelect && chartSelect.value && chartSelect.value !== state.lastKlineSymbol) {
        fetchKlines();
      }
    }

    function applyTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const target = tab.getAttribute('data-tab');
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
          const panel = document.getElementById(`panel-${target}`);
          if (panel) panel.classList.add('active');
          if (target === 'chart') {
            state.chartVisible = true;
            ensureChartReady();
            requestOverlayUpdate();
            ensureOrdersLoaded();
            state.optionsChartVisible = false;
            if (optionsChartTimer) {
              clearInterval(optionsChartTimer);
              optionsChartTimer = null;
            }
            stopOptionsOrderbook();
          } else {
            state.chartVisible = false;
            stopTradeStream();
            if (target === 'options-chart') {
              state.optionsChartVisible = true;
              ensureOptionsChartReady();
            } else {
              state.optionsChartVisible = false;
              if (optionsChartTimer) {
                clearInterval(optionsChartTimer);
                optionsChartTimer = null;
              }
              stopOptionsOrderbook();
            }
          }
        });
      });
    }

    async function fetchStatus() {
      try {
        const res = await fetch('/api/status', { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        const dot = document.getElementById('status_dot');
        const statusText = document.getElementById('status_text');
        dot.classList.remove('ok', 'warn', 'error');
        if (data.has_metrics) {
          dot.classList.add('ok');
          statusText.textContent = formatModeLabel((data.mode || 'unknown').toString());
        } else if (data.mode === 'bybit_api') {
          dot.classList.add('error');
          statusText.textContent = t('status_api_missing');
        } else {
          dot.classList.add('warn');
          statusText.textContent = t('status_waiting_data');
        }
        setText('product_name', 'ResTM(Beta)');
        setText('exchange_name', data.exchange || '-');
        setText('source_mode', formatModeLabel(data.mode || '-'));
        const statusTextEl = document.getElementById('status_text');
        if (statusTextEl) {
          statusTextEl.title = data.session_id ? `Session: ${data.session_id}` : '';
        }
        const exchangeLogo = document.getElementById('exchange_logo');
        if (exchangeLogo) {
          const exchange = (data.exchange || '').toString().toLowerCase();
          const logoMap = {
            bybit: '/assets/exchanges/Bybit_dark.png'
          };
          const logoSrc = logoMap[exchange] || '';
          if (logoSrc) {
            exchangeLogo.src = logoSrc;
            exchangeLogo.alt = exchange;
            exchangeLogo.classList.add('has-logo');
          } else {
            exchangeLogo.removeAttribute('src');
            exchangeLogo.classList.remove('has-logo');
          }
        }
        const subtitle = document.getElementById('subtitle');
        if (subtitle) {
          if (data.mode === 'bybit_api') {
            subtitle.textContent = t('subtitle_bybit');
            subtitle.setAttribute('data-mode', 'bybit');
          } else {
            subtitle.textContent = t('subtitle_monitoring');
            subtitle.setAttribute('data-mode', 'monitor');
          }
        }
      } catch (e) {}
    }

    async function fetchMetrics() {
      try {
        const res = await fetch('/api/metrics', { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        state.metrics = data;
        state.product = data.product || null;
        state.exchange = data.exchange || null;
        setText('symbol_name', data.symbol || '-');
        setText('session_id', data.session_id || '-');
        state.metricsSymbols = (data.fills || []).map(f => f.symbol).filter(Boolean);
        mergeHistory(data.fills || []);
        updateSymbolOptions();
        renderHistory();
        renderConsistency();
        renderResilientMaker(data);
      } catch (e) {}
    }

    function setAnalysisLoading(active) {
      const el = document.getElementById('analysis_loading');
      if (!el) return;
      if (active) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    }

    function getOptionsGreeksSource() {
      const el = document.getElementById('options_greeks_source');
      return (el && el.value) ? el.value : 'bs';
    }

    function normalizeUnderlyingSymbol(symbol) {
      const raw = (symbol || '').toUpperCase();
      if (raw.includes('BTC')) return 'BTC';
      if (raw.includes('ETH')) return 'ETH';
      return '';
    }

    function getOptionsSectionUnderlying() {
      const analysisSymbol = getAnalysisSymbol();
      if (analysisSymbol) {
        return normalizeUnderlyingSymbol(analysisSymbol);
      }
      const optionsSymbol = document.getElementById('options_symbol')?.value || '';
      return normalizeUnderlyingSymbol(optionsSymbol);
    }

    async function fetchOptionsReport() {
      try {
        const source = getOptionsGreeksSource();
        const optRes = await fetch(`/api/options/report?settle=USDT&iv_btc=0.44&iv_eth=0.65&iv_shock=0.0&source=${encodeURIComponent(source)}`, { cache: 'no-store' });
        if (optRes.ok) {
          const optJson = await optRes.json();
          state.analysisOptions = optJson.ok ? optJson.report : null;
        } else {
          state.analysisOptions = null;
        }
      } catch (e) {
        state.analysisOptions = null;
      }
    }

    async function fetchAnalysis() {
      setAnalysisLoading(true);
      try {
        const mode = document.getElementById('analysis_mode').value;
        const days = document.getElementById('analysis_timeframe').value;
        const symbol = getAnalysisSymbol();
        state.analysisCompare = null;
        const qs = new URLSearchParams({ days, symbol: symbol || '' });
        qs.set('source', 'rest');
        qs.set('limit', '20000');
        if (isAnalysisDateRangeEnabled()) {
          const startVal = document.getElementById('analysis_start')?.value || '';
          const endVal = document.getElementById('analysis_end')?.value || '';
          if (startVal) qs.set('start', startVal);
          if (endVal) qs.set('end', endVal);
        }
        const res = await fetch(`/api/analysis?${qs.toString()}`, { cache: 'no-store' });
        if (!res.ok) {
          let errorMsg = t('status_analysis_unavailable');
          try {
            const errorData = await res.json();
            errorMsg = errorData.error || errorMsg;
          } catch (jsonError) {
            errorMsg = `HTTP ${res.status}: ${res.statusText}`;
          }
          document.getElementById('analysis_content').innerHTML = `<div class="muted">${errorMsg}</div>`;
          return;
        }
        const data = await res.json();
        if (data.error) {
          document.getElementById('analysis_content').innerHTML = `<div class="muted">${data.error}</div>`;
          return;
        }
        state.analysisData = data;
        state.analysisMode = mode;
        await fetchOptionsReport();
        renderAnalysis(data, mode);
      } catch (e) {
        console.error('Analysis fetch error:', e);
        const errorMsg = e.message || 'Unknown error occurred';
        document.getElementById('analysis_content').innerHTML = `<div class="muted">${t('status_analysis_error')} ${errorMsg}<br>${currentLang === 'zh' ? '请检查浏览器控制台。' : 'Check browser console for details.'}</div>`;
      } finally {
        setAnalysisLoading(false);
      }
    }

    async function fetchAdvancedAnalysis() {
      setAdvancedLoading(true);
      try {
        const days = document.getElementById('advanced_timeframe').value;
        const symbol = getAdvancedSymbol();
        const qs = new URLSearchParams({ days, symbol: symbol || '' });
        qs.set('source', 'rest');
        qs.set('limit', '20000');
        if (isAdvancedDateRangeEnabled()) {
          const startVal = document.getElementById('advanced_start')?.value || '';
          const endVal = document.getElementById('advanced_end')?.value || '';
          if (startVal) qs.set('start', startVal);
          if (endVal) qs.set('end', endVal);
        }
        const res = await fetch(`/api/analysis?${qs.toString()}`, { cache: 'no-store' });
        if (!res.ok) {
          let errorMsg = t('status_analysis_unavailable');
          try {
            const errorData = await res.json();
            errorMsg = errorData.error || errorMsg;
          } catch (jsonError) {
            errorMsg = `HTTP ${res.status}: ${res.statusText}`;
          }
          document.getElementById('advanced_content').innerHTML = `<div class="muted">${errorMsg}</div>`;
          return;
        }
        const data = await res.json();
        if (data.error) {
          document.getElementById('advanced_content').innerHTML = `<div class="muted">${data.error}</div>`;
          return;
        }
        state.advancedData = data;
        renderAdvancedAnalysis(data, symbol);
      } catch (e) {
        console.error('Advanced analysis fetch error:', e);
        const errorMsg = e.message || 'Unknown error occurred';
        document.getElementById('advanced_content').innerHTML = `<div class="muted">${t('status_analysis_error')} ${errorMsg}<br>${currentLang === 'zh' ? '请检查浏览器控制台。' : 'Check browser console for details.'}</div>`;
      } finally {
        setAdvancedLoading(false);
      }
    }

    function formatPct(value, digits = 1) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      return `${(num * 100).toFixed(digits)}%`;
    }

    function formatSigned(value, digits = 4) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      const sign = num > 0 ? '+' : '';
      return `${sign}${num.toFixed(digits)}`;
    }

    function formatNumber(value, digits = 2) {
      const num = Number(value);
      if (!Number.isFinite(num)) return '-';
      return num.toFixed(digits);
    }

    function getHourLabel(hourStr) {
      if (!hourStr || typeof hourStr !== 'string') return '';
      const parts = hourStr.split(' ');
      if (parts.length < 2) return '';
      const hour = parts[1].split(':')[0];
      if (!hour) return '';
      return `${hour}:00`;
    }

    function buildAnalysisInsights(data) {
      const zh = currentLang === 'zh';
      const summary = [];
      const advice = [];
      const basic = data.basic || {};
      const perf = data.performance || {};
      const mt = data.maker_taker || {};
      const hourly = Array.isArray(data.hourly_stats) ? data.hourly_stats : [];
      const daily = Array.isArray(data.daily_stats) ? data.daily_stats : [];
      const symbols = Array.isArray(data.symbol_stats) ? data.symbol_stats : [];

      if (basic.total_trades) {
        const days = daily.length || 0;
        if (days > 0) {
          summary.push(zh ? `覆盖 ${days} 天 / ${basic.total_trades} 笔交易` : `Coverage: ${days} days / ${basic.total_trades} trades`);
        } else {
          summary.push(zh ? `交易数 ${basic.total_trades} 笔` : `Trades: ${basic.total_trades}`);
        }
      }

      if (basic.total_volume) {
        summary.push(zh ? `总成交量 ${basic.total_volume.toFixed(2)}` : `Total volume ${basic.total_volume.toFixed(2)}`);
      }

      if (basic.total_fee && basic.total_volume) {
        summary.push(zh ? `手续费占比 ${formatPct(basic.fee_rate, 2)}` : `Fee ratio ${formatPct(basic.fee_rate, 2)}`);
        if (basic.fee_rate > 0.0004) {
          advice.push(zh
            ? `手续费占比 ${formatPct(basic.fee_rate, 2)} 偏高，建议降低吃单比例或缩小高频交易时段。`
            : `Fee ratio ${formatPct(basic.fee_rate, 2)} is high; reduce taker usage or narrow high-frequency windows.`);
        }
      }

      if (symbols.length && basic.total_volume) {
        const top = symbols.reduce((a, b) => (b.total_volume || 0) > (a.total_volume || 0) ? b : a, symbols[0]);
        const share = (top.total_volume || 0) / (basic.total_volume || 1);
        summary.push(zh
          ? `交易量集中在 ${top.symbol || '-'}（${formatPct(share, 1)}）`
          : `Volume concentrated in ${top.symbol || '-'} (${formatPct(share, 1)})`);
        if (share >= 0.6) {
          advice.push(zh
            ? `${top.symbol || '该品种'} 占比 ${formatPct(share, 1)}，集中度偏高，建议把单品种占比压到 50% 以下。`
            : `${top.symbol || 'Top symbol'} share is ${formatPct(share, 1)}; reduce single-symbol exposure below 50%.`);
        }
      }

      if (hourly.length) {
        const buckets = {};
        for (const row of hourly) {
          const label = getHourLabel(row.hour);
          if (!label) continue;
          if (!buckets[label]) {
            buckets[label] = { pnl: 0, trades: 0 };
          }
          buckets[label].pnl += Number(row.hourly_pnl) || 0;
          buckets[label].trades += Number(row.trade_count) || 0;
        }
        const minTrades = Math.max(3, Math.floor((basic.total_trades || 0) * 0.02));
        const bucketList = Object.entries(buckets)
          .map(([hour, v]) => ({
            hour,
            trades: v.trades,
            avg_pnl: v.trades ? v.pnl / v.trades : 0
          }))
          .filter(b => b.trades >= minTrades);
        if (bucketList.length >= 2) {
          const best = bucketList.reduce((a, b) => (b.avg_pnl > a.avg_pnl ? b : a), bucketList[0]);
          const worst = bucketList.reduce((a, b) => (b.avg_pnl < a.avg_pnl ? b : a), bucketList[0]);
          summary.push(zh
            ? `时段分布：UTC ${best.hour} 平均盈亏 ${formatSigned(best.avg_pnl)}；UTC ${worst.hour} 平均盈亏 ${formatSigned(worst.avg_pnl)}`
            : `Time-of-day: UTC ${best.hour} avg ${formatSigned(best.avg_pnl)}; UTC ${worst.hour} avg ${formatSigned(worst.avg_pnl)}`);
          if (best.avg_pnl > 0 && worst.avg_pnl < 0) {
            advice.push(zh
              ? `减少 UTC ${worst.hour} 附近交易，优先 UTC ${best.hour} 时段（样本≥${minTrades} 笔）。`
              : `Reduce trading around UTC ${worst.hour}; prioritize UTC ${best.hour} (sample ≥ ${minTrades}).`);
          }
        }
      }

      if (mt.maker_count || mt.taker_count) {
        if ((mt.taker_count || 0) > (mt.maker_count || 0) && (mt.taker_pnl || 0) < 0) {
          advice.push(zh
            ? `Taker 交易 ${mt.taker_count || 0} 笔且盈亏 ${formatSigned(mt.taker_pnl || 0)}，建议降低吃单占比。`
            : `Taker trades ${mt.taker_count || 0} with PnL ${formatSigned(mt.taker_pnl || 0)}; reduce taker usage.`);
        }
        if ((mt.maker_count || 0) > 0 && (mt.maker_pnl || 0) < 0) {
          advice.push(zh
            ? `Maker 盈亏 ${formatSigned(mt.maker_pnl || 0)} 为负，检查挂单价格偏离或撤单过早。`
            : `Maker PnL ${formatSigned(mt.maker_pnl || 0)} is negative; review maker pricing or early cancels.`);
        }
      }

      if (perf.win_rate !== undefined && perf.profit_loss_ratio !== undefined) {
        summary.push(zh
          ? `胜率 ${formatPct(perf.win_rate, 1)}，盈亏比 ${Number(perf.profit_loss_ratio || 0).toFixed(2)}`
          : `Win rate ${formatPct(perf.win_rate, 1)}, P/L ${Number(perf.profit_loss_ratio || 0).toFixed(2)}`);
        if ((perf.win_rate || 0) < 0.45 && (perf.profit_loss_ratio || 0) < 1) {
          advice.push(zh
            ? `胜率 ${formatPct(perf.win_rate, 1)} 且盈亏比 ${Number(perf.profit_loss_ratio || 0).toFixed(2)}，建议先缩小开仓频率并优化止损/止盈比例。`
            : `Win rate ${formatPct(perf.win_rate, 1)} and P/L ${Number(perf.profit_loss_ratio || 0).toFixed(2)}; reduce frequency and rebalance SL/TP.` );
        }
      }

      if (perf.max_drawdown_pct !== undefined) {
        const dd = Number(perf.max_drawdown_pct || 0);
        if (dd < -10) {
          advice.push(zh
            ? `最大回撤 ${dd.toFixed(2)}%，建议限制单笔风险并回测触发点。`
            : `Max drawdown ${dd.toFixed(2)}%; tighten per-trade risk and review triggers.`);
        }
      }

      return { summary, advice };
    }

    function renderAnalysisSummary(insights) {
      const summaryItems = insights.summary.length
        ? insights.summary.map(item => `<li>${item}</li>`).join('')
        : `<li class="muted">${t('analysis_summary_empty')}</li>`;
      const adviceItems = insights.advice.length
        ? insights.advice.map(item => `<li>${item}</li>`).join('')
        : `<li class="muted">${t('analysis_advice_empty')}</li>`;
      return `
        <div class="analysis-summary">
          <div class="analysis-summary-grid">
            <div>
              <h3>${t('analysis_heading_summary')}</h3>
              <ul class="analysis-list">${summaryItems}</ul>
            </div>
            <div>
              <h3>${t('analysis_heading_advice')}</h3>
              <ul class="analysis-list">${adviceItems}</ul>
            </div>
          </div>
        </div>
      `;
    }

    function renderCompareBlock(compare) {
      if (!compare || !compare.ok) return '';
      const fills = compare.fills || {};
      const orders = compare.orders || {};
      return `
        <h3>${t('analysis_heading_compare')}</h3>
        <div class="row">
          <div class="card"><div class="label">${t('analysis_label_fills_rows')}</div><div class="value">${fills.rows || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fetch_time')}</div><div class="value">${fills.ms || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fields_present')}</div><div class="value">${fills.fields_present || 0}</div></div>
        </div>
        <div class="row">
          <div class="card"><div class="label">${t('analysis_label_orders_rows')}</div><div class="value">${orders.rows || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_orders_filled')}</div><div class="value">${orders.filled_rows || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fetch_time')}</div><div class="value">${orders.ms || 0}</div></div>
          <div class="card"><div class="label">${t('analysis_label_fields_present')}</div><div class="value">${orders.fields_present || 0}</div></div>
        </div>
      `;
    }

    function clearAnalysisDateFilters() {
      const start = document.getElementById('analysis_start');
      const end = document.getElementById('analysis_end');
      if (start) start.value = '';
      if (end) end.value = '';
    }

    function isAnalysisDateRangeEnabled() {
      return !!document.getElementById('analysis_use_range')?.checked;
    }

    function syncAnalysisDateRangeUI() {
      const enabled = isAnalysisDateRangeEnabled();
      const start = document.getElementById('analysis_start');
      const end = document.getElementById('analysis_end');
      if (start) start.disabled = !enabled;
      if (end) end.disabled = !enabled;
      if (!enabled) {
        clearAnalysisDateFilters();
      }
    }

    function getAdvancedSymbol() {
      return document.getElementById('advanced_symbol')?.value || '';
    }

    function isAdvancedDateRangeEnabled() {
      return !!document.getElementById('advanced_use_range')?.checked;
    }

    function clearAdvancedDateFilters() {
      const start = document.getElementById('advanced_start');
      const end = document.getElementById('advanced_end');
      if (start) start.value = '';
      if (end) end.value = '';
    }

    function syncAdvancedDateRangeUI() {
      const enabled = isAdvancedDateRangeEnabled();
      const start = document.getElementById('advanced_start');
      const end = document.getElementById('advanced_end');
      if (start) start.disabled = !enabled;
      if (end) end.disabled = !enabled;
      if (!enabled) {
        clearAdvancedDateFilters();
      }
    }

    function setAdvancedLoading(active) {
      const el = document.getElementById('advanced_loading');
      if (!el) return;
      if (active) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    }

    function renderAnalysis(data, mode) {
      const content = document.getElementById('analysis_content');
      let html = '';

      // Check if there's a message (no data available)
      if (data.basic && data.basic.message) {
        html = `<div class="muted">${data.basic.message}</div>`;
        content.innerHTML = html;
        return;
      }

      const insights = buildAnalysisInsights(data);
      html += renderAnalysisSummary(insights);
      if (state.analysisCompare) {
        html += renderCompareBlock(state.analysisCompare);
      }

      if (mode === 'full' || mode === 'performance') {
        const perf = data.performance || {};
        html += `<h3>${t('analysis_heading_performance')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '胜率' : 'Win Rate'}</div><div class="value">${((perf.win_rate || 0) * 100).toFixed(2)}%</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '盈亏比' : 'Profit/Loss Ratio'}</div><div class="value">${(perf.profit_loss_ratio || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '夏普比率' : 'Sharpe Ratio'}</div><div class="value">${(perf.sharpe_ratio || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '卡玛比率' : 'Calmar Ratio'}</div><div class="value">${(perf.calmar_ratio || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '最大回撤' : 'Max Drawdown'}</div><div class="value">${(perf.max_drawdown || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '总回报' : 'Total Return'}</div><div class="value">${(perf.total_return || 0).toFixed(4)}</div></div>`;
        html += '</div>';
      }

      if (mode === 'full' || mode === 'risk') {
        const risk = data.risk || {};
        html += `<h3>${t('analysis_heading_risk')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">VaR (95%)</div><div class="value">${(risk.var_95 || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">CVaR (95%)</div><div class="value">${(risk.cvar_95 || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '年化波动率' : 'Volatility (Annual)'}</div><div class="value">${(risk.volatility_annualised || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${currentLang === 'zh' ? '单日最大亏损' : 'Max Daily Loss'}</div><div class="value">${(risk.max_daily_loss || 0).toFixed(4)}</div></div>`;
        html += '</div>';
      }

      if (mode === 'full' || mode === 'maker_taker') {
        const mt = data.maker_taker || {};
        html += `<h3>${t('analysis_heading_maker_taker')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${t('analysis_label_maker_trades')}</div><div class="value">${mt.maker_count || 0}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_taker_trades')}</div><div class="value">${mt.taker_count || 0}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_maker_pnl')}</div><div class="value">${(mt.maker_pnl || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_taker_pnl')}</div><div class="value">${(mt.taker_pnl || 0).toFixed(4)}</div></div>`;
        html += '</div>';
      }

      if (data.basic) {
        const basic = data.basic;
        html += `<h3>${t('analysis_heading_basic')}</h3>`;
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${t('analysis_label_total_trades')}</div><div class="value">${basic.total_trades || 0}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_total_volume')}</div><div class="value">${(basic.total_volume || 0).toFixed(2)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_net_pnl')}</div><div class="value">${(basic.net_pnl || 0).toFixed(4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_total_fee')}</div><div class="value">${(basic.total_fee || 0).toFixed(4)}</div></div>`;
        html += '</div>';

      html += `<h3>${t('analysis_heading_entry_exit')}</h3>`;
      if (basic.avg_buy_price !== null && basic.avg_buy_price !== undefined) {
        html += '<div class="row">';
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_price')}</div><div class="value">${formatNumber(basic.avg_buy_price, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_price')}</div><div class="value">${formatNumber(basic.avg_sell_price, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_qty')}</div><div class="value">${formatNumber(basic.avg_buy_qty, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_qty')}</div><div class="value">${formatNumber(basic.avg_sell_qty, 4)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_notional')}</div><div class="value">${formatNumber(basic.avg_buy_notional, 2)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_notional')}</div><div class="value">${formatNumber(basic.avg_sell_notional, 2)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_entry_fee')}</div><div class="value">${formatNumber(basic.avg_buy_fee, 6)}</div></div>`;
        html += `<div class="card"><div class="label">${t('analysis_label_avg_exit_fee')}</div><div class="value">${formatNumber(basic.avg_sell_fee, 6)}</div></div>`;
        html += '</div>';
      } else if (Array.isArray(basic.avg_entry_exit_by_symbol) && basic.avg_entry_exit_by_symbol.length) {
        const rows = basic.avg_entry_exit_by_symbol.map(row => `
          <tr>
            <td>${row.symbol || '-'}</td>
            <td>${formatNumber(row.avg_entry_price, 4)}</td>
            <td>${formatNumber(row.avg_exit_price, 4)}</td>
            <td>${formatNumber(row.entry_qty, 4)}</td>
            <td>${formatNumber(row.exit_qty, 4)}</td>
          </tr>
        `);
        html += `<table><thead><tr>
          <th>${t('th_symbol')}</th>
          <th>${t('analysis_label_avg_entry_price')}</th>
          <th>${t('analysis_label_avg_exit_price')}</th>
          <th>${t('analysis_label_avg_entry_qty')}</th>
          <th>${t('analysis_label_avg_exit_qty')}</th>
        </tr></thead><tbody>${rows.join('')}</tbody></table>`;
      }

      if (state.analysisOptions) {
        const opt = state.analysisOptions;
        html += `<h3>${t('analysis_heading_options')}</h3>`;
        const sourceNote = opt.source === 'bybit'
          ? t('options_greeks_source_bybit')
          : t('options_greeks_source_model');
        const bybitNote = opt.source === 'bybit'
          ? (currentLang === 'zh' ? t('options_greeks_note_bybit') : (opt.note || t('options_greeks_note_bybit')))
          : '';
        html += `<div class="note">${sourceNote}${bybitNote ? ` · ${bybitNote}` : ''}</div>`;
        const underlying = getOptionsSectionUnderlying();
        const totalsByUnderlying = opt.totals_by_underlying || {};
        const selectedTotals = underlying ? totalsByUnderlying[underlying] : null;
        const totals = selectedTotals || (underlying ? null : (opt.total || {}));
        html += '<div class="row">';
        if (totals) {
          html += `<div class="card"><div class="label">${t('analysis_label_delta')}</div><div class="value">${formatNumber(totals.delta || 0, 4)}</div></div>`;
          html += `<div class="card"><div class="label">${t('analysis_label_gamma')}</div><div class="value">${formatNumber(totals.gamma || 0, 6)}</div></div>`;
          html += `<div class="card"><div class="label">${t('analysis_label_theta')}</div><div class="value">${formatNumber(totals.theta || 0, 6)}</div></div>`;
          html += `<div class="card"><div class="label">${t('analysis_label_vega')}</div><div class="value">${formatNumber(totals.vega || 0, 6)}</div></div>`;
          html += `<div class="card"><div class="label">${t('analysis_label_iv_pnl')}</div><div class="value">${formatNumber(totals.pnl_reprice || 0, 4)}</div></div>`;
        } else {
          html += `<div class="muted">${t('options_greeks_no_data')}</div>`;
        }
        html += '</div>';
        if (opt.totals_by_underlying) {
          const rows = Object.entries(opt.totals_by_underlying).map(([sym, totals]) => `
            <tr>
              <td>${sym}</td>
              <td>${formatNumber(totals.delta || 0, 4)}</td>
              <td>${formatNumber(totals.gamma || 0, 6)}</td>
              <td>${formatNumber(totals.theta || 0, 6)}</td>
              <td>${formatNumber(totals.vega || 0, 6)}</td>
              <td>${formatNumber(totals.pnl_reprice || 0, 4)}</td>
            </tr>
          `);
          if (rows.length) {
            html += `<table><thead><tr>
              <th>${t('th_symbol')}</th>
              <th>${t('analysis_label_delta')}</th>
              <th>${t('analysis_label_gamma')}</th>
              <th>${t('analysis_label_theta')}</th>
              <th>${t('analysis_label_vega')}</th>
              <th>${t('analysis_label_iv_pnl')}</th>
            </tr></thead><tbody>${rows.join('')}</tbody></table>`;
          }
        }
      }
      }

      if (Array.isArray(data.symbol_stats) && data.symbol_stats.length > 0) {
        html += `<h3>${t('analysis_heading_symbol_pnl')}</h3>`;
        html += `<table><thead><tr><th>${t('th_symbol')}</th><th>${currentLang === 'zh' ? '总盈亏' : 'Total PnL'}</th><th>${currentLang === 'zh' ? '交易数' : 'Trades'}</th><th>${t('analysis_label_total_fee')}</th><th>${t('analysis_label_total_volume')}</th></tr></thead><tbody>`;
        data.symbol_stats.forEach(row => {
          html += `<tr>
            <td>${row.symbol || '-'}</td>
            <td>${(row.total_pnl || 0).toFixed(4)}</td>
            <td>${row.trade_count || 0}</td>
            <td>${(row.total_fee || 0).toFixed(4)}</td>
            <td>${(row.total_volume || 0).toFixed(2)}</td>
          </tr>`;
        });
        html += '</tbody></table>';
      }

      content.innerHTML = html || `<div class="muted">${t('status_no_analysis')}</div>`;
    }

    function renderAdvancedTable(headers, rows) {
      return `<table><thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody>${rows.join('')}</tbody></table>`;
    }

    function renderDetailsTable(summaryText, tableHtml) {
      return `
        <details class="analysis-details">
          <summary>${summaryText}</summary>
          ${tableHtml}
        </details>
      `;
    }

    function renderChartBlock(title, chartHtml, detailKey = '') {
      return `
        <div class="analysis-chart-block">
          <div class="row row-between">
            <h3>${title}</h3>
            ${detailKey ? `<button class="chart-details" data-detail-key="${detailKey}">${t('advanced_details_button')}</button>` : ''}
          </div>
          ${chartHtml}
        </div>
      `;
    }

    function buildLinePath(points, width, height, padding = 12) {
      if (!points.length) return '';
      const min = Math.min(...points);
      const max = Math.max(...points);
      const span = max - min || 1;
      const innerW = width - padding * 2;
      const innerH = height - padding * 2;
      return points.map((val, idx) => {
        const x = padding + (innerW * idx) / (points.length - 1 || 1);
        const y = padding + innerH - ((val - min) / span) * innerH;
        return `${idx === 0 ? 'M' : 'L'}${x.toFixed(2)},${y.toFixed(2)}`;
      }).join(' ');
    }

    function renderLineChart(points, opts = {}) {
      const width = 180;
      const height = 80;
      const padding = 12;
      const label = opts.label || '';
      const units = opts.units || '';
      const secondary = Array.isArray(opts.secondary) ? opts.secondary : null;
      const showZoom = opts.zoom !== false;
      const primaryLabel = opts.primaryLabel || '';
      const secondaryLabel = opts.secondaryLabel || '';
      if (!points.length) {
        return `<div class="analysis-chart"><div class="muted">${t('status_no_analysis')}</div></div>`;
      }
      const path = buildLinePath(points, width, height, padding);
      const min = Math.min(...points);
      const max = Math.max(...points);
      const mid = (min + max) / 2;
      const gridY = [0, 1, 2].map(i => padding + (i * (height - padding * 2)) / 2);
      const leftLabelX = padding - 2;
      const rightLabelX = width - 2;
      let secondaryPath = '';
      let secondaryMin = 0;
      let secondaryMax = 0;
      let secondaryMid = 0;
      if (secondary && secondary.length) {
        secondaryMin = Math.min(...secondary);
        secondaryMax = Math.max(...secondary);
        secondaryMid = (secondaryMin + secondaryMax) / 2;
        secondaryPath = buildLinePath(secondary, width, height, padding);
      }
      return `
        <div class="analysis-chart">
          ${label ? `<div class="chart-title">${label}</div>` : ''}
          ${(primaryLabel || secondaryLabel) ? `
            <div class="chart-legend">
              ${primaryLabel ? `<span><span class="legend-dot primary"></span>${primaryLabel}</span>` : ''}
              ${secondaryLabel ? `<span><span class="legend-dot secondary"></span>${secondaryLabel}</span>` : ''}
            </div>
          ` : ''}
          ${showZoom ? `<button class="chart-zoom" data-title="${label}">Zoom</button>` : ''}
          <div class="chart-tooltip"></div>
          <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet"
            data-values='${JSON.stringify(points)}'
            data-secondary='${secondary ? JSON.stringify(secondary) : ''}'
            data-min="${min}" data-max="${max}"
            data-min2="${secondary ? secondaryMin : ''}"
            data-max2="${secondary ? secondaryMax : ''}"
            data-padding="${padding}">
            <line class="axis-line" x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}"></line>
            ${gridY.map(y => `<line class="grid-line" x1="${padding}" y1="${y}" x2="${width - padding}" y2="${y}"></line>`).join('')}
            <text class="axis-text" text-anchor="end" x="${leftLabelX}" y="${padding + 2}">${max.toFixed(2)}${units}</text>
            <text class="axis-text" text-anchor="end" x="${leftLabelX}" y="${(height / 2).toFixed(2)}">${mid.toFixed(2)}${units}</text>
            <text class="axis-text" text-anchor="end" x="${leftLabelX}" y="${height - 2}">${min.toFixed(2)}${units}</text>
            ${secondary ? `
              <text class="axis-text" text-anchor="end" x="${rightLabelX}" y="${padding + 2}">${secondaryMax.toFixed(2)}${units}</text>
              <text class="axis-text" text-anchor="end" x="${rightLabelX}" y="${(height / 2).toFixed(2)}">${secondaryMid.toFixed(2)}${units}</text>
              <text class="axis-text" text-anchor="end" x="${rightLabelX}" y="${height - 2}">${secondaryMin.toFixed(2)}${units}</text>
            ` : ''}
            <path d="${path}"></path>
            ${secondaryPath ? `<path class="series-secondary" d="${secondaryPath}"></path>` : ''}
            <line class="hover-line" x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}"></line>
            <circle class="hover-point" r="1.6" cx="${padding}" cy="${height - padding}"></circle>
            <circle class="hover-point secondary" r="1.6" cx="${padding}" cy="${height - padding}"></circle>
          </svg>
        </div>
      `;
    }

    function wireAdvancedCharts() {
      document.querySelectorAll('.analysis-chart svg[data-values]').forEach(svg => {
        const chart = svg.closest('.analysis-chart');
        const tooltip = chart ? chart.querySelector('.chart-tooltip') : null;
        const values = JSON.parse(svg.getAttribute('data-values') || '[]');
        const secondaryRaw = svg.getAttribute('data-secondary') || '';
        const secondary = secondaryRaw ? JSON.parse(secondaryRaw) : null;
        const padding = Number(svg.getAttribute('data-padding') || 12);
        const min = Number(svg.getAttribute('data-min') || 0);
        const max = Number(svg.getAttribute('data-max') || 1);
        const min2 = Number(svg.getAttribute('data-min2') || 0);
        const max2 = Number(svg.getAttribute('data-max2') || 1);
        const hoverLine = svg.querySelector('.hover-line');
        const hoverPoint = svg.querySelector('.hover-point');
        const hoverPoint2 = svg.querySelector('.hover-point.secondary');
        const width = svg.viewBox.baseVal.width || 180;
        const height = svg.viewBox.baseVal.height || 80;
        const innerW = width - padding * 2;
        const innerH = height - padding * 2;

        const toY = (val, vmin, vmax) => {
          const span = vmax - vmin || 1;
          return padding + innerH - ((val - vmin) / span) * innerH;
        };

        const move = (evt) => {
          if (!values.length) return;
          const rect = svg.getBoundingClientRect();
          const chartRect = chart.getBoundingClientRect();
          const x = evt.clientX - rect.left;
          const leftPadPx = (padding / width) * rect.width;
          const plotWidthPx = ((width - padding * 2) / width) * rect.width;
          const clampedPx = Math.min(leftPadPx + plotWidthPx, Math.max(leftPadPx, x));
          const ratio = plotWidthPx > 0 ? (clampedPx - leftPadPx) / plotWidthPx : 0;
          const idx = Math.round(ratio * (values.length - 1));
          const idxSafe = Math.max(0, Math.min(values.length - 1, idx));
          const val = values[idxSafe];
          const sx = padding + innerW * (idxSafe / (values.length - 1 || 1));
          const sy = toY(val, min, max);

          if (hoverLine) {
            hoverLine.setAttribute('x1', sx);
            hoverLine.setAttribute('x2', sx);
            hoverLine.style.opacity = '1';
          }
          if (hoverPoint) {
            hoverPoint.setAttribute('cx', sx);
            hoverPoint.setAttribute('cy', sy);
            hoverPoint.style.opacity = '1';
          }
          let tooltipText = `#${idxSafe + 1}: ${formatNumber(val, 4)}`;
          if (secondary && secondary.length) {
            const val2 = secondary[idxSafe] ?? 0;
            const sy2 = toY(val2, min2, max2);
            if (hoverPoint2) {
              hoverPoint2.setAttribute('cx', sx);
              hoverPoint2.setAttribute('cy', sy2);
              hoverPoint2.style.opacity = '1';
            }
            tooltipText += ` | ${formatNumber(val2, 2)}`;
          }
          if (tooltip && chart) {
            tooltip.textContent = tooltipText;
            tooltip.style.opacity = '1';
            const leftPx = (rect.left - chartRect.left) + (sx / width) * rect.width;
            const topPx = (rect.top - chartRect.top) + (sy / height) * rect.height;
            tooltip.style.left = `${leftPx}px`;
            tooltip.style.top = `${topPx}px`;
          }
        };

        const leave = () => {
          if (hoverLine) hoverLine.style.opacity = '0';
          if (hoverPoint) hoverPoint.style.opacity = '0';
          if (hoverPoint2) hoverPoint2.style.opacity = '0';
          if (tooltip) tooltip.style.opacity = '0';
        };

        svg.addEventListener('mousemove', move);
        svg.addEventListener('mouseleave', leave);
      });

      document.querySelectorAll('.analysis-chart .chart-zoom').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const block = btn.closest('.analysis-chart-block');
          const grid = block ? block.closest('.analysis-charts-grid') : null;
          if (!block || !grid) return;
          const isExpanded = block.classList.contains('expanded');
          grid.classList.toggle('focus', !isExpanded);
          block.classList.toggle('expanded', !isExpanded);
        });
      });
    }

    function wireAdvancedDetails(detailsMap) {
      document.querySelectorAll('.chart-details').forEach(btn => {
        btn.addEventListener('click', () => {
          const key = btn.getAttribute('data-detail-key') || '';
          const body = document.getElementById('advanced_details_body');
          if (!body) return;
          if (state.advancedDetailsKey === key) {
            state.advancedDetailsKey = '';
            body.innerHTML = `<div class="muted">${t('advanced_details_empty')}</div>`;
            return;
          }
          state.advancedDetailsKey = key;
          body.innerHTML = detailsMap[key] || `<div class="muted">${t('advanced_details_empty')}</div>`;
          body.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
      });
    }


    function renderBarChart(points) {
      const width = 120;
      const height = 60;
      if (!points.length) {
        return `<div class="analysis-chart"><div class="muted">${t('status_no_analysis')}</div></div>`;
      }
      const max = Math.max(...points, 1);
      const barWidth = width / points.length;
      const bars = points.map((val, idx) => {
        const h = (val / max) * (height - 6);
        const x = idx * barWidth;
        const y = height - h - 4;
        return `<rect class="bar" x="${x.toFixed(2)}" y="${y.toFixed(2)}" width="${(barWidth * 0.7).toFixed(2)}" height="${h.toFixed(2)}"></rect>`;
      }).join('');
      return `
        <div class="analysis-chart">
          <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none">
            <line class="axis-line" x1="0" y1="${height - 4}" x2="${width}" y2="${height - 4}"></line>
            ${bars}
          </svg>
        </div>
      `;
    }

    function renderAdvancedAnalysis(data, symbol) {
      const content = document.getElementById('advanced_content');
      if (!data) {
        content.innerHTML = `<div class="muted">${t('status_no_analysis')}</div>`;
        return;
      }
      if (data.error) {
        content.innerHTML = `<div class="muted">${data.error}</div>`;
        return;
      }

      const hourly = Array.isArray(data.hourly_stats) ? data.hourly_stats : [];
      const daily = Array.isArray(data.daily_stats) ? data.daily_stats : [];
      const hourOfDay = Array.isArray(data.hour_of_day_stats) ? data.hour_of_day_stats : [];
      const symbolHourlyRaw = Array.isArray(data.symbol_hourly_stats) ? data.symbol_hourly_stats : [];
      const inventoryBySymbol = data.inventory_by_symbol || {};
      const inventoryBase = symbol && inventoryBySymbol[symbol]
        ? inventoryBySymbol[symbol]
        : {
            hourly: Array.isArray(data.inventory_hourly) ? data.inventory_hourly : [],
            daily: Array.isArray(data.inventory_daily) ? data.inventory_daily : [],
            weekly: Array.isArray(data.inventory_weekly) ? data.inventory_weekly : []
          };
      const inventoryHourly = Array.isArray(inventoryBase.hourly) ? inventoryBase.hourly : [];
      const inventoryDaily = Array.isArray(inventoryBase.daily) ? inventoryBase.daily : [];
      const inventoryWeekly = Array.isArray(inventoryBase.weekly) ? inventoryBase.weekly : [];
      const corr = data.time_correlations || {};

      let html = '';
      let chartsHtml = '';
      let performanceCharts = '';
      let accountCharts = '';
      let inventoryCharts = '';
      const detailsMap = {};

      html += `<h3>${t('advanced_heading_time_correlation')}</h3>`;
      html += '<div class="row">';
      html += `<div class="card"><div class="label">${t('advanced_label_corr_hour_pnl')}</div><div class="value">${formatSigned(corr.corr_hour_of_day_pnl || 0, 3)}</div></div>`;
      html += `<div class="card"><div class="label">${t('advanced_label_corr_tradecount_pnl')}</div><div class="value">${formatSigned(corr.corr_tradecount_pnl || 0, 3)}</div></div>`;
      html += `<div class="card"><div class="label">${t('advanced_label_corr_volume_pnl')}</div><div class="value">${formatSigned(corr.corr_volume_pnl || 0, 3)}</div></div>`;
      html += '</div>';

      performanceCharts += renderChartBlock(
        t('advanced_heading_daily_performance'),
        renderLineChart(
          daily.map(row => Number(row.daily_pnl || 0)),
          { units: '', secondary: daily.map(row => Number(row.daily_volume || 0)),
            primaryLabel: t('advanced_series_primary'), secondaryLabel: t('advanced_series_secondary') }
        ),
        'daily'
      );
      const dailyRows = daily.map(row => `
        <tr>
          <td>${row.date || '-'}</td>
          <td>${row.trade_count || 0}</td>
          <td>${formatNumber(row.daily_volume, 2)}</td>
          <td>${formatSigned(row.daily_pnl || 0, 4)}</td>
          <td>${formatSigned(row.delta_trades || 0, 0)}</td>
          <td>${formatSigned(row.delta_volume || 0, 2)}</td>
          <td>${formatSigned(row.delta_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsMap.daily = renderAdvancedTable(
        [
          t('advanced_label_date'),
          t('advanced_label_trades'),
          t('advanced_label_notional'),
          t('advanced_label_pnl'),
          t('advanced_label_delta_trades'),
          t('advanced_label_delta_notional'),
          t('advanced_label_delta_pnl')
        ],
        dailyRows
      );

      const hourlySlice = hourly.slice(-168);
      performanceCharts += renderChartBlock(
        t('advanced_heading_hourly_performance'),
        renderLineChart(
          hourlySlice.map(row => Number(row.hourly_pnl || 0)),
          { units: '', secondary: hourlySlice.map(row => Number(row.hourly_volume || 0)),
            primaryLabel: t('advanced_series_primary'), secondaryLabel: t('advanced_series_secondary') }
        ),
        'hourly'
      );
      if (hourly.length > hourlySlice.length) {
        html += `<div class="muted">${currentLang === 'zh' ? `仅显示最近 ${hourlySlice.length} 小时` : `Showing last ${hourlySlice.length} hours`}</div>`;
      }
      const hourlyRows = hourlySlice.map(row => `
        <tr>
          <td>${row.hour || '-'}</td>
          <td>${row.trade_count || 0}</td>
          <td>${formatNumber(row.hourly_volume, 2)}</td>
          <td>${formatSigned(row.hourly_pnl || 0, 4)}</td>
          <td>${formatSigned(row.delta_trades || 0, 0)}</td>
          <td>${formatSigned(row.delta_volume || 0, 2)}</td>
          <td>${formatSigned(row.delta_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsMap.hourly = renderAdvancedTable(
        [
          t('advanced_label_hour'),
          t('advanced_label_trades'),
          t('advanced_label_notional'),
          t('advanced_label_pnl'),
          t('advanced_label_delta_trades'),
          t('advanced_label_delta_notional'),
          t('advanced_label_delta_pnl')
        ],
        hourlyRows
      );

      performanceCharts += renderChartBlock(
        t('advanced_heading_hour_of_day'),
        renderLineChart(
          hourOfDay.map(row => Number(row.hour_pnl || 0)),
          { units: '', secondary: hourOfDay.map(row => Number(row.hour_volume || 0)),
            primaryLabel: t('advanced_series_primary'), secondaryLabel: t('advanced_series_secondary') }
        ),
        'hour_of_day'
      );
      const hodRows = hourOfDay.map(row => `
        <tr>
          <td>${row.hour_of_day ?? '-'}</td>
          <td>${row.trade_count || 0}</td>
          <td>${formatNumber(row.hour_volume, 2)}</td>
          <td>${formatSigned(row.hour_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsMap.hour_of_day = renderAdvancedTable(
        [
          t('advanced_label_hour'),
          t('advanced_label_trades'),
          t('advanced_label_notional'),
          t('advanced_label_pnl')
        ],
        hodRows
      );

      html += `<h3>${t('advanced_heading_symbol_hourly')}</h3>`;
      let symbolHourly = symbol ? symbolHourlyRaw.filter(row => row.symbol === symbol) : symbolHourlyRaw;
      const symbolHourlyLimit = 200;
      const symbolHourlySlice = symbolHourly.slice(0, symbolHourlyLimit);
      if (symbolHourly.length > symbolHourlySlice.length) {
        html += `<div class="muted">${currentLang === 'zh' ? `仅显示前 ${symbolHourlySlice.length} 行` : `Showing first ${symbolHourlySlice.length} rows`}</div>`;
      }
      const symbolHourlyRows = symbolHourlySlice.map(row => `
        <tr>
          <td>${row.symbol || '-'}</td>
          <td>${row.hour_of_day ?? '-'}</td>
          <td>${row.buy_count || 0}</td>
          <td>${row.sell_count || 0}</td>
          <td>${formatNumber(row.avg_buy_qty, 4)}</td>
          <td>${formatNumber(row.avg_sell_qty, 4)}</td>
          <td>${formatNumber(row.buy_notional, 2)}</td>
          <td>${formatNumber(row.sell_notional, 2)}</td>
        </tr>
      `);
      detailsMap.symbol_hourly = renderAdvancedTable(
        [
          t('th_symbol'),
          t('advanced_label_hour'),
          t('advanced_label_buy_count'),
          t('advanced_label_sell_count'),
          t('advanced_label_avg_buy_qty'),
          t('advanced_label_avg_sell_qty'),
          t('advanced_label_buy_notional'),
          t('advanced_label_sell_notional')
        ],
        symbolHourlyRows
      );

      const invHourlySlice = inventoryHourly.slice(-168);
      inventoryCharts += renderChartBlock(
        t('advanced_heading_inventory_hourly'),
        renderLineChart(
          invHourlySlice.map(row => Number(row.cumulative_net_qty || 0)),
          { units: '', secondary: invHourlySlice.map(row => Number(row.trade_count || 0)),
            primaryLabel: currentLang === 'zh' ? '净数量' : 'Net Qty', secondaryLabel: t('advanced_series_trades') }
        ),
        'inventory_hourly'
      );
      const invHourlyRows = invHourlySlice.map(row => `
        <tr>
          <td>${row.hour || '-'}</td>
          <td>${formatSigned(row.net_qty || 0, 4)}</td>
          <td>${formatSigned(row.cumulative_net_qty || 0, 4)}</td>
          <td>${row.trade_count || 0}</td>
        </tr>
      `);
      detailsMap.inventory_hourly = renderAdvancedTable(
        [
          t('advanced_label_hour'),
          t('advanced_label_net_qty'),
          t('advanced_label_cum_net_qty'),
          t('advanced_label_trades')
        ],
        invHourlyRows
      );

      const invDailySlice = inventoryDaily.slice(-60);
      inventoryCharts += renderChartBlock(
        t('advanced_heading_inventory_daily'),
        renderLineChart(
          invDailySlice.map(row => Number(row.cumulative_net_qty || 0)),
          { units: '', secondary: invDailySlice.map(row => Number(row.trade_count || 0)),
            primaryLabel: currentLang === 'zh' ? '净数量' : 'Net Qty', secondaryLabel: t('advanced_series_trades') }
        ),
        'inventory_daily'
      );
      const invDailyRows = invDailySlice.map(row => `
        <tr>
          <td>${row.date || '-'}</td>
          <td>${formatSigned(row.net_qty || 0, 4)}</td>
          <td>${formatSigned(row.cumulative_net_qty || 0, 4)}</td>
          <td>${row.trade_count || 0}</td>
        </tr>
      `);
      detailsMap.inventory_daily = renderAdvancedTable(
        [
          t('advanced_label_date'),
          t('advanced_label_net_qty'),
          t('advanced_label_cum_net_qty'),
          t('advanced_label_trades')
        ],
        invDailyRows
      );

      inventoryCharts += renderChartBlock(
        t('advanced_heading_inventory_weekly'),
        renderLineChart(
          inventoryWeekly.map(row => Number(row.cumulative_net_qty || 0)),
          { units: '', secondary: inventoryWeekly.map(row => Number(row.trade_count || 0)),
            primaryLabel: currentLang === 'zh' ? '净数量' : 'Net Qty', secondaryLabel: t('advanced_series_trades') }
        ),
        'inventory_weekly'
      );
      const invWeeklyRows = inventoryWeekly.map(row => `
        <tr>
          <td>${row.week || '-'}</td>
          <td>${formatSigned(row.net_qty || 0, 4)}</td>
          <td>${formatSigned(row.cumulative_net_qty || 0, 4)}</td>
          <td>${row.trade_count || 0}</td>
        </tr>
      `);
      detailsMap.inventory_weekly = renderAdvancedTable(
        [
          t('advanced_label_week'),
          t('advanced_label_net_qty'),
          t('advanced_label_cum_net_qty'),
          t('advanced_label_trades')
        ],
        invWeeklyRows
      );

      html += `<h3>${t('advanced_heading_hourly_balance')}</h3>`;
      const balanceSlice = hourly.slice(-168);
      accountCharts += renderChartBlock(
        t('advanced_heading_hourly_balance'),
        renderLineChart(
          balanceSlice.map(row => Number(row.cumulative_net_pnl || 0)),
          { units: '', secondary: balanceSlice.map(row => Number(row.hourly_volume || 0)),
            primaryLabel: t('advanced_series_primary'), secondaryLabel: t('advanced_series_secondary') }
        ),
        'balance'
      );
      const balanceRows = balanceSlice.map(row => `
        <tr>
          <td>${row.hour || '-'}</td>
          <td>${formatSigned(row.cumulative_net_pnl || 0, 4)}</td>
        </tr>
      `);
      detailsMap.balance = renderAdvancedTable(
        [t('advanced_label_hour'), t('advanced_label_pnl')],
        balanceRows
      );

      chartsHtml += performanceCharts
        ? `<h3>${currentLang === 'zh' ? '交易表现' : 'Performance'}</h3><div class="analysis-charts-grid">${performanceCharts}</div>`
        : '';
      chartsHtml += accountCharts
        ? `<h3>${currentLang === 'zh' ? '账户表现' : 'Account'}</h3><div class="analysis-charts-grid single">${accountCharts}</div>`
        : '';
      chartsHtml += inventoryCharts
        ? `<h3>${currentLang === 'zh' ? '库存变化' : 'Inventory'}</h3><div class="analysis-charts-grid">${inventoryCharts}</div>`
        : '';
      if (chartsHtml) {
        html += chartsHtml;
      }
      html += `
        <h3>${t('advanced_details_title')}</h3>
        <div id="advanced_details_body" class="analysis-summary">
          <div class="muted">${t('advanced_details_empty')}</div>
        </div>
      `;

      content.innerHTML = html || `<div class="muted">${t('status_no_analysis')}</div>`;
      wireAdvancedCharts();
      wireAdvancedDetails(detailsMap);
    }

    async function fetchPositions() {
      try {
        const res = await fetch('/api/positions', { cache: 'no-store' });
        if (!res.ok) {
          document.getElementById('positions_content').innerHTML = `<div class="muted">${currentLang === 'zh' ? '当前模式不支持持仓。' : 'Positions not available in current mode.'}</div>`;
          return;
        }
        const data = await res.json();
        const positions = Array.isArray(data.positions) ? data.positions : [];
        state.positionSymbols = positions.map(p => p.symbol || p.Symbol).filter(Boolean);
        updateSymbolOptions();
        renderPositions(data);
      } catch (e) {
        document.getElementById('positions_content').innerHTML = `<div class="muted">${t('status_positions_error')} ${e.message}</div>`;
      }
    }

    function renderPositions(data) {
      const content = document.getElementById('positions_content');
      let positions = data.positions || [];
      
      // Ensure positions is an array
      if (!Array.isArray(positions)) {
        if (typeof positions === 'object' && positions !== null) {
          positions = Object.values(positions);
        } else {
          positions = [];
        }
      }
      
      if (positions.length === 0) {
        content.innerHTML = `<div class="muted">${t('status_no_positions')}</div>`;
        return;
      }

      const cache = {};
      let html = `<table><thead><tr><th>${t('positions_table_symbol')}</th><th>${t('positions_table_side')}</th><th>${t('positions_table_size')}</th><th>${t('positions_table_avg_price')}</th><th>${t('positions_table_mark_price')}</th><th>${t('positions_table_unrealised')}</th><th>${t('positions_table_realised')}</th><th>${t('positions_table_leverage')}</th><th>${t('positions_table_actions')}</th></tr></thead><tbody>`;
      positions.forEach(pos => {
        const unrealised = getPosValue(pos, ['unrealisedPnl', 'UnrealisedPnl']);
        const realised = getPosValue(pos, ['curRealisedPnl', 'realisedPnl', 'CurRealisedPnl', 'RealisedPnl']);
        const funding = getPosValue(pos, ['fundingFee', 'FundingFee', 'funding', 'Funding']);
        const closed = getPosValue(pos, ['closedPnl', 'ClosedPnl', 'execPnl', 'ExecPnl']);
        const breakEven = getPosValue(pos, ['breakEvenPrice', 'BreakEvenPrice']);
        const realisedTip = buildPnlTooltip({ realised, funding, closed, breakEven });
        const unrealisedClass = pnlClass(unrealised);
        const realisedClass = pnlClass(realised);
        const symbol = pos.symbol || pos.Symbol || '-';
        cache[symbol] = pos;
        html += `<tr>
          <td>${symbol}</td>
          <td>${pos.side || pos.Side || '-'}</td>
          <td>${pos.size || pos.Size || 0}</td>
          <td>${pos.avgPrice || pos.AvgPrice || 0}</td>
          <td>${pos.markPrice || pos.MarkPrice || 0}</td>
          <td class="tooltip-cell ${unrealisedClass}" data-tooltip="${realisedTip.unrealised}">${unrealised || 0}</td>
          <td class="tooltip-cell ${realisedClass}" data-tooltip="${realisedTip.realised}">${realised || 0}</td>
          <td>${pos.leverage || pos.Leverage || '-'}</td>
          <td><button class="position-manage" data-symbol="${symbol}">${t('positions_table_manage')}</button></td>
        </tr>`;
      });
      html += '</tbody></table>';
      content.innerHTML = html;
      state.positionCache = cache;
      content.querySelectorAll('.position-manage').forEach(btn => {
        btn.addEventListener('click', () => openPositionModal(btn.dataset.symbol));
      });
    }

    function renderResilientMaker(metrics) {
      if (!metrics) return;
      setText('rm_inventory', metrics.inventory ?? '-');
      setText('rm_session_pnl', metrics.session_pnl ?? '-');
      setText('rm_realized_pnl', metrics.realized_pnl ?? '-');
      setText('rm_unrealized_pnl', metrics.unrealized_pnl ?? '-');
      setText('rm_fee_total', metrics.fee_total ?? '-');
      setText('rm_funding_total', metrics.funding_fee_total ?? '-');
      const glft = metrics.glft || {};
      document.getElementById('rm_glft').textContent = JSON.stringify(glft, null, 2);
    }

    function setTradeStatus(text, ok) {
      const el = document.getElementById('trade_status');
      if (!el) return;
      el.textContent = text;
      el.style.color = ok ? 'var(--success)' : 'var(--muted)';
    }

    function updateTradingFormState() {
      const ack = document.getElementById('trade_ack').checked;
      const useEnvEl = document.getElementById('trade_use_env');
      const apiKey = document.getElementById('trade_api_key');
      const apiSecret = document.getElementById('trade_api_secret');
      const mode = document.getElementById('trade_mode');
      const demo = document.getElementById('trade_demo');
      const enableBtn = document.getElementById('enable_trading');
      useEnvEl.disabled = !state.tradingHasEnv;
      if (!state.tradingHasEnv && useEnvEl.checked) {
        useEnvEl.checked = false;
      }
      const useEnv = useEnvEl.checked;
      apiKey.disabled = !ack || useEnv;
      apiSecret.disabled = !ack || useEnv;
      mode.disabled = !ack;
      demo.disabled = !ack;
      const hasManualKeys = apiKey.value.trim() && apiSecret.value.trim();
      const canUseEnv = useEnv && state.tradingHasEnv;
      enableBtn.disabled = !ack || (!hasManualKeys && !canUseEnv);
    }

    function syncChartTradingState() {
      const reduceOnly = document.getElementById('chart_reduce_only');
      if (!reduceOnly) return;
      if (state.tradingMode === 'close_only') {
        reduceOnly.checked = true;
        reduceOnly.disabled = true;
      } else {
        reduceOnly.disabled = false;
      }
    }

    function updateChartOrderMode() {
      const mode = document.getElementById('chart_order_mode').value;
      const priceRow = document.getElementById('chart_price_row');
      if (priceRow) {
        priceRow.style.display = mode === 'limit' ? 'block' : 'none';
      }
    }

    async function submitChartOrder(side) {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = getChartSymbol();
      if (!symbol) {
        alert(t('alert_symbol_required'));
        return;
      }
      const qty = parseFloat(document.getElementById('chart_order_qty').value || '0');
      if (!Number.isFinite(qty) || qty <= 0) {
        alert(t('alert_qty_required'));
        return;
      }
      const orderMode = document.getElementById('chart_order_mode').value;
      const reduceOnly = document.getElementById('chart_reduce_only').checked || state.tradingMode === 'close_only';
      let price = null;
      if (orderMode === 'limit') {
        price = parseFloat(document.getElementById('chart_order_price').value || '0');
        if (!Number.isFinite(price) || price <= 0) {
          alert(t('alert_price_required'));
          return;
        }
      }
      try {
        const res = await fetch('/api/orders/create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbol,
            side,
            qty,
            order_mode: orderMode,
            price,
            reduce_only: reduceOnly
          })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_order_failed'));
        }
        fetchOrders('');
        updateOrdersOverlay();
      } catch (e) {
        alert(e.message || t('alert_order_failed'));
      }
    }

    function openPositionModal(symbol) {
      const pos = state.positionCache[symbol];
      if (!pos) {
        alert(t('alert_position_missing'));
        return;
      }
      state.activePositionSymbol = symbol;
      setText('position_modal_symbol', symbol);
      setText('position_modal_side', pos.side || pos.Side || '-');
      setText('position_modal_qty', pos.size || pos.Size || '-');
      document.getElementById('position_tp').value = '';
      document.getElementById('position_sl').value = '';
      document.getElementById('position_modal').classList.add('active');
    }

    async function submitPositionClose() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      try {
        const res = await fetch('/api/positions/close', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
        fetchPositions();
        fetchOrders('');
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function submitPositionTpSl() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      const tp = parseFloat(document.getElementById('position_tp').value || '');
      const sl = parseFloat(document.getElementById('position_sl').value || '');
      const hasTp = Number.isFinite(tp) && tp > 0;
      const hasSl = Number.isFinite(sl) && sl > 0;
      if (!hasTp && !hasSl) {
        alert(t('alert_tpsl_required'));
        return;
      }
      try {
        const res = await fetch('/api/positions/tpsl', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbol,
            take_profit: hasTp ? tp : null,
            stop_loss: hasSl ? sl : null
          })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function submitSmartTp() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      try {
        const res = await fetch('/api/positions/smart-tp', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
        fetchOrders('');
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function submitSmartSl() {
      if (!state.tradingEnabled) {
        alert(t('alert_trading_disabled'));
        return;
      }
      const symbol = state.activePositionSymbol;
      if (!symbol) return;
      try {
        const res = await fetch('/api/positions/smart-sl', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_action_failed'));
        }
        fetchOrders('');
      } catch (e) {
        alert(e.message || t('alert_action_failed'));
      }
    }

    async function loadTradingStatus() {
      try {
        const res = await fetch('/api/trading/status', { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        if (data.enabled) {
          state.tradingEnabled = true;
          state.tradingMode = data.mode || '';
          state.tradingHasEnv = !!data.has_env;
          setTradeStatus(`${t('status_trading_enabled')} (${state.tradingMode.replace('_', '/')} ${currentLang === 'zh' ? '模式' : 'mode'}).`, true);
          document.getElementById('open_trading_modal').textContent = t('status_trading_enabled');
          ensureOrdersLoaded();
        } else {
          state.tradingEnabled = false;
          state.tradingMode = '';
          state.tradingHasEnv = !!data.has_env;
          setTradeStatus(t('status_trading_disabled'), false);
          document.getElementById('open_trading_modal').textContent = t('button_enable_trading');
          if (state.tradingHasEnv) {
            ensureOrdersLoaded();
          }
        }
        updateTradingFormState();
        syncChartTradingState();
      } catch (e) {}
    }

    async function enableTrading() {
      const apiKey = document.getElementById('trade_api_key').value.trim();
      const apiSecret = document.getElementById('trade_api_secret').value.trim();
      const mode = document.getElementById('trade_mode').value;
      const ack = document.getElementById('trade_ack').checked;
      const useEnv = document.getElementById('trade_use_env').checked;
      const demo = document.getElementById('trade_demo').checked;

      if (!ack) {
        alert(t('alert_ack_risk'));
        return;
      }
      if (!useEnv && (!apiKey || !apiSecret)) {
        alert(t('alert_keys_required'));
        return;
      }
      if (useEnv && !state.tradingHasEnv) {
        alert(t('alert_no_env'));
        return;
      }

      try {
        const res = await fetch('/api/trading/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ api_key: apiKey, api_secret: apiSecret, mode, use_env: useEnv, demo })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_enable_failed'));
        }
        state.tradingEnabled = true;
        state.tradingMode = mode;
        document.getElementById('trade_api_key').value = '';
        document.getElementById('trade_api_secret').value = '';
        document.getElementById('trade_ack').checked = false;
        document.getElementById('trade_use_env').checked = false;
        document.getElementById('trade_demo').checked = false;
        setTradeStatus(`${t('status_trading_enabled')} (${mode.replace('_', '/')} ${currentLang === 'zh' ? '模式' : 'mode'}).`, true);
        updateTradingFormState();
        fetchOrders('');
        document.getElementById('trading_modal').classList.remove('active');
      } catch (e) {
        setTradeStatus(t('status_trading_disabled'), false);
        alert(e.message || t('alert_enable_failed'));
      }
    }

    async function disableTrading() {
      try {
        const res = await fetch('/api/trading/disable', { method: 'POST' });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || t('alert_disable_failed'));
        }
        state.tradingEnabled = false;
        state.tradingMode = '';
        setTradeStatus(t('status_trading_disabled'), false);
        document.getElementById('open_trading_modal').textContent = t('button_enable_trading');
        state.ordersLoaded = false;
      } catch (e) {
        alert(e.message || t('alert_disable_failed'));
      }
    }

    function ensureOrdersLoaded() {
      if (state.ordersLoaded) return;
      fetchOrders('');
    }

    async function fetchOrders(symbolOverride = '') {
      const content = document.getElementById('orders_content');
      try {
        const symbol = symbolOverride || '';
        const res = await fetch('/api/orders/list', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || (currentLang === 'zh' ? '获取订单失败。' : 'Failed to fetch orders.'));
        }
        state.ordersCache = Array.isArray(data.orders) ? data.orders : [];
        state.ordersCacheSymbol = symbol ? symbol : 'all';
        state.ordersLoaded = true;
        renderOrders(data.orders || []);
        updateOrdersOverlay();
      } catch (e) {
        content.innerHTML = `<div class="muted">${t('status_orders_error')} ${e.message}</div>`;
      }
    }

    function renderOrders(orders) {
      const content = document.getElementById('orders_content');
      if (!Array.isArray(orders) || orders.length === 0) {
        content.innerHTML = `<div class="muted">${t('status_no_orders')}</div>`;
        return;
      }
      let html = `<table><thead><tr><th>${t('orders_table_symbol')}</th><th>${t('orders_table_side')}</th><th>${t('orders_table_type')}</th><th>${t('orders_table_qty')}</th><th>${t('orders_table_price')}</th><th>${t('orders_table_status')}</th><th>${t('orders_table_action')}</th></tr></thead><tbody>`;
      orders.forEach(order => {
        const orderId = order.orderId || order.orderID || '';
        const symbol = order.symbol || order.Symbol || '-';
        html += `<tr>
          <td>${symbol}</td>
          <td>${order.side || '-'}</td>
          <td>${order.orderType || order.type || '-'}</td>
          <td>${order.qty || order.leavesQty || 0}</td>
          <td>${order.price || order.avgPrice || 0}</td>
          <td>${order.orderStatus || order.status || '-'}</td>
          <td><button data-order-id="${orderId}" data-symbol="${symbol}" class="cancel-order">${t('orders_cancel')}</button></td>
        </tr>`;
      });
      html += '</tbody></table>';
      content.innerHTML = html;
      content.querySelectorAll('.cancel-order').forEach(btn => {
        btn.addEventListener('click', () => cancelOrder(btn.dataset.orderId, btn.dataset.symbol));
      });
    }

    async function cancelOrder(orderId, symbol) {
      if (!orderId || !symbol) {
        alert(t('alert_missing_order'));
        return;
      }
      if (!state.tradingEnabled) {
        alert(t('alert_trading_required'));
        return;
      }
      if (!confirm(`${t('alert_cancel_confirm')} ${orderId}?`)) return;
      try {
        const res = await fetch('/api/orders/cancel', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ order_id: orderId, symbol })
        });
        const data = await res.json();
        if (!res.ok || data.error) {
          throw new Error(data.error || 'Cancel failed.');
        }
        fetchOrders();
      } catch (e) {
        alert(e.message || t('alert_cancel_failed'));
      }
    }

    function updateOrdersOverlay() {
      const overlaySeries = getActivePriceSeries();
      if (!overlaySeries) return;
      const showOrders = document.getElementById('chart_show_orders').checked;
      if (!showOrders) {
        removeSeriesLines(chartOrderLines);
        state.chartOrderSignature = '';
        return;
      }
      const symbol = getChartSymbol();
      if (!symbol) return;
      if (state.ordersCacheSymbol && state.ordersCacheSymbol !== 'all' && state.ordersCacheSymbol !== symbol) {
        return;
      }
      const orders = state.ordersCache.filter(o => (o.symbol || o.Symbol) === symbol);
      const orderSignature = orders.map(o => `${o.orderId || o.orderID || ''}:${o.price || o.avgPrice || ''}:${o.side || ''}`).join('|');
      if (orderSignature === state.chartOrderSignature) return;
      removeSeriesLines(chartOrderLines);
      orders.forEach(order => {
        const price = parseFloat(order.price || order.avgPrice || '');
        if (!Number.isFinite(price) || price <= 0) return;
        const side = String(order.side || '').toLowerCase();
        const isBuy = side.startsWith('b');
        const line = overlaySeries.createPriceLine({
          price,
          color: isBuy ? '#27d07d' : '#ff6b6b',
          lineWidth: 1,
          lineStyle: 1,
          axisLabelVisible: true,
          title: isBuy ? t('chart_order_buy') : t('chart_order_sell'),
        });
        chartOrderLines.push({ series: overlaySeries, line });
      });
      state.chartOrderSignature = orderSignature;
    }

    function getPosValue(pos, keys) {
      for (const key of keys) {
        const val = pos[key];
        if (val !== undefined && val !== null && val !== '') {
          return val;
        }
      }
      return 0;
    }

    function buildPnlTooltip(values) {
      const realisedLines = [];
      const unrealisedLines = [];
      if (values.realised !== undefined && values.realised !== null && values.realised !== 0) {
        realisedLines.push(`${t('tooltip_current_realised')}: ${values.realised}`);
      }
      if (values.funding !== undefined && values.funding !== null && values.funding !== 0) {
        realisedLines.push(`${t('tooltip_funding')}: ${values.funding}`);
      }
      if (values.closed !== undefined && values.closed !== null && values.closed !== 0) {
        realisedLines.push(`${t('tooltip_closed_pnl')}: ${values.closed}`);
      }
      if (values.breakEven !== undefined && values.breakEven !== null && values.breakEven !== 0) {
        unrealisedLines.push(`${t('tooltip_break_even')}: ${values.breakEven}`);
      }
      return {
        unrealised: unrealisedLines.length ? unrealisedLines.join(' | ') : t('tooltip_unrealised_pnl'),
        realised: realisedLines.length ? realisedLines.join(' | ') : t('tooltip_realised_pnl')
      };
    }

    function pnlClass(value) {
      const num = Number(value);
      if (!Number.isFinite(num) || num === 0) return '';
      return num > 0 ? 'pnl-positive' : 'pnl-negative';
    }

    function getChartSymbol() {
      const dropdown = document.getElementById('chart_symbol');
      if (dropdown && dropdown.value) return dropdown.value;
      if (state.metricsSymbols.includes('ETHUSDT')) return 'ETHUSDT';
      const first = state.metricsSymbols[0];
      return first || '';
    }

    function initChart() {
      const container = document.getElementById('chart_container');
      if (!container || !window.LightweightCharts) return;
      if (chart) return;
      if (container.clientWidth === 0 || container.clientHeight === 0) {
        if (state.chartVisible) setTimeout(initChart, 120);
        return;
      }
      chart = LightweightCharts.createChart(container, {
        layout: {
          background: { color: 'transparent' },
          textColor: '#d6e1f0',
          fontFamily: '"Inter", "SF Pro Text", "Segoe UI", system-ui, -apple-system, sans-serif'
        },
        grid: {
          vertLines: { color: 'rgba(91, 110, 140, 0.18)' },
          horzLines: { color: 'rgba(91, 110, 140, 0.18)' }
        },
        rightPriceScale: {
          borderVisible: false,
          scaleMargins: { top: 0.18, bottom: 0.2 },
          ticksVisible: true
        },
        timeScale: {
          borderVisible: false,
          timeVisible: true,
          rightOffset: 6,
          barSpacing: 12,
          tickMarkFormatter: getOptionsChartTickMarkFormatter()
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Magnet,
          vertLine: { color: 'rgba(124, 196, 255, 0.35)', width: 1, style: 1 },
          horzLine: { color: 'rgba(124, 196, 255, 0.35)', width: 1, style: 1 },
        },
        localization: {
          locale: currentLang === 'zh' ? 'zh-CN' : 'en-US',
          timeFormatter: getOptionsChartTimeFormatter()
        }
      });
      applyChartLocalization();
      candleSeries = chart.addCandlestickSeries({
        upColor: '#27d07d',
        downColor: '#ff6b6b',
        borderVisible: false,
        wickUpColor: '#35f49b',
        wickDownColor: '#ff7b7b',
        priceLineColor: 'rgba(124, 196, 255, 0.6)',
        priceLineWidth: 1,
      });
      tickSeries = chart.addLineSeries({
        color: '#7cc4ff',
        lineWidth: 2,
        crosshairMarkerVisible: true,
        priceLineVisible: true,
        lastValueVisible: true,
      });
      if (window.LightweightCharts && window.LightweightCharts.LineType) {
        tickSeries.applyOptions({ lineType: window.LightweightCharts.LineType.Simple });
      }
      tickSeries.applyOptions({ visible: false });
      volumeSeries = chart.addHistogramSeries({
        color: '#3a465e',
        priceFormat: { type: 'volume' },
        priceScaleId: '',
        lastValueVisible: false,
      });
      if (volumeSeries) {
        volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.85, bottom: 0 } });
      }
      chartLegendEl = document.getElementById('chartLegend');
      updateLegendFromLatest();
      chart.subscribeCrosshairMove(param => {
        if (!param || param.time === undefined) {
          updateLegendFromLatest();
          return;
        }
        const candle = param.seriesData.get(candleSeries);
        if (candle && candle.time) {
          const candles = streamCandles.length ? streamCandles : chartKlinesCache;
          const idx = candles.findIndex(c => c.time === candle.time);
          updateLegend(candle, idx >= 0 ? idx : candles.length - 1);
          return;
        }
        const tick = param.seriesData.get(tickSeries);
        if (tick && tick.time) {
          updateLegend({
            time: tick.time,
            open: tick.value,
            high: tick.value,
            low: tick.value,
            close: tick.value,
            volume: 0,
          }, 0);
        }
      });
      chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
        renderDrawings();
      });
      window.addEventListener('resize', () => {
        applyChartSize();
      });
      applyChartSize();
    }

    function resizeChart() {
      applyChartSize();
    }

    function applyChartSize() {
      const container = document.getElementById('chart_container');
      if (!container || !chart) return;
      const width = container.clientWidth;
      const height = Math.max(240, container.clientHeight);
      chart.applyOptions({ width, height });
      renderDrawings();
    }

    function setDrawMode(mode) {
      drawMode = mode;
      const svg = document.getElementById('chart_drawings');
      if (svg) {
        svg.classList.toggle('active', Boolean(drawMode));
      }
    }

    function getRelativePoint(event) {
      const svg = document.getElementById('chart_drawings');
      if (!svg) return null;
      const rect = svg.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
      return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
    }

    function renderDrawings() {
      const svg = document.getElementById('chart_drawings');
      if (!svg) return;
      const width = svg.clientWidth || svg.getBoundingClientRect().width || 1;
      const height = svg.clientHeight || svg.getBoundingClientRect().height || 1;
      svg.innerHTML = '';
      const renderRect = (x, y, w, h, className) => {
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return;
        if (w <= 0 || h <= 0) return;
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', x.toFixed(2));
        rect.setAttribute('y', y.toFixed(2));
        rect.setAttribute('width', w.toFixed(2));
        rect.setAttribute('height', h.toFixed(2));
        rect.setAttribute('class', className);
        svg.appendChild(rect);
      };
      for (const item of drawings) {
        if (item.type !== 'box') continue;
        const x = Math.min(item.x1, item.x2) * width;
        const y = Math.min(item.y1, item.y2) * height;
        const w = Math.abs(item.x2 - item.x1) * width;
        const h = Math.abs(item.y2 - item.y1) * height;
        renderRect(x, y, w, h, 'chart-drawing-rect');
      }
      if (chart && candleSeries) {
        // reserved for future strategy drawings
      }
      if (drawTempRect) {
        svg.appendChild(drawTempRect);
      }
    }

    function startDraw(event) {
      if (!drawMode) return;
      const point = getRelativePoint(event);
      if (!point) return;
      drawStart = point;
      const svg = document.getElementById('chart_drawings');
      if (!svg) return;
      if (event.pointerId != null && svg.setPointerCapture) {
        svg.setPointerCapture(event.pointerId);
      }
      drawTempRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      drawTempRect.setAttribute('class', 'chart-drawing-rect');
      svg.appendChild(drawTempRect);
      updateDraw(event);
    }

    function updateDraw(event) {
      if (!drawMode || !drawStart || !drawTempRect) return;
      const point = getRelativePoint(event);
      if (!point) return;
      const svg = document.getElementById('chart_drawings');
      if (!svg) return;
      const width = svg.clientWidth || svg.getBoundingClientRect().width || 1;
      const height = svg.clientHeight || svg.getBoundingClientRect().height || 1;
      const x = Math.min(drawStart.x, point.x) * width;
      const y = Math.min(drawStart.y, point.y) * height;
      const w = Math.abs(point.x - drawStart.x) * width;
      const h = Math.abs(point.y - drawStart.y) * height;
      drawTempRect.setAttribute('x', x.toFixed(2));
      drawTempRect.setAttribute('y', y.toFixed(2));
      drawTempRect.setAttribute('width', w.toFixed(2));
      drawTempRect.setAttribute('height', h.toFixed(2));
    }

    function endDraw(event) {
      if (!drawMode || !drawStart || !drawTempRect) return;
      const point = getRelativePoint(event);
      if (!point) return;
      const svg = document.getElementById('chart_drawings');
      if (event.pointerId != null && svg && svg.releasePointerCapture) {
        svg.releasePointerCapture(event.pointerId);
      }
      drawings.push({ type: 'box', x1: drawStart.x, y1: drawStart.y, x2: point.x, y2: point.y });
      drawStart = null;
      drawTempRect = null;
      renderDrawings();
    }


    function ensureChartReady() {
      if (!state.chartVisible) return;
      const container = document.getElementById('chart_container');
      if (!container) return;
      if (!window.LightweightCharts) {
        const status = document.getElementById('chart_status');
        if (status) {
          status.textContent = currentLang === 'zh' ? '正在加载图表库...' : 'Loading chart library...';
        }
        if (chartInitAttempts < 12) {
          chartInitAttempts += 1;
          setTimeout(ensureChartReady, 200);
        }
        return;
      }
      initChart();
      if (!chart || container.clientWidth === 0 || container.clientHeight === 0) {
        if (chartInitAttempts < 12) {
          chartInitAttempts += 1;
          setTimeout(ensureChartReady, 120);
        }
        return;
      }
      chartInitAttempts = 0;
      resizeChart();
      fetchKlines();
      startChartPolling();
      requestOverlayUpdate();
    }

    function getOptionsChartSymbol() {
      const select = document.getElementById('options_chart_symbol');
      return select ? (select.value || '').trim().toUpperCase() : '';
    }

    function normalizeOptionType(value) {
      const raw = String(value || '').trim().toUpperCase();
      if (!raw) return '';
      if (raw.startsWith('C')) return 'Call';
      if (raw.startsWith('P')) return 'Put';
      return raw.charAt(0) + raw.slice(1).toLowerCase();
    }

    function normalizeExpiryLabel(value) {
      if (!value) return '';
      const raw = String(value);
      if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;
      return raw.toUpperCase();
    }

    function compareExpiry(a, b) {
      const da = Date.parse(a);
      const db = Date.parse(b);
      if (!Number.isNaN(da) && !Number.isNaN(db)) return da - db;
      return String(a).localeCompare(String(b));
    }

    function updateOptionsSymbolOptions() {
      const symbolSelect = document.getElementById('options_chart_symbol');
      const expirySelect = document.getElementById('options_chart_expiry');
      const typeSelect = document.getElementById('options_chart_type');
      if (!symbolSelect || !expirySelect || !typeSelect) return;
      const expiry = expirySelect.value || 'all';
      const type = typeSelect.value || 'all';
      const filtered = optionsInstruments.filter(item => {
        if (expiry !== 'all' && item.expiry !== expiry) return false;
        if (type !== 'all' && item.optionType !== type) return false;
        return true;
      });
      symbolSelect.innerHTML = filtered.map(item => `<option value="${item.symbol}">${item.symbol}</option>`).join('');
      if (!filtered.length) {
        symbolSelect.innerHTML = `<option value="">--</option>`;
        return;
      }
      if (!filtered.some(item => item.symbol === symbolSelect.value)) {
        symbolSelect.value = filtered[0].symbol;
      }
    }

    function rebuildOptionsFilters() {
      const expirySelect = document.getElementById('options_chart_expiry');
      const typeSelect = document.getElementById('options_chart_type');
      if (!expirySelect || !typeSelect) return;
      const expiries = Array.from(new Set(optionsInstruments.map(item => item.expiry).filter(Boolean))).sort(compareExpiry);
      const types = Array.from(new Set(optionsInstruments.map(item => item.optionType).filter(Boolean))).sort();
      expirySelect.innerHTML = ['<option value="all">ALL</option>']
        .concat(expiries.map(exp => `<option value="${exp}">${exp}</option>`))
        .join('');
      typeSelect.innerHTML = ['<option value="all">ALL</option>']
        .concat(types.map(type => `<option value="${type}">${type}</option>`))
        .join('');
      updateOptionsSymbolOptions();
    }

    async function loadOptionsInstruments() {
      if (optionsInstrumentsLoaded) return;
      optionsInstrumentsLoaded = true;
      const note = document.getElementById('options_chart_note');
      if (note) note.textContent = t('options_chart_loading');
      try {
        const res = await fetch('/api/options/instruments', { cache: 'no-store' });
        if (!res.ok) throw new Error('instrument fetch failed');
        const data = await res.json();
        const list = Array.isArray(data.instruments) ? data.instruments : [];
        optionsInstruments = list.map(item => ({
          symbol: String(item.symbol || '').toUpperCase(),
          expiry: normalizeExpiryLabel(item.expiry || ''),
          optionType: normalizeOptionType(item.optionType || item.optionsType || ''),
        })).filter(item => item.symbol);
        rebuildOptionsFilters();
        if (note) note.textContent = t('options_chart_hint');
      } catch (err) {
        optionsInstrumentsLoaded = false;
        if (note) note.textContent = t('options_chart_load_failed');
      }
    }

    function initOptionsChart() {
      const container = document.getElementById('options_chart_container');
      if (!container || !window.LightweightCharts) return;
      if (optionsChart) return;
      if (container.clientWidth === 0 || container.clientHeight === 0) {
        if (state.optionsChartVisible) setTimeout(initOptionsChart, 120);
        return;
      }
      optionsChart = LightweightCharts.createChart(container, {
        layout: {
          background: { color: 'transparent' },
          textColor: '#d6e1f0',
          fontFamily: '"Inter", "SF Pro Text", "Segoe UI", system-ui, -apple-system, sans-serif'
        },
        grid: {
          vertLines: { color: 'rgba(91, 110, 140, 0.18)' },
          horzLines: { color: 'rgba(91, 110, 140, 0.18)' }
        },
        leftPriceScale: {
          visible: true,
          borderVisible: false,
        },
        rightPriceScale: {
          borderVisible: false,
          scaleMargins: { top: 0.18, bottom: 0.2 },
          ticksVisible: true
        },
        timeScale: {
          borderVisible: false,
          timeVisible: true,
          rightOffset: 6,
          barSpacing: 12,
          tickMarkFormatter: getChartTickMarkFormatter()
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Magnet,
          vertLine: { color: 'rgba(124, 196, 255, 0.35)', width: 1, style: 1 },
          horzLine: { color: 'rgba(124, 196, 255, 0.35)', width: 1, style: 1 },
        },
        localization: {
          locale: currentLang === 'zh' ? 'zh-CN' : 'en-US',
          timeFormatter: getChartTimeFormatter()
        }
      });
      optionsMarkSeries = optionsChart.addCandlestickSeries({
        upColor: '#27d07d',
        downColor: '#ff6b6b',
        borderVisible: false,
        wickUpColor: '#35f49b',
        wickDownColor: '#ff7b7b',
        priceLineColor: 'rgba(124, 196, 255, 0.6)',
        priceLineWidth: 1,
      });
      optionsChartLegendEl = document.getElementById('optionsChartLegend');
      optionsChart.subscribeCrosshairMove(param => {
        if (!param || param.time === undefined) {
          updateOptionsLegendFromLatest();
          return;
        }
        const point = param.seriesData.get(optionsMarkSeries);
        if (point && point.time) {
          updateOptionsLegendFromLatest(point.time);
        }
      });
      window.addEventListener('resize', () => {
        applyOptionsChartSize();
      });
      applyOptionsChartSize();
    }

    function applyOptionsChartSize() {
      const container = document.getElementById('options_chart_container');
      if (!container || !optionsChart) return;
      const width = container.clientWidth;
      const height = Math.max(240, container.clientHeight);
      optionsChart.applyOptions({ width, height });
    }

    function resizeOptionsChart() {
      applyOptionsChartSize();
    }

    function findOptionsSeriesValue(metric, time) {
      const data = optionsSeriesData[metric] || [];
      if (!data.length) return null;
      if (time) {
        const match = data.find(point => point.time === time);
        if (match) return match.value ?? match.close ?? null;
      }
      const last = data[data.length - 1];
      return last?.value ?? last?.close ?? null;
    }

    function formatIv(value) {
      if (value === null || value === undefined || !Number.isFinite(value)) return '-';
      return `${value.toFixed(2)}%`;
    }

    function formatDelta(value) {
      if (value === null || value === undefined || !Number.isFinite(value)) return '-';
      return value.toFixed(4);
    }

    function formatVega(value) {
      if (value === null || value === undefined || !Number.isFinite(value)) return '-';
      return value.toFixed(4);
    }

    function updateOptionsLegendFromLatest(atTime = null) {
      const legend = optionsChartLegendEl || document.getElementById('optionsChartLegend');
      if (!legend) return;
      if (!optionsChartLegendEl) optionsChartLegendEl = legend;
      const markVal = findOptionsSeriesValue('mark', atTime);
      const ivVal = optionsMetricsEnabled.iv ? findOptionsSeriesValue('iv', atTime) : null;
      const deltaVal = optionsMetricsEnabled.delta ? findOptionsSeriesValue('delta', atTime) : null;
      const vegaVal = optionsMetricsEnabled.vega ? findOptionsSeriesValue('vega', atTime) : null;
      const markSeries = optionsSeriesData.mark || [];
      const timeValue = atTime || (markSeries.length ? markSeries[markSeries.length - 1].time : null);
      const timeLabel = timeValue ? new Date(timeValue * 1000).toLocaleString() : '-';
      legend.innerHTML = `
        <div class="legend-row">
          <span class="legend-label">Mark</span><span class="legend-value">${formatPrice(markVal)}</span>
          <span class="legend-label">IV</span><span class="legend-value">${formatIv(ivVal)}</span>
          <span class="legend-label">Δ</span><span class="legend-value">${formatDelta(deltaVal)}</span>
          <span class="legend-label">Vega</span><span class="legend-value">${formatVega(vegaVal)}</span>
        </div>
        <div class="legend-row">
          <span class="legend-label legend-time">${timeLabel}</span>
        </div>
      `;
    }

    function setOptionsStaleBadge(isStale) {
      const badge = document.getElementById('options_chart_stale');
      if (!badge) return;
      badge.classList.toggle('active', Boolean(isStale));
    }

    function updateOptionsSnapshotUI(snapshot) {
      const asofEl = document.getElementById('options_chart_asof');
      if (asofEl) {
        const ts = snapshot?.asof_ms ? new Date(snapshot.asof_ms) : null;
        asofEl.textContent = ts ? ts.toLocaleString() : '--';
      }
      setOptionsStaleBadge(snapshot?.stale);
    }

    function getOptionsSeries(metric) {
      if (!optionsChart) return null;
      if (metric === 'mark') return optionsMarkSeries;
      if (optionsOverlaySeries.has(metric)) return optionsOverlaySeries.get(metric);
      const colors = {
        iv: '#f4d35e',
        delta: '#a0b3ff',
        vega: '#ff8f4d',
      };
      const priceFormat = metric === 'iv'
        ? { type: 'custom', formatter: (value) => `${value.toFixed(2)}%` }
        : { type: 'price', precision: 4, minMove: 0.0001 };
      const series = optionsChart.addLineSeries({
        color: colors[metric] || '#d7dee8',
        lineWidth: 2,
        priceLineVisible: false,
        lastValueVisible: false,
        priceScaleId: 'left',
        priceFormat,
      });
      optionsOverlaySeries.set(metric, series);
      return series;
    }

    function clearOptionsSeries(metric) {
      const series = optionsOverlaySeries.get(metric);
      if (series && optionsChart) {
        optionsChart.removeSeries(series);
      }
      optionsOverlaySeries.delete(metric);
      optionsSeriesData[metric] = [];
    }

    function setOptionsMetricEnabled(metric, enabled) {
      optionsMetricsEnabled[metric] = enabled;
      if (!enabled) {
        clearOptionsSeries(metric);
        updateOptionsLegendFromLatest();
        return;
      }
      getOptionsSeries(metric);
      refreshOptionsChart();
    }

    async function fetchOptionsSnapshot() {
      const symbol = getOptionsChartSymbol();
      const note = document.getElementById('options_chart_note');
      if (note) note.textContent = '';
      if (!symbol) {
        if (note) note.textContent = t('options_chart_hint');
        setOptionsStaleBadge(false);
        return null;
      }
      const res = await fetch(`/api/options/snapshot?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
      if (!res.ok) {
        const fallback = { stale: true, asof_ms: Date.now() };
        updateOptionsSnapshotUI(fallback);
        return fallback;
      }
      const data = await res.json();
      optionsSnapshot = data;
      updateOptionsSnapshotUI(data);
      return data;
    }

    async function fetchOptionsTimeseries(metric) {
      const symbol = getOptionsChartSymbol();
      if (!symbol) return;
      const interval = document.getElementById('options_chart_interval')?.value || '1';
      const isIntervalChange = symbol !== optionsChartLastSymbol || interval !== optionsChartLastInterval;
      if (isIntervalChange) {
        optionsChartHasLoaded = false;
      }
      const qs = new URLSearchParams({ symbol, metric });
      const res = await fetch(`/api/options/timeseries?${qs.toString()}`, { cache: 'no-store' });
      if (!res.ok) return;
      const data = await res.json();
      if (!data || data.ok === false) return;
      if (metric === 'mark' && Array.isArray(data.bars)) {
        const candles = data.bars.map(row => {
          const ts = Number(row[0]);
          const open = Number(row[1]);
          const high = Number(row[2]);
          const low = Number(row[3]);
          const close = Number(row[4]);
          const time = Math.floor(ts / 1000);
          if (!Number.isFinite(time) || !Number.isFinite(open) || !Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(close)) {
            return null;
          }
          return { time, open, high, low, close };
        }).filter(Boolean);
        optionsCandlesData = candles;
        optionsSeriesData.mark = candles.map(candle => ({ time: candle.time, value: candle.close }));
        const series = getOptionsSeries(metric);
        if (series) series.setData(candles);
        if (optionsChart && !optionsChartHasLoaded && candles.length) {
          optionsChart.timeScale().fitContent();
          optionsChartHasLoaded = true;
          optionsChartLastSymbol = symbol;
          optionsChartLastInterval = interval;
        }
        return;
      }
      if (!Array.isArray(data.points)) return;
      const bucketSeconds = getIntervalSeconds(interval);
      const bucketMs = bucketSeconds ? bucketSeconds * 1000 : 0;
      let pointPairs = data.points;
      if (bucketMs) {
        const buckets = new Map();
        for (const [ts, value] of data.points) {
          const tsNum = Number(ts);
          if (!Number.isFinite(tsNum)) continue;
          const bucket = Math.floor(tsNum / bucketMs) * bucketMs;
          buckets.set(bucket, value);
        }
        pointPairs = Array.from(buckets.entries()).sort((a, b) => a[0] - b[0]);
      }
      const points = pointPairs.map(([ts, value]) => {
        const time = Math.floor(Number(ts) / 1000);
        const val = metric === 'iv' ? Number(value) * 100 : Number(value);
        return Number.isFinite(time) && Number.isFinite(val) ? { time, value: val } : null;
      }).filter(Boolean);
      optionsSeriesData[metric] = points;
      const series = getOptionsSeries(metric);
      if (series) series.setData(points);
      if (metric === 'mark' && optionsChart && !optionsChartHasLoaded && points.length) {
        optionsChart.timeScale().fitContent();
        optionsChartHasLoaded = true;
        optionsChartLastSymbol = symbol;
        optionsChartLastInterval = interval;
      }
    }

    async function refreshOptionsChart() {
      if (optionsChartRefreshing) return;
      optionsChartRefreshing = true;
      try {
        await fetchOptionsSnapshot();
        await fetchOptionsTimeseries('mark');
        const overlays = ['iv', 'delta', 'vega'];
        for (const metric of overlays) {
          if (optionsMetricsEnabled[metric]) {
            await fetchOptionsTimeseries(metric);
          }
        }
        updateOptionsLegendFromLatest();
      } catch (err) {
        setOptionsStaleBadge(true);
      } finally {
        optionsChartRefreshing = false;
      }
    }

    function startOptionsChartPolling() {
      if (optionsChartTimer) {
        clearInterval(optionsChartTimer);
        optionsChartTimer = null;
      }
      const auto = document.getElementById('options_chart_auto')?.checked;
      if (!auto) return;
      const refresh = parseInt(document.getElementById('options_chart_refresh')?.value || '5000', 10);
      optionsChartTimer = setInterval(refreshOptionsChart, isNaN(refresh) ? 5000 : refresh);
    }

    function setOptionsOrderbookStale(isStale) {
      const badge = document.getElementById('options_orderbook_stale');
      if (!badge) return;
      badge.classList.toggle('active', Boolean(isStale));
    }

    function updateOptionsOrderbookAsOf(ts) {
      const el = document.getElementById('options_orderbook_asof');
      if (!el) return;
      if (!ts) {
        el.textContent = '--';
        return;
      }
      el.textContent = new Date(ts).toLocaleString();
    }

    function formatOrderbookValue(value, decimals = 4) {
      if (value === null || value === undefined || !Number.isFinite(value)) return '-';
      return Number(value).toFixed(decimals);
    }

    function renderOrderbookSide(rows, side) {
      const container = document.getElementById(side === 'ask' ? 'options_orderbook_asks' : 'options_orderbook_bids');
      if (!container) return;
      if (!rows.length) {
        container.innerHTML = '';
        return;
      }
      const maxCum = rows[rows.length - 1].cum || 1;
      container.innerHTML = rows.map(row => {
        const fill = Math.min(100, (row.cum / maxCum) * 100);
        return `
          <div class="orderbook-row ${side}" style="--ob-fill:${fill.toFixed(2)}%;">
            <span class="ob-price">${formatOrderbookValue(row.price, row.priceDecimals)}</span>
            <span class="ob-size">${formatOrderbookValue(row.size, row.sizeDecimals)}</span>
            <span class="ob-total">${formatOrderbookValue(row.cum, row.sizeDecimals)}</span>
          </div>
        `;
      }).join('');
    }

    function buildOrderbookRows(levels, side) {
      const rows = [];
      let cumulative = 0;
      levels.forEach(level => {
        cumulative += level.size;
        rows.push({ ...level, cum: cumulative });
      });
      return rows;
    }

    function renderOptionsOrderbook(data) {
      const asks = Array.isArray(data.asks) ? data.asks : [];
      const bids = Array.isArray(data.bids) ? data.bids : [];
      const parsedAsks = asks.map(([price, size]) => ({ price: Number(price), size: Number(size) }))
        .filter(item => Number.isFinite(item.price) && Number.isFinite(item.size));
      const parsedBids = bids.map(([price, size]) => ({ price: Number(price), size: Number(size) }))
        .filter(item => Number.isFinite(item.price) && Number.isFinite(item.size));
      parsedAsks.sort((a, b) => a.price - b.price);
      parsedBids.sort((a, b) => b.price - a.price);
      const askRowsRaw = buildOrderbookRows(parsedAsks.slice(0, 25), 'ask');
      const bidRows = buildOrderbookRows(parsedBids.slice(0, 25), 'bid');
      const askRows = askRowsRaw.slice().reverse();
      const bestAsk = parsedAsks.length ? parsedAsks[0].price : null;
      const bestBid = parsedBids.length ? parsedBids[0].price : null;
      const mid = bestAsk && bestBid ? (bestAsk + bestBid) / 2 : (bestAsk || bestBid);
      const midEl = document.getElementById('options_orderbook_mid');
      if (midEl) {
        midEl.textContent = mid ? formatOrderbookValue(mid, 4) : '--';
      }
      const priceDecimals = 4;
      const sizeDecimals = 4;
      const withMeta = (rows) => rows.map(row => ({
        ...row,
        priceDecimals,
        sizeDecimals,
      }));
      renderOrderbookSide(withMeta(askRows), 'ask');
      renderOrderbookSide(withMeta(bidRows), 'bid');
      updateOptionsOrderbookAsOf(data.asof_ms || Date.now());
      setOptionsOrderbookStale(Boolean(data.stale));
    }

    function scheduleOptionsOrderbook(delayMs) {
      if (optionsOrderbookTimer) {
        clearTimeout(optionsOrderbookTimer);
        optionsOrderbookTimer = null;
      }
      optionsOrderbookTimer = setTimeout(fetchOptionsOrderbook, delayMs);
    }

    async function fetchOptionsOrderbook() {
      const symbol = getOptionsChartSymbol();
      if (!symbol) {
        renderOptionsOrderbook({ bids: [], asks: [], stale: false, asof_ms: null });
        return;
      }
      const fastDelay = 1500;
      const staleDelay = 15000;
      try {
        const res = await fetch(`/api/options/orderbook?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
        const data = res.ok ? await res.json() : { stale: true, bids: [], asks: [] };
        renderOptionsOrderbook(data);
        scheduleOptionsOrderbook(data.stale ? staleDelay : fastDelay);
      } catch (err) {
        renderOptionsOrderbook({ bids: [], asks: [], stale: true, asof_ms: Date.now() });
        scheduleOptionsOrderbook(staleDelay);
      }
    }

    function startOptionsOrderbook() {
      scheduleOptionsOrderbook(100);
    }

    function stopOptionsOrderbook() {
      if (optionsOrderbookTimer) {
        clearTimeout(optionsOrderbookTimer);
        optionsOrderbookTimer = null;
      }
    }

    function ensureOptionsChartReady() {
      if (!state.optionsChartVisible) return;
      const container = document.getElementById('options_chart_container');
      if (!container) return;
      const note = document.getElementById('options_chart_note');
      if (!window.LightweightCharts) {
        if (note) note.textContent = currentLang === 'zh' ? '正在加载图表库...' : 'Loading chart library...';
        if (optionsChartInitAttempts < 12) {
          optionsChartInitAttempts += 1;
          setTimeout(ensureOptionsChartReady, 200);
        }
        return;
      }
      initOptionsChart();
      if (!optionsChart || container.clientWidth === 0 || container.clientHeight === 0) {
        if (optionsChartInitAttempts < 12) {
          optionsChartInitAttempts += 1;
          setTimeout(ensureOptionsChartReady, 120);
        }
        return;
      }
      optionsChartInitAttempts = 0;
      resizeOptionsChart();
      loadOptionsInstruments().then(() => {
        updateOptionsSymbolOptions();
        refreshOptionsChart();
        startOptionsChartPolling();
        startOptionsOrderbook();
      });
    }

    function isStreamInterval(interval) {
      return interval === 'tick' || interval === '1s' || interval === '5s';
    }

    function setLiveBadge(interval) {
      const badge = document.getElementById('chart_live_badge');
      if (!badge) return;
      badge.classList.toggle('on', isStreamInterval(interval));
    }

    function setActiveInterval(interval, opts = {}) {
      const select = document.getElementById('chart_interval');
      if (select) select.value = interval;
      document.querySelectorAll('.tf-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.interval === interval);
      });
      setLiveBadge(interval);
      if (opts.skipFetch) return;
      fetchKlines();
      applyChartLocalization();
      startChartPolling();
    }

    function setActiveTool(tool) {
      activeTool = tool;
      document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tool === tool);
      });
      if (tool === 'rect') {
        setDrawMode('box');
      } else if (drawMode) {
        setDrawMode(null);
      }
      if (!chart) return;
      if (tool === 'crosshair') {
        chart.applyOptions({ crosshair: { vertLine: { visible: true }, horzLine: { visible: true } } });
      } else if (tool === 'cursor') {
        chart.applyOptions({ crosshair: { vertLine: { visible: false }, horzLine: { visible: false } } });
      } else {
        chart.applyOptions({ crosshair: { vertLine: { visible: true }, horzLine: { visible: true } } });
      }
    }

    function setActiveSide(side) {
      currentSide = side;
      document.querySelectorAll('.side-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.side === side);
      });
    }

    function setChartSeriesMode(interval) {
      if (!candleSeries || !tickSeries) return;
      const isTick = interval === 'tick';
      tickSeries.applyOptions({ visible: isTick });
      candleSeries.applyOptions({ visible: !isTick });
    }

    function stopTradeStream() {
      if (tradeStream) {
        tradeStream.close();
        tradeStream = null;
      }
      if (streamRetryTimer) {
        clearTimeout(streamRetryTimer);
        streamRetryTimer = null;
      }
      state.streamInterval = '';
    }

    function applyTradeToStream(trade, bucketSeconds) {
      const ts = normalizeTimestamp(trade.ts || trade.time || trade.T);
      const price = Number(trade.price || trade.p || 0);
      const qty = Number(trade.qty || trade.size || trade.v || 0);
      if (!ts || !Number.isFinite(price)) return;
      const bucket = bucketSeconds ? Math.floor(ts / bucketSeconds) * bucketSeconds : ts;
      if (!lastStreamCandle || bucket > lastStreamCandle.time) {
        const candle = {
          time: bucket,
          open: price,
          high: price,
          low: price,
          close: price,
          volume: qty,
        };
        streamCandles.push(candle);
        lastStreamCandle = candle;
        lastStreamBucket = bucket;
        if (candleSeries) candleSeries.update(candle);
        if (volumeSeries) volumeSeries.update(buildVolumeBar(candle));
        if (streamCandles.length > 600) {
          streamCandles = streamCandles.slice(-500);
          if (candleSeries) candleSeries.setData(streamCandles);
          if (volumeSeries) volumeSeries.setData(buildVolumeBars(streamCandles));
        }
      } else {
        lastStreamCandle.high = Math.max(lastStreamCandle.high, price);
        lastStreamCandle.low = Math.min(lastStreamCandle.low, price);
        lastStreamCandle.close = price;
        lastStreamCandle.volume = (lastStreamCandle.volume || 0) + qty;
        if (candleSeries) candleSeries.update(lastStreamCandle);
        if (volumeSeries) volumeSeries.update(buildVolumeBar(lastStreamCandle));
      }
      updateLegendFromLatest();
    }

    function applyTradeToTick(trade) {
      const ts = normalizeTimestamp(trade.ts || trade.time || trade.T);
      const price = Number(trade.price || trade.p || 0);
      if (!ts || !Number.isFinite(price)) return;
      const point = { time: ts, value: price };
      const lastPoint = tickPoints[tickPoints.length - 1];
      if (lastPoint && lastPoint.time === point.time) {
        tickPoints[tickPoints.length - 1] = point;
        if (tickSeries) tickSeries.update(point);
      } else {
        tickPoints.push(point);
        if (tickSeries) tickSeries.update(point);
      }
      if (tickPoints.length > TICK_MAX_POINTS && tickPoints.length % TICK_TRIM_EVERY === 0) {
        tickPoints = tickPoints.slice(-TICK_MAX_POINTS);
        scheduleTickSync();
      }
      updateLegendFromLatest();
    }

    function scheduleTickSync() {
      if (tickUpdateQueued) return;
      tickUpdateQueued = true;
      requestAnimationFrame(() => {
        tickUpdateQueued = false;
        if (tickSeries) {
          tickSeries.setData(tickPoints);
        }
      });
    }

    function startTradeStream(interval) {
      if (chartTimer) {
        clearInterval(chartTimer);
        chartTimer = null;
      }
      stopTradeStream();
      const symbol = getChartSymbol();
      if (!symbol) return;
      state.streamInterval = interval;
      const bucketSeconds = getIntervalSeconds(interval);
      const useStreamOnly = isStreamInterval(interval);
      if (useStreamOnly) {
        streamCandles = [];
        lastStreamCandle = null;
        lastStreamBucket = null;
        if (volumeSeries) volumeSeries.setData([]);
        if (interval === 'tick') {
          tickPoints = [];
          tickSeries.setData([]);
        } else {
          candleSeries.setData([]);
        }
      } else if (!streamCandles.length && chartKlinesCache.length) {
        streamCandles = chartKlinesCache.slice();
        lastStreamCandle = streamCandles[streamCandles.length - 1] || null;
        lastStreamBucket = lastStreamCandle ? lastStreamCandle.time : null;
      }
      const status = document.getElementById('chart_status');
      tradeStream = new EventSource(`/api/trades/stream?symbol=${encodeURIComponent(symbol)}`);
      tradeStream.addEventListener('snapshot', (event) => {
        try {
          if (state.streamInterval !== interval || document.getElementById('chart_interval').value !== interval) return;
          const payload = JSON.parse(event.data);
          const trades = Array.isArray(payload.trades) ? payload.trades : [];
          trades.sort((a, b) => (a.ts || 0) - (b.ts || 0));
          if (interval === 'tick') {
            tickPoints = trades.map(t => {
              const time = normalizeTimestamp(t.ts);
              return time ? { time, value: t.price } : null;
            }).filter(Boolean);
            if (tickSeries) tickSeries.setData(tickPoints);
          } else {
            const minTs = lastStreamCandle ? lastStreamCandle.time : 0;
            trades.forEach(trade => {
              const ts = normalizeTimestamp(trade.ts || trade.time || trade.T);
              if (!ts || ts <= minTs) return;
              applyTradeToStream(trade, bucketSeconds || 1);
            });
          }
        } catch (e) {}
      });
      tradeStream.onmessage = (event) => {
        try {
          if (state.streamInterval !== interval || document.getElementById('chart_interval').value !== interval) return;
          const trade = JSON.parse(event.data);
          if (interval === 'tick') {
            applyTradeToTick(trade);
          } else {
            applyTradeToStream(trade, bucketSeconds || 1);
          }
        } catch (e) {}
      };
      tradeStream.onerror = () => {
        if (status) status.textContent = 'Stream disconnected, retrying...';
        stopTradeStream();
        if (streamRetryTimer) {
          clearTimeout(streamRetryTimer);
          streamRetryTimer = null;
        }
        streamRetryTimer = setTimeout(() => {
          streamRetryTimer = null;
          const currentSymbol = getChartSymbol();
          const currentInterval = document.getElementById('chart_interval').value;
          if (currentSymbol === symbol && currentInterval === interval) {
            startTradeStream(interval);
          }
        }, 2200);
      };
    }

    async function fetchKlines() {
      if (!candleSeries) return;
      const symbol = getChartSymbol();
      const status = document.getElementById('chart_status');
      const note = document.getElementById('chart_note');
      if (note) note.textContent = '';
      if (!symbol) {
        if (status) status.textContent = t('chart_hint');
        return;
      }
      await ensureSymbolPrecision(symbol);
      applyChartPrecision(symbol);
      const interval = document.getElementById('chart_interval').value;
      const isIntervalChange = state.lastKlineInterval !== interval || state.lastKlineSymbol !== symbol;
      if (isIntervalChange) {
        state.chartHasLoaded = false;
        state.lastKlineTime = 0;
        state.newCandleCount = 0;
      }
      setChartSeriesMode(interval);
      if (isStreamInterval(interval)) {
        if (status) status.textContent = `${symbol} · ${interval}`;
        startTradeStream(interval);
        state.chartRange = null;
        state.lastKlineInterval = interval;
        state.lastKlineSymbol = symbol;
        if (candleSeries) {
          candleSeries.setMarkers([]);
        }
        applyChartLocalization();
        requestOverlayUpdate();
        return;
      }
      stopTradeStream();
      if (tickSeries) {
        tickPoints = [];
        tickSeries.setData([]);
      }
      applyChartLocalization();
      const limit = 300;
      const qs = new URLSearchParams({ symbol, interval, limit: String(limit) });
      const res = await fetch(`/api/klines?${qs.toString()}`, { cache: 'no-store' });
      if (!res.ok) {
        if (status) status.textContent = currentLang === 'zh' ? '获取 K 线失败。' : 'Failed to fetch klines.';
        return;
      }
      const data = await res.json();
      if (data.error || !Array.isArray(data.klines)) {
        if (status) status.textContent = data.error || (currentLang === 'zh' ? '暂无 K 线数据。' : 'No kline data available.');
        return;
      }
      suppressRangeTracking = true;
      chartKlinesCache = data.klines;
      streamCandles = data.klines.slice();
      lastStreamCandle = streamCandles.length ? streamCandles[streamCandles.length - 1] : null;
      lastStreamBucket = lastStreamCandle ? lastStreamCandle.time : null;
      candleSeries.setData(data.klines);
      if (volumeSeries) volumeSeries.setData(buildVolumeBars(data.klines));
      if (data.klines.length > 0) {
        const latestTime = data.klines[data.klines.length - 1].time;
        if (latestTime && latestTime !== state.lastKlineTime) {
          if (state.lastKlineTime) {
            state.newCandleCount += 1;
          }
          state.lastKlineTime = latestTime;
        }
      }
      if (chart && !state.chartHasLoaded) {
        chart.timeScale().fitContent();
      }
      suppressRangeTracking = false;
      state.chartHasLoaded = true;
      if (data.klines.length > 1) {
        state.chartRange = {
          from: data.klines[0].time,
          to: data.klines[data.klines.length - 1].time
        };
      }
      state.lastKlineInterval = interval;
      state.lastKlineSymbol = symbol;
      if (status) status.textContent = `${symbol} · ${interval} ${currentLang === 'zh' ? '周期' : 'interval'}`;
      updateLegendFromLatest();
      requestOverlayUpdate();
      startTradeStream(interval);
    }

    function requestOverlayUpdate() {
      if (!state.chartVisible) return;
      if (chartOverlayTimer) return;
      chartOverlayTimer = setTimeout(() => {
        chartOverlayTimer = null;
        state.chartLastOverlayTs = Date.now();
        updateChartOverlays();
      }, 600);
    }


    async function updateChartOverlays() {
      if (!candleSeries) return;
      const symbol = getChartSymbol();
      if (!symbol) return;
      const overlaySeries = getActivePriceSeries();
      if (!overlaySeries) return;

      removeSeriesLines(chartPositionLines);

      const showBreakeven = document.getElementById('chart_show_breakeven').checked;
      const showLiq = document.getElementById('chart_show_liq').checked;
      const showOrders = document.getElementById('chart_show_orders').checked;
      const showTrades = document.getElementById('chart_show_trades').checked;
      const intervalValue = document.getElementById('chart_interval').value;

      try {
        const posRes = await fetch('/api/positions', { cache: 'no-store' });
        if (posRes.ok) {
          const posData = await posRes.json();
          const positions = Array.isArray(posData.positions) ? posData.positions : [];
          const pos = positions.find(p => (p.symbol || p.Symbol) === symbol);
          if (pos) {
            const breakeven = parseFloat(pos.breakEvenPrice || pos.BreakEvenPrice || '');
            const liq = parseFloat(pos.liqPrice || pos.LiqPrice || '');
            if (showBreakeven && Number.isFinite(breakeven) && breakeven > 0) {
              const line = overlaySeries.createPriceLine({
                price: breakeven,
                color: '#d7dee8',
                lineWidth: 1,
                lineStyle: 2,
                axisLabelVisible: true,
                title: t('chart_break_even'),
              });
              chartPositionLines.push({ series: overlaySeries, line });
            }
            if (showLiq && Number.isFinite(liq) && liq > 0) {
              const line = overlaySeries.createPriceLine({
                price: liq,
                color: '#ff6b6b',
                lineWidth: 1,
                lineStyle: 3,
                axisLabelVisible: true,
                title: t('chart_liq'),
              });
              chartPositionLines.push({ series: overlaySeries, line });
            }
          }
        }
      } catch (e) {}

      let combinedMarkers = [];
      if (showTrades && intervalValue !== 'tick') {
        const range = state.chartRange;
        if (!range) return;
        const markers = [];
        const intervalSeconds = getIntervalSeconds(intervalValue);
        if (intervalSeconds > 0 && intervalSeconds < 60) {
          candleSeries.setMarkers([]);
          chartMarkersCache = [];
          state.chartMarkerSignature = '';
          return;
        }
        const bucketMap = new Map();
        const trades = state.history.filter(r => r.symbol === symbol);
        for (const trade of trades) {
          const ts = Number(trade.ts || 0);
          if (!Number.isFinite(ts) || ts <= 0) continue;
          const bucketTime = intervalSeconds > 0 ? Math.floor(ts / intervalSeconds) * intervalSeconds : ts;
          if (bucketTime < range.from || bucketTime > range.to) continue;
          const existing = bucketMap.get(bucketTime);
          if (!existing || ts > existing.ts) {
            bucketMap.set(bucketTime, { trade, ts, bucketTime });
          }
        }
        for (const item of bucketMap.values()) {
          const trade = item.trade;
          const side = String(trade.side || '').toLowerCase();
          const isBuy = side.startsWith('b');
          markers.push({
            time: item.bucketTime,
            position: isBuy ? 'belowBar' : 'aboveBar',
            color: isBuy ? '#27d07d' : '#ff6b6b',
            shape: isBuy ? 'arrowUp' : 'arrowDown',
            text: isBuy ? 'B' : 'S',
          });
        }
        if (markers.length > 200) {
          const status = document.getElementById('chart_status');
          if (status) status.textContent = 'Too many trades in range. Zoom in or reduce interval.';
          candleSeries.setMarkers([]);
          chartMarkersCache = [];
          state.chartMarkerSignature = '';
          return;
        }
        const sig = `${symbol}|${range.from}|${range.to}|${markers.length}|${markers[0]?.time || 0}|${markers[markers.length - 1]?.time || 0}`;
        if (sig !== state.chartMarkerSignature) {
          chartMarkersCache = markers;
          state.chartMarkerSignature = sig;
        }
        combinedMarkers = combinedMarkers.concat(chartMarkersCache);
      }

      if (combinedMarkers.length) {
        candleSeries.setMarkers(combinedMarkers);
      } else {
        candleSeries.setMarkers([]);
        chartMarkersCache = [];
        state.chartMarkerSignature = '';
      }
    }

    function getIntervalSeconds(intervalValue) {
      if (intervalValue === '5s') return 5;
      if (intervalValue === '1s') return 1;
      if (intervalValue === 'tick') return 1;
      if (/^\d+$/.test(intervalValue)) {
        return parseInt(intervalValue, 10) * 60;
      }
      if (intervalValue === 'D') return 86400;
      return 0;
    }

    function normalizeTimestamp(ts) {
      const value = Number(ts);
      if (!Number.isFinite(value) || value <= 0) return null;
      if (value > 1e12) return Math.floor(value / 1000);
      return Math.floor(value);
    }

    function formatPrice(value) {
      if (value === null || value === undefined || !Number.isFinite(value)) return '-';
      return new Intl.NumberFormat('en-US', { maximumFractionDigits: 6 }).format(value);
    }

    function formatVolume(value) {
      if (value === null || value === undefined || !Number.isFinite(value)) return '-';
      return new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 }).format(value);
    }

    function formatPercent(value) {
      if (value === null || value === undefined || !Number.isFinite(value)) return '-';
      return `${value.toFixed(2)}%`;
    }

    function decimalsFromValue(step) {
      if (!step) return 0;
      const text = String(step).toLowerCase();
      if (text.includes('e-')) {
        const exp = Number(text.split('e-')[1]);
        return Number.isFinite(exp) ? exp : 0;
      }
      if (text.includes('e+')) return 0;
      if (!text.includes('.')) return 0;
      const decimals = text.split('.')[1].replace(/0+$/, '');
      return decimals.length;
    }

    function getDecimalsFromStep(step) {
      return decimalsFromValue(step);
    }

    function formatWithDecimals(value, decimals, fallback = '-') {
      if (value === null || value === undefined || !Number.isFinite(value)) return fallback;
      const formatter = new Intl.NumberFormat('en-US', {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
      return formatter.format(value);
    }

    async function ensureSymbolPrecision(symbol) {
      if (!symbol) return null;
      if (symbolPrecision[symbol]) return symbolPrecision[symbol];
      try {
        const res = await fetch(`/api/instruments?symbol=${encodeURIComponent(symbol)}`, { cache: 'no-store' });
        if (!res.ok) return null;
        const data = await res.json();
        if (!data || data.ok === false) return null;
        const info = data.data || {};
        const priceStep = info.priceFilter?.tickSize || info.tickSize || '';
        const qtyStep = info.lotSizeFilter?.qtyStep || info.qtyStep || '';
        const basePrecision = info.lotSizeFilter?.basePrecision || info.basePrecision || '';
        const priceScale = Number(info.priceScale);
        const tickDecimals = getDecimalsFromStep(priceStep);
        const priceDecimals = Number.isFinite(priceScale)
          ? Math.max(priceScale, tickDecimals)
          : tickDecimals;
        const qtyDecimals = getDecimalsFromStep(qtyStep || basePrecision);
        symbolPrecision[symbol] = {
          priceDecimals: Number.isFinite(priceDecimals) ? priceDecimals : 2,
          qtyDecimals: Number.isFinite(qtyDecimals) ? qtyDecimals : 2,
          tickSize: priceStep || '',
          qtyStep: qtyStep || basePrecision || '',
        };
      } catch (err) {
        if (err?.name === 'AbortError') return null;
        return null;
      }
      return symbolPrecision[symbol];
    }

    function getPrecisionForSymbol(symbol) {
      return symbolPrecision[symbol] || { priceDecimals: 2, qtyDecimals: 2, tickSize: '', qtyStep: '' };
    }

    function applyChartPrecision(symbol) {
      if (!chart || !symbol) return;
      const precision = getPrecisionForSymbol(symbol);
      const tickSize = Number(precision.tickSize);
      const minMove = Number.isFinite(tickSize) && tickSize > 0
        ? tickSize
        : Math.pow(10, -precision.priceDecimals);
      const priceFormat = {
        type: 'price',
        precision: precision.priceDecimals,
        minMove,
      };
      if (candleSeries) candleSeries.applyOptions({ priceFormat });
      if (tickSeries) tickSeries.applyOptions({ priceFormat });
      const priceInput = document.getElementById('chart_order_price');
      if (priceInput && precision.tickSize) priceInput.step = String(precision.tickSize);
      const qtyInput = document.getElementById('chart_order_qty');
      if (qtyInput && precision.qtyStep) qtyInput.step = String(precision.qtyStep);
    }

    function buildVolumeBar(candle) {
      if (!candle) return { time: 0, value: 0, color: 'rgba(77, 214, 197, 0.6)' };
      return {
        time: candle.time,
        value: candle.volume || 0,
        color: candle.close >= candle.open ? 'rgba(77, 214, 197, 0.6)' : 'rgba(255, 107, 107, 0.6)',
      };
    }

    function buildVolumeBars(candles) {
      return (candles || []).map(buildVolumeBar);
    }

    function removeSeriesLines(list) {
      if (!Array.isArray(list)) return;
      list.forEach(entry => {
        if (entry?.series && entry?.line) {
          entry.series.removePriceLine(entry.line);
        }
      });
      list.length = 0;
    }

    function getActivePriceSeries() {
      const intervalValue = document.getElementById('chart_interval')?.value || '1';
      return intervalValue === 'tick' ? tickSeries : candleSeries;
    }

    function updateLegend(candle, idx) {
      const legend = chartLegendEl || document.getElementById('chartLegend');
      if (!legend || !candle) return;
      if (!chartLegendEl) chartLegendEl = legend;
      const precision = getPrecisionForSymbol(getChartSymbol());
      const formatLegendPrice = (value) => formatWithDecimals(value, precision.priceDecimals, formatPrice(value));
      const formatLegendVolume = (value) => formatWithDecimals(value, precision.qtyDecimals, formatVolume(value));
      const candles = streamCandles.length ? streamCandles : chartKlinesCache;
      const prevClose = idx > 0 && candles[idx - 1] ? candles[idx - 1].close : null;
      const change = prevClose ? ((candle.close - prevClose) / prevClose) * 100 : null;
      const changeClass = change === null ? '' : (change >= 0 ? 'value-positive' : 'value-negative');
      const changeLabel = change === null ? '-' : formatPercent(change);
      const timeLabel = candle.time ? new Date(candle.time * 1000).toLocaleString() : '-';
      legend.innerHTML = `
        <div class="legend-row">
          <span class="legend-label">O</span><span class="legend-value">${formatLegendPrice(candle.open)}</span>
          <span class="legend-label">H</span><span class="legend-value">${formatLegendPrice(candle.high)}</span>
          <span class="legend-label">L</span><span class="legend-value">${formatLegendPrice(candle.low)}</span>
          <span class="legend-label">C</span><span class="legend-value">${formatLegendPrice(candle.close)}</span>
        </div>
        <div class="legend-row">
          <span class="legend-label">Δ</span><span class="legend-value ${changeClass}">${changeLabel}</span>
          <span class="legend-label">Vol</span><span class="legend-value">${formatLegendVolume(candle.volume || 0)}</span>
        </div>
        <div class="legend-row">
          <span class="legend-label legend-time">${timeLabel}</span>
        </div>
      `;
    }

    function updateLegendFromLatest() {
      const candles = streamCandles.length ? streamCandles : chartKlinesCache;
      if (candles.length) {
        const candle = candles[candles.length - 1];
        updateLegend(candle, candles.length - 1);
        return;
      }
      const latestTick = tickPoints[tickPoints.length - 1];
      if (!latestTick) return;
      updateLegend({
        time: latestTick.time,
        open: latestTick.value,
        high: latestTick.value,
        low: latestTick.value,
        close: latestTick.value,
        volume: 0,
      }, 0);
    }

    function computeSMA(candles, period) {
      const result = [];
      for (let i = period - 1; i < candles.length; i += 1) {
        const slice = candles.slice(i - period + 1, i + 1);
        const sum = slice.reduce((acc, c) => acc + c.close, 0);
        result.push({ time: candles[i].time, value: sum / period });
      }
      return result;
    }

    function computeEMA(candles, period) {
      const result = [];
      if (candles.length < period) return result;
      const multiplier = 2 / (period + 1);
      let ema = candles.slice(0, period).reduce((acc, c) => acc + c.close, 0) / period;
      result.push({ time: candles[period - 1].time, value: ema });
      for (let i = period; i < candles.length; i += 1) {
        ema = (candles[i].close - ema) * multiplier + ema;
        result.push({ time: candles[i].time, value: ema });
      }
      return result;
    }

    function computeVWAP(candles) {
      const result = [];
      let cumulativePV = 0;
      let cumulativeVolume = 0;
      candles.forEach(candle => {
        const volume = candle.volume || 0;
        const typical = (candle.high + candle.low + candle.close) / 3;
        cumulativePV += typical * volume;
        cumulativeVolume += volume;
        if (cumulativeVolume > 0) {
          result.push({ time: candle.time, value: cumulativePV / cumulativeVolume });
        }
      });
      return result;
    }

    function rebuildIndicators() {
      if (!chart) return;
      const candles = streamCandles.length ? streamCandles : chartKlinesCache;
      if (!candles.length) return;
      const configs = {
        ma20: { type: 'ma', period: 20, color: '#4dd6c5' },
        ema20: { type: 'ema', period: 20, color: '#a0b3ff' },
        vwap: { type: 'vwap', color: '#f4d35e' },
      };
      Object.entries(configs).forEach(([key, cfg]) => {
        if (!indicatorsEnabled[key]) {
          if (indicatorSeries.has(key)) {
            chart.removeSeries(indicatorSeries.get(key));
            indicatorSeries.delete(key);
          }
          return;
        }
        if (!indicatorSeries.has(key)) {
          const series = chart.addLineSeries({
            color: cfg.color,
            lineWidth: 2,
            priceLineVisible: false,
            lastValueVisible: false,
          });
          indicatorSeries.set(key, series);
        }
        const series = indicatorSeries.get(key);
        let data = [];
        if (cfg.type === 'ma') data = computeSMA(candles, cfg.period);
        if (cfg.type === 'ema') data = computeEMA(candles, cfg.period);
        if (cfg.type === 'vwap') data = computeVWAP(candles);
        series.setData(data);
      });
    }

    function toggleIndicator(key, enabled) {
      indicatorsEnabled[key] = enabled;
      if (!enabled && indicatorSeries.has(key)) {
        const series = indicatorSeries.get(key);
        chart.removeSeries(series);
        indicatorSeries.delete(key);
      }
      rebuildIndicators();
    }

    function bindIndicatorDropdown() {
      const dropdown = document.getElementById('chart_indicator_dropdown');
      if (!dropdown || indicatorDropdownBound) return;
      indicatorDropdownBound = true;
      document.addEventListener('mousedown', event => {
        if (!dropdown.contains(event.target)) dropdown.classList.remove('open');
      });
      const toggle = dropdown.querySelector('.dropdown-toggle');
      if (toggle) {
        toggle.addEventListener('click', () => dropdown.classList.toggle('open'));
      }
    }

    function scheduleIndicatorRecalc() {
      if (indicatorTimer) return;
      indicatorTimer = setTimeout(() => {
        indicatorTimer = null;
        rebuildIndicators();
      }, 200);
    }

    function startChartPolling() {
      if (chartTimer) {
        clearInterval(chartTimer);
        chartTimer = null;
      }
      const interval = document.getElementById('chart_interval').value;
      if (isStreamInterval(interval)) return;
      if (state.streamInterval) return;
      const auto = document.getElementById('chart_auto').checked;
      if (!auto) return;
      const refresh = parseInt(document.getElementById('chart_refresh').value || '5000', 10);
      chartTimer = setInterval(fetchKlines, isNaN(refresh) ? 5000 : refresh);
    }

    function exportHistory() {
      exportHistoryBybitCsv();
    }

    function pad2(value) {
      return String(value).padStart(2, '0');
    }

    function formatUtcTime(tsSeconds) {
      if (!tsSeconds) return '';
      const ms = tsSeconds > 1000000000000 ? tsSeconds : tsSeconds * 1000;
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return '';
      return `${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())} ${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-${pad2(d.getUTCDate())}`;
    }

    function csvEscape(value) {
      if (value === null || value === undefined) return '';
      const str = String(value);
      if (/[",\n]/.test(str)) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    }

    function downloadCsv(filename, rows, columns) {
      const header = columns.map(col => csvEscape(col.label)).join(',');
      const lines = [header];
      for (const row of rows) {
        const line = columns.map(col => csvEscape(row[col.key] ?? '')).join(',');
        lines.push(line);
      }
      const text = lines.join('\n');
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([text], { type: 'text/csv' }));
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function formatDateStamp(value) {
      if (!value) return '';
      const d = new Date(value);
      if (Number.isNaN(d.getTime())) return '';
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth() + 1).padStart(2, '0');
      const day = String(d.getUTCDate()).padStart(2, '0');
      return `${y}${m}${day}`;
    }


    function buildExportFilename(prefix, symbol, startDate, endDate, days) {
      const symbolTag = symbol ? symbol : 'ALL';
      const startTag = startDate ? formatDateStamp(`${startDate}T00:00:00Z`) : '';
      const endTag = endDate ? formatDateStamp(`${endDate}T00:00:00Z`) : '';
      if (startTag || endTag) {
        const rangeTag = `${startTag || 'NA'}-${endTag || 'NA'}`;
        return `${prefix}_${symbolTag}_${rangeTag}.csv`;
      }
      return `${prefix}_${symbolTag}_${days || 'range'}d.csv`;
    }

    function buildBybitOrderHistoryRows(fills) {
      const orders = new Map();
      for (const fill of fills || []) {
        if (!fill || !fill.order_id) continue;
        const symbol = fill.symbol || '';
        const side = fill.side || '';
        const key = `${fill.order_id}|${symbol}|${side}`;
        const qty = Number(fill.qty) || 0;
        const price = Number(fill.price) || 0;
        const fee = Number(fill.fee) || 0;
        const feeCcy = fill.fee_ccy || '';
        let entry = orders.get(key);
        if (!entry) {
          entry = {
            order_id: fill.order_id,
            symbol,
            side,
            qty: 0,
            notional: 0,
            min_ts: fill.ts || 0,
            max_ts: fill.ts || 0,
            fee_by_ccy: {}
          };
          orders.set(key, entry);
        }
        entry.qty += qty;
        entry.notional += qty * price;
        entry.min_ts = Math.min(entry.min_ts || fill.ts || 0, fill.ts || 0);
        entry.max_ts = Math.max(entry.max_ts || fill.ts || 0, fill.ts || 0);
        if (feeCcy) {
          entry.fee_by_ccy[feeCcy] = (entry.fee_by_ccy[feeCcy] || 0) + fee;
        }
      }

      const rows = [];
      for (const entry of orders.values()) {
        const filledPrice = entry.qty ? entry.notional / entry.qty : '';
        const feeInfo = Object.keys(entry.fee_by_ccy).length ? JSON.stringify(entry.fee_by_ccy) : '';
        const suffix = entry.order_id.slice(-8);
        rows.push({
          market: entry.symbol,
          order_qty: entry.qty || '',
          order_price: filledPrice || '',
          filled_price: filledPrice || '',
          trigger_price: '',
          filled_qty: entry.qty || '',
          fee_info: feeInfo,
          direction: entry.side === 'Buy' ? 'Long' : entry.side === 'Sell' ? 'Short' : entry.side,
          order_type: '',
          order_status: entry.qty ? 'Filled' : '',
          order_id: suffix,
          order_time: formatUtcTime(entry.min_ts),
          tif: '',
          create_time: formatUtcTime(entry.min_ts),
          max_slippage: '',
          max_slippage_type: '',
          limit_tpsl_strategy: '',
          bbo_side_type: '',
          bbo_level: ''
        });
      }

      rows.sort((a, b) => (b.order_time || '').localeCompare(a.order_time || ''));
      return rows;
    }

    function formatUtcFromMs(value) {
      if (!value) return '';
      const ms = Number(value);
      if (!Number.isFinite(ms)) return '';
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return '';
      return `${String(d.getUTCHours()).padStart(2, '0')}:${String(d.getUTCMinutes()).padStart(2, '0')} ${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}-${String(d.getUTCDate()).padStart(2, '0')}`;
    }

    function buildOrderHistoryRows(orders) {
      return (orders || []).map(o => {
        const orderId = o.orderId || o.orderID || '';
        const orderQty = o.qty ?? o.orderQty ?? '';
        const filledQty = o.cumExecQty ?? o.filledQty ?? '';
        const avgPrice = o.avgPrice ?? o.filledPrice ?? '';
        const orderPrice = o.price ?? o.orderPrice ?? '';
        return {
          market: o.symbol || '',
          order_qty: orderQty,
          order_price: orderPrice,
          filled_price: avgPrice,
          trigger_price: o.triggerPrice ?? '',
          filled_qty: filledQty,
          fee_info: o.feeInfo ?? '',
          direction: o.side === 'Buy' ? 'Long' : o.side === 'Sell' ? 'Short' : (o.side || ''),
          order_type: o.orderType || '',
          order_status: o.orderStatus || '',
          order_id: orderId ? String(orderId).slice(-8) : '',
          order_time: formatUtcFromMs(o.updatedTime || o.createdTime || ''),
          tif: o.timeInForce || '',
          create_time: formatUtcFromMs(o.createdTime || ''),
          max_slippage: o.maxSlippage ?? '',
          max_slippage_type: o.maxSlippageType ?? '',
          limit_tpsl_strategy: o.tpslMode ?? '',
          bbo_side_type: o.bboSideType ?? '',
          bbo_level: o.bboLevel ?? ''
        };
      });
    }

    function buildFillRows(fills) {
      return (fills || []).map(f => {
        const ts = f.ts ? new Date(f.ts * 1000) : null;
        const timeStr = ts ? `${String(ts.getUTCHours()).padStart(2, '0')}:${String(ts.getUTCMinutes()).padStart(2, '0')} ${ts.getUTCFullYear()}-${String(ts.getUTCMonth() + 1).padStart(2, '0')}-${String(ts.getUTCDate()).padStart(2, '0')}` : '';
        return {
          time: timeStr,
          symbol: f.symbol || '',
          side: f.side || '',
          qty: f.qty ?? '',
          price: f.price ?? '',
          notional: f.notional ?? '',
          fee: f.fee ?? '',
          fee_ccy: f.fee_ccy || '',
          exec_pnl: f.exec_pnl ?? '',
          order_id: f.order_id || '',
          is_maker: f.is_maker ?? ''
        };
      });
    }

    function getFillColumns() {
      return [
        { key: 'time', label: 'Time(UTC)' },
        { key: 'symbol', label: 'Symbol' },
        { key: 'side', label: 'Side' },
        { key: 'qty', label: 'Qty' },
        { key: 'price', label: 'Price' },
        { key: 'notional', label: 'Notional' },
        { key: 'fee', label: 'Fee' },
        { key: 'fee_ccy', label: 'Fee Ccy' },
        { key: 'exec_pnl', label: 'Exec PnL' },
        { key: 'order_id', label: 'Order ID' },
        { key: 'is_maker', label: 'Is Maker' }
      ];
    }

    function getBybitOrderHistoryColumns() {
      return [
        { key: 'market', label: 'Market' },
        { key: 'order_qty', label: 'Order Quantity' },
        { key: 'order_price', label: 'Order Price' },
        { key: 'filled_price', label: 'Filled Price' },
        { key: 'trigger_price', label: 'Trigger Price' },
        { key: 'filled_qty', label: 'Filled Quantity' },
        { key: 'fee_info', label: 'feeInfo' },
        { key: 'direction', label: 'Direction' },
        { key: 'order_type', label: 'Order Type' },
        { key: 'order_status', label: 'Order Status' },
        { key: 'order_id', label: 'Order ID' },
        { key: 'order_time', label: 'Order Time(UTC+0)' },
        { key: 'tif', label: 'Time In Force' },
        { key: 'create_time', label: 'Create Time' },
        { key: 'max_slippage', label: 'Max Slippage' },
        { key: 'max_slippage_type', label: 'Max Slippage Type' },
        { key: 'limit_tpsl_strategy', label: 'Limit Tpsl Strategy' },
        { key: 'bbo_side_type', label: 'Bbo Side Type' },
        { key: 'bbo_level', label: 'Bbo Level' }
      ];
    }

    function exportHistoryBybitCsv() {
      const columns = getBybitOrderHistoryColumns();
      const rows = buildBybitOrderHistoryRows(getFilteredHistoryRows(null));
      const symbol = getHistorySymbol();
      const { startTs, endTs } = getDateRangeFromInputs('filter_start', 'filter_end');
      const startDate = startTs ? new Date(startTs * 1000).toISOString().slice(0, 10) : '';
      const endDate = endTs ? new Date(endTs * 1000).toISOString().slice(0, 10) : '';
      const filename = buildExportFilename('trade_history_bybit', symbol, startDate, endDate, '');
      downloadCsv(filename, rows, columns);
    }

    function clearHistory() {
      if (!confirm(currentLang === 'zh' ? '清除本地交易历史？' : 'Clear local trade history?')) return;
      state.history = [];
      state.historyIndex = new Set();
      saveHistory();
      updateSymbolOptions();
      renderHistory();
      renderConsistency();
    }

    loadHistory();
    setLanguage('zh');
    setActiveInterval('1', { skipFetch: true });
    setActiveTool('cursor');
    setActiveSide('Buy');
    bindIndicatorDropdown();
    updateChartHeight(460);
    updateChartOrderMode();
    updateSymbolOptions();
    applyTabs();
    syncAnalysisDateRangeUI();
    syncAdvancedDateRangeUI();
    document.getElementById('apply_filters').addEventListener('click', () => {
      renderHistory();
      renderConsistency();
    });
    document.getElementById('export_history').addEventListener('click', exportHistory);
    document.getElementById('clear_history').addEventListener('click', clearHistory);
    document.getElementById('refresh_analysis').addEventListener('click', fetchAnalysis);
    document.getElementById('generate_advanced').addEventListener('click', fetchAdvancedAnalysis);
    document.getElementById('refresh_positions').addEventListener('click', fetchPositions);
    document.getElementById('enable_trading').addEventListener('click', enableTrading);
    document.getElementById('disable_trading').addEventListener('click', disableTrading);
    document.getElementById('refresh_orders').addEventListener('click', () => fetchOrders(''));
    const optionsSourceSelect = document.getElementById('options_greeks_source');
    if (optionsSourceSelect) {
      optionsSourceSelect.addEventListener('change', async () => {
        await fetchOptionsReport();
        if (state.analysisData) {
          renderAnalysis(state.analysisData, state.analysisMode || 'full');
        }
      });
    }
    const optionsSymbolSelect = document.getElementById('options_symbol');
    if (optionsSymbolSelect) {
      optionsSymbolSelect.addEventListener('change', () => {
        if (state.analysisData) {
          renderAnalysis(state.analysisData, state.analysisMode || 'full');
        }
      });
    }
    const optionsBybitBtn = document.getElementById('options_use_bybit');
    if (optionsBybitBtn) {
      optionsBybitBtn.addEventListener('click', async () => {
        const sel = document.getElementById('options_greeks_source');
        if (sel) sel.value = 'bybit';
        await fetchOptionsReport();
        if (state.analysisData) {
          renderAnalysis(state.analysisData, state.analysisMode || 'full');
        }
      });
    }
    document.getElementById('lang_select').addEventListener('change', (e) => setLanguage(e.target.value));
    document.getElementById('open_trading_modal').addEventListener('click', () => {
      document.getElementById('trading_modal').classList.add('active');
      loadTradingStatus();
      updateTradingFormState();
    });
    const on = (id, evt, fn) => {
      const el = document.getElementById(id);
      if (el) el.addEventListener(evt, fn);
    };
    on('close_trading_modal', 'click', () => {
      const modal = document.getElementById('trading_modal');
      if (modal) modal.classList.remove('active');
    });
    on('open_donate', 'click', () => {
      const modal = document.getElementById('donate_modal');
      if (modal) modal.classList.add('active');
    });
    on('close_donate_modal', 'click', () => {
      const modal = document.getElementById('donate_modal');
      if (modal) modal.classList.remove('active');
    });
    on('close_position_modal', 'click', () => {
      const modal = document.getElementById('position_modal');
      if (modal) modal.classList.remove('active');
    });
    on('trading_modal', 'click', (e) => {
      if (e.target.id === 'trading_modal') {
        const modal = document.getElementById('trading_modal');
        if (modal) modal.classList.remove('active');
      }
    });
    on('donate_modal', 'click', (e) => {
      if (e.target.id === 'donate_modal') {
        const modal = document.getElementById('donate_modal');
        if (modal) modal.classList.remove('active');
      }
    });
    on('position_modal', 'click', (e) => {
      if (e.target.id === 'position_modal') {
        const modal = document.getElementById('position_modal');
        if (modal) modal.classList.remove('active');
      }
    });
    on('trade_ack', 'change', updateTradingFormState);
    on('trade_use_env', 'change', updateTradingFormState);
    on('trade_demo', 'change', updateTradingFormState);
    on('trade_api_key', 'input', updateTradingFormState);
    on('trade_api_secret', 'input', updateTradingFormState);
    on('chart_order_mode', 'change', updateChartOrderMode);
    on('chart_buy', 'click', () => submitChartOrder('Buy'));
    on('chart_sell', 'click', () => submitChartOrder('Sell'));
    on('position_set_tpsl', 'click', submitPositionTpSl);
    on('position_smart_tp', 'click', submitSmartTp);
    on('position_smart_sl', 'click', submitSmartSl);
    on('position_close', 'click', submitPositionClose);
    on('chart_height', 'input', (e) => updateChartHeight(e.target.value));
    on('chart_symbol', 'change', () => {
      fetchKlines();
      requestOverlayUpdate();
      updateOrdersOverlay();
    });
    on('chart_interval', 'change', () => {
      setActiveInterval(document.getElementById('chart_interval').value);
    });
    on('chart_refresh', 'change', startChartPolling);
    on('chart_auto', 'change', startChartPolling);
    on('chart_show_breakeven', 'change', requestOverlayUpdate);
    on('chart_show_liq', 'change', requestOverlayUpdate);
    on('chart_show_orders', 'change', updateOrdersOverlay);
    on('chart_show_trades', 'change', requestOverlayUpdate);
    on('chart_ind_ma', 'change', (e) => toggleIndicator('ma20', e.target.checked));
    on('chart_ind_ema', 'change', (e) => toggleIndicator('ema20', e.target.checked));
    on('chart_ind_vwap', 'change', (e) => toggleIndicator('vwap', e.target.checked));
    on('chart_reload', 'click', () => {
      fetchKlines();
    });
    on('options_chart_reload', 'click', refreshOptionsChart);
    on('options_chart_interval', 'change', refreshOptionsChart);
    on('options_chart_interval', 'change', applyOptionsChartLocalization);
    on('options_chart_refresh', 'change', startOptionsChartPolling);
    on('options_chart_auto', 'change', startOptionsChartPolling);
    on('options_chart_symbol', 'change', () => {
      optionsChartHasLoaded = false;
      refreshOptionsChart();
      startOptionsOrderbook();
    });
    on('options_chart_expiry', 'change', () => {
      updateOptionsSymbolOptions();
      optionsChartHasLoaded = false;
      refreshOptionsChart();
      startOptionsOrderbook();
    });
    on('options_chart_type', 'change', () => {
      updateOptionsSymbolOptions();
      optionsChartHasLoaded = false;
      refreshOptionsChart();
      startOptionsOrderbook();
    });
    on('options_show_iv', 'change', (e) => setOptionsMetricEnabled('iv', e.target.checked));
    on('options_show_delta', 'change', (e) => setOptionsMetricEnabled('delta', e.target.checked));
    on('options_show_vega', 'change', (e) => setOptionsMetricEnabled('vega', e.target.checked));
    document.querySelectorAll('.tf-btn').forEach(btn => {
      btn.addEventListener('click', () => setActiveInterval(btn.dataset.interval));
    });
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => setActiveTool(btn.dataset.tool));
    });
    document.querySelectorAll('.side-btn').forEach(btn => {
      btn.addEventListener('click', () => setActiveSide(btn.dataset.side));
    });
    const drawSvg = document.getElementById('chart_drawings');
    if (drawSvg) {
      drawSvg.addEventListener('pointerdown', startDraw);
      drawSvg.addEventListener('pointermove', updateDraw);
      drawSvg.addEventListener('pointerup', endDraw);
      drawSvg.addEventListener('pointerleave', endDraw);
    }
    on('chart_draw_box', 'click', () => {
      setDrawMode(drawMode === 'box' ? null : 'box');
    });
    on('chart_clear_drawings', 'click', () => {
      drawings = [];
      drawStart = null;
      drawTempRect = null;
      renderDrawings();
    });
    on('chart_add_symbol', 'click', () => {
      const input = document.getElementById('chart_custom_symbol');
      if (!input) return;
      const symbol = (input.value || '').trim().toUpperCase();
      if (!symbol) return;
      if (!state.customSymbols.includes(symbol)) {
        state.customSymbols.push(symbol);
        updateSymbolOptions();
      }
      const chartSelect = document.getElementById('chart_symbol');
      if (chartSelect) chartSelect.value = symbol;
      input.value = '';
      fetchKlines();
    });
    on('filter_symbol', 'change', () => {
      renderHistory();
      renderConsistency();
    });
    on('analysis_timeframe', 'change', () => {
      document.getElementById('analysis_use_range').checked = false;
      syncAnalysisDateRangeUI();
    });
    on('analysis_use_range', 'change', syncAnalysisDateRangeUI);
    on('advanced_timeframe', 'change', () => {
      document.getElementById('advanced_use_range').checked = false;
      syncAdvancedDateRangeUI();
    });
    on('advanced_use_range', 'change', syncAdvancedDateRangeUI);
    on('export_analysis', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('source', 'rest');
      qs.set('limit', '20000');
      let startVal = '';
      let endVal = '';
      if (isAnalysisDateRangeEnabled()) {
        startVal = document.getElementById('analysis_start')?.value || '';
        endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/analysis/fills?${qs.toString()}`).then(r => r.json()).then(data => {
        const fills = Array.isArray(data?.fills) ? data.fills : [];
        const rows = buildBybitOrderHistoryRows(fills);
        const columns = getBybitOrderHistoryColumns();
        const filename = buildExportFilename('analysis_bybit', symbol, startVal, endVal, days);
        downloadCsv(filename, rows, columns);
      }).catch(e => alert(t('alert_export_error')));
    });
    on('export_analysis_fills', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('source', 'rest');
      qs.set('limit', '20000');
      let startVal = '';
      let endVal = '';
      if (isAnalysisDateRangeEnabled()) {
        startVal = document.getElementById('analysis_start')?.value || '';
        endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/analysis/fills?${qs.toString()}`).then(r => r.json()).then(data => {
        const fills = Array.isArray(data?.fills) ? data.fills : [];
        const rows = buildFillRows(fills);
        const columns = getFillColumns();
        const filename = buildExportFilename('analysis_fills', symbol, startVal, endVal, days);
        downloadCsv(filename, rows, columns);
      }).catch(e => alert(t('alert_export_error')));
    });
    on('export_order_history', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('limit', '20000');
      let startVal = '';
      let endVal = '';
      if (isAnalysisDateRangeEnabled()) {
        startVal = document.getElementById('analysis_start')?.value || '';
        endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/orders/history?${qs.toString()}`).then(r => r.json()).then(data => {
        const orders = Array.isArray(data?.orders) ? data.orders : [];
        const rows = buildOrderHistoryRows(orders);
        const columns = getBybitOrderHistoryColumns();
        const filename = buildExportFilename('order_history', symbol, startVal, endVal, days);
        downloadCsv(filename, rows, columns);
      }).catch(e => alert(t('alert_export_error')));
    });
    on('compare_sources', 'click', () => {
      const days = document.getElementById('analysis_timeframe').value;
      const symbol = getAnalysisSymbol();
      const qs = new URLSearchParams({ days, symbol: symbol || '' });
      qs.set('limit', '20000');
      if (isAnalysisDateRangeEnabled()) {
        const startVal = document.getElementById('analysis_start')?.value || '';
        const endVal = document.getElementById('analysis_end')?.value || '';
        if (startVal) qs.set('start', startVal);
        if (endVal) qs.set('end', endVal);
      }
      fetch(`/api/analysis/compare?${qs.toString()}`).then(r => r.json()).then(data => {
        state.analysisCompare = data && data.ok ? data : null;
        if (state.analysisData) {
          renderAnalysis(state.analysisData, state.analysisMode || 'full');
        } else {
          document.getElementById('analysis_content').innerHTML = renderCompareBlock(state.analysisCompare);
        }
      }).catch(e => alert(t('alert_export_error')));
    });
    renderHistory();
    renderConsistency();
    fetchStatus();
    fetchMetrics();
    loadTradingStatus();
    updateTradingFormState();
    initChart();
    ensureChartReady();
    setInterval(fetchStatus, 5000);
    setInterval(fetchMetrics, 2000);
    // Auto-refresh positions every 10 seconds if in realtime mode
    setInterval(() => {
      if (state.metrics && (state.metrics.mode === 'realtime' || state.metrics.mode === 'sync')) {
        fetchPositions();
      }
    }, 10000);
  </script>
</body>
</html>
